<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Browse smarter. Collect better ‚Äì Developed by Unscoop">
    <title>CRONOS.WTF | Developed by Unscoop</title>

    <!-- Favicon et ressources -->
    <link rel="icon" type="image/png" href="icon.png">
    <link rel="preload" href="icon.png" as="image">
    <link rel="preload" href="Geomanist-Bold.otf" as="font" type="font/otf" crossorigin>
    <link rel="stylesheet" href="styles.css">

    <!-- Librairies JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <!-- Open Graph (aper√ßu lien) -->
    <meta property="og:title" content="CRONOS.WTF | Developed by Unscoop">
    <meta property="og:description" content="Browse smarter. Collect better">
    <meta property="og:image" content="https://CronoBots.github.io/CronoBots/link.png">
    <meta property="og:url" content="https://CronoBots.github.io/CronoBots/">
    <meta property="og:type" content="website">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="CRONOS.WTF | Developed by Unscoop">
    <meta name="twitter:description" content="Browse smarter. Collect better">
    <meta name="twitter:image" content="https://www.cronos.wtf/link.png">
</head>

<body>
    <noscript>
        <div style="text-align: center; padding: 20px; color: var(--text-dark);">
            JavaScript is required to view this content. Please enable JavaScript in your browser settings.
        </div>
    </noscript>
    <nav class="navbar">
        <div class="navbar-logo-search-container">
            <div class="navbar-logo">
                <img src="CRONOBOTS.png" alt="Cronobots Logo">
                <span class="navbar-logo-text">CRONOS.WTF</span>
            </div>
            <div class="navbar-search">
                <input type="text" id="usernameInput" placeholder="üîé Search a profile" aria-describedby="usernameHelp" autocomplete="on" onfocus="this.placeholder=''" onblur="if(!this.value) this.placeholder='üîé Search a profile'" />
                <div class="suggestions" id="suggestions"></div>
            </div>
        </div>
        <div class="navbar-menu" id="navbarMenu">
            <a href="https://cronobots.github.io/Cronos" aria-label="Home">Home</a>
            <span class="navbar-divider"> | </span>
            <a href="#" id="myProfileLink" style="display: none;" aria-label="My Profile">My Profile</a>
            <a href="#" id="logoutLink" style="display: none;" aria-label="Logout">Logout</a>
            <a href="#" id="loginLink" aria-label="Login">Login</a>
            <div class="user-profile" id="userProfile" style="display: none;">
                <img id="userProfilePicture" src="" alt="User Profile" class="user-profile-picture" />
            </div>
        </div>
        <button class="navbar-toggle" aria-label="Toggle menu" aria-expanded="false">‚ò∞</button>
    </nav>
    <div class="main-content">
        <div class="updates-container">
            <div class="update-modal home-update-modal" id="availableFeaturesModal" role="region" aria-labelledby="availableFeaturesTitle">
                <div class="update-modal-content">
                    <div class="update-header">
                        <h3 id="availableFeaturesTitle">‚úÖ Available Features</h3>
                    </div>
                    <div class="update-content" id="availableFeaturesContent">
                        <ul>
                            <li>Profile exploration</li>
                            <li>Login</li>
                            <li>Filtering (Collection / Blockchain / Curated)</li>
                            <li>Display (Small / Medium / Large)</li>
                            <li>Sorting (Newest / Oldest / Rank)</li>
                            <li>Theme switching (Dark / CDC)</li>
                            <li>Full assets download (With NFT name)</li>
                            <li>Single asset download</li>
                            <li>Collage download</li>
                            <li>Scroll navigation buttons (Up / Down)</li>
                            <li>Community support tracking</li>
                            <li>Display name on hover üÜï</li>
	                    <li>Link to NFTs üÜï</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="update-modal home-update-modal" id="inProgressModal" role="region" aria-labelledby="inProgressTitle">
                <div class="update-modal-content">
                    <div class="update-header">
                        <h3 id="inProgressTitle">‚öôÔ∏è In development</h3>
                    </div>
                    <div class="update-content" id="inProgressContent">
                        <ul>
		            <li>Filter by artist</li>
		            <li>Filter by bundle (Manecity)</li>
		            <li>Collection viewer</li>
                            <li>Collection statistics (Floor / Volume / Owners)</li>
                            <li>Partner collections integration</li>
                            <li>Sales bot (Notifications / Automated alerts)</li>
                            <li>Leaderboards (Top holders / Top collections)</li>
                            <li>...</li>
                            <li>Send me your suggestions for improvements or bug reports on X.</li>
			    <ul>
                            	<li><a href="https://x.com/LoadedPixel_CDC" target="_blank">Twitter/X</a></li>
			    </ul>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="profile-section">
            <div class="profile-header" id="profileHeader" style="display: none;">
                <div class="profile-header-content">
                    <div class="profile-picture">
                        <img id="profilePicture" src="" alt="Profile Picture" />
                        <div class="social-container" style="display: none;" id="socialContainer">
                            <p id="croLink" style="display: none;">
                                <a href="#" target="_blank" id="croUrl" title="Visit Crypto.com/NFT Profile">
                                    <img src="CRO.png" alt="CRO Profile" class="social-icon" onerror="console.error('Failed to load CRO.png'); this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                            <p id="twitterLink" style="display: none;">
                                <a href="#" target="_blank" id="twitterUrl" title="Visit X Profile">
                                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/X_icon_2.svg/512px-X_icon_2.svg.png" alt="X Profile" class="social-icon" onerror="this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                            <p id="facebookLink" style="display: none;">
                                <a href="#" target="_blank" id="facebookUrl" title="Visit Facebook Profile">
                                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Facebook_f_logo_%282019%29.svg/512px-Facebook_f_logo_%282019%29.svg.png" alt="Facebook Profile" class="social-icon" onerror="this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                            <p id="instagramLink" style="display: none;">
                                <a href="#" target="_blank" id="instagramUrl" title="Visit Instagram Profile">
                                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/512px-Instagram_icon.png" alt="Instagram Profile" class="social-icon" onerror="this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                        </div>
                    </div>
                    <div class="profile-info">
                        <div class="username-container">
                            <h2 id="username" class="username"></h2>
                            <img id="verifiedBadge" class="verified-badge" src="https://parspng.com/wp-content/uploads/2022/07/tickpng.parspng.com-4-1024x1024.png" style="display: none;" alt="Verified" onerror="this.src='/assets/fallback-verified.png'" />
                        </div>
                        <p id="displayName" class="display-name"></p>
                    </div>
                </div>
            </div>
            <div class="controls" id="controls">
    <div class="control-group">
        <label>ARTISTS:</label>
        <select id="creatorFilter" onchange="filterNFTs()">
            <option value="">ALL ARTISTS</option>
        </select>
    </div>
<div class="control-group">
    <label>COLLECTIONS:</label>
    <select id="collectionFilter" onchange="filterNFTs()">
        <option value="">ALL COLLECTIONS</option>
    </select>
</div>
    <div class="control-group">
        <label>CHAINS:</label>
        <select id="chainFilter" onchange="filterNFTs()">
            <option value="">ALL</option>
            <option value="CRONOS">CRONOS</option>
            <option value="CRONOS_POS">CRONOS POS CHAIN</option>
        </select>
    </div>
    <div class="control-group">
        <label>CURATIONS:</label>
        <select id="curatedFilter" onchange="filterNFTs()">
            <option value="">ALL</option>
            <option value="true">CURATED</option>
            <option value="false">NON CURATED</option>
        </select>
    </div>
    <div class="control-group">
        <label for="cardSize">CARD SIZE:</label>
        <select id="cardSize" onchange="updateDisplay()">
            <option value="small" selected>SMALL</option>
            <option value="medium">MEDIUM</option>
            <option value="large">LARGE</option>
        </select>
    </div>
    <div class="control-group">
        <label>SORT BY:</label>
        <select id="sortBy" onchange="filterNFTs()">
            <option value="newest" selected>NEWEST</option>
            <option value="oldest">OLDEST</option>
            <option value="rank">RANK</option>
        </select>
    </div>
</div>
            <h2 id="collectionTitle" class="collection-title"></h2>
        </div>
        <div class="timestamp" id="timestamp"></div>
        <div class="error" id="error" role="alert"></div>
        <div class="no-results" id="noResults" style="display: none;">No results found</div>
        <div id="nftCountContainer"></div>
        <div class="nft-container" id="nftContainer"></div>
        <div class="download-buttons">
            <button id="downloadZipButton" style="display: none;" onclick="downloadNFTsAsZip()">DOWNLOAD ASSETS</button>
            <button id="downloadCollageButton" style="display: none;" onclick="downloadCollage()">DOWNLOAD COLLAGE</button>
        </div>
        <div class="modal" id="progressModal">
            <div class="modal-content">
                <h3 id="modalTitle">Creating ZIP File</h3>
                <div class="progress-bar">
                    <div class="progress" id="progressBar"></div>
                </div>
                <p class="progress-text" id="progressText">Preparing</p>
                <div class="modal-buttons">
                    <button id="cancelDownloadButton" class="cancel-button">Cancel</button>
                </div>
            </div>
        </div>
        <div class="modal" id="loginModal">
            <div class="modal-content">
                <h3>Enter your Crypto.com/NFT Profile</h3>
                <div class="navbar-search" id="loginSearchContainer">
                    <input type="text" id="loginUsernameInput" placeholder="üîé Search a profile" autocomplete="on" onfocus="this.placeholder=''" onblur="if(!this.value) this.placeholder='üîé Search a profile'" />
                    <div class="suggestions" id="loginSuggestions"></div>
                </div>
                <div class="modal-buttons">
                    <button id="cancelLoginButton" class="cancel-button">Cancel</button>
                </div>
            </div>
        </div>
    </div>
    <footer class="footer">
        <div class="footer-left">
            <div class="footer-logo-container">
                <img src="CRONOBOTS.png" alt="Cronobots Logo" class="footer-logo">
                <p class="footer-text">DEVELOPED BY <a href="https://x.com/LoadedPixel_CDC" target="_blank" rel="noopener noreferrer" class="footer-link">UNSCOOP</a></p>
            </div>
        </div>
        <div class="footer-center">
            <div class="donation-section">
                <h4>Together, we make this possible</h4>
                <span class="wallet-address">0x9829e44fd04f3788F27096875Df0D2772173Ab3d</span>
                <div class="donation-progress">
                    <span class="progress-label">Community Supports: <span id="progressPercent">1143</span> CRO</span>
                    <div class="progress-bar">
                        <div class="progress" id="donationProgressBar" style="width: 8%;"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="footer-right">
            <div class="theme-toggle">
                <label>Theme:</label>
                <button id="themeButton">CDC</button>
            </div>
        </div>
    </footer>
    <button id="scrollToTopButton" aria-label="Scroll to top">‚Üë</button>
    <button id="scrollToBottomButton" aria-label="Scroll to bottom">‚Üì</button>
    <script>
        const cache = new Map();
let allNFTs = [];
let currentUsername = '';
let currentDisplayName = '';
let lastSearchedUsername = '';
let debounceTimeout = null;
let isDownloadCancelled = false;
let isProfileLoadingCancelled = false;
let loggedInUser = null;
let activeSearch = null;
let hasSelectedSpecificCollection = false;

const profileQuery = `
    query User($id: ID!, $cacheId: ID) {
        public(cacheId: $cacheId) {
            user(id: $id) {
                username
                displayName
                verified
                avatar {
                    url
                }
                twitterUsername
                facebookUsername
                instagramUsername
            }
        }
    }
`;

const nftQuery = `
    query GetProfileAssets($ownerId: ID!, $first: Int!, $skip: Int!) {
        public {
            profileAssets(ownerId: $ownerId, first: $first, skip: $skip) {
                id
                name
                cover {
                    url
                }
                collection {
                    id
                    name
                    creator {
                        id
                        displayName
                    }
                }
                isExternalNft
                externalNftMetadata {
                    network
                }
                defaultListingV2 {
                    salePriceDecimalUSD
                }
                latestPurchasedEdition {
                    priceUSD
                }
                createdAt
                defaultRarityRank
                isCurated
            }
        }
    }
`;

const graphqlEndpoint = "https://crypto.com/nft-api/graphql";
const homeUrl = "https://cronobots.github.io/Cronos";

function parseUrlHash() {
    const hash = window.location.hash.substring(1);
    if (!hash) return { username: null, collection: null };
    const parts = hash.split('/#').map(decodeURIComponent);
    return {
        username: parts[0] || null,
        collection: parts[1] || null
    };
}

function resetSearchBar() {
    const searchInput = document.getElementById('usernameInput');
    if (searchInput) {
        searchInput.value = ''; // Vider le contenu
        searchInput.blur(); // Retirer le focus
        searchInput.placeholder = 'üîé Search a profile'; // Restaurer le placeholder
    }
}

function resetViewport() {
    window.scrollTo(0, 0);
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function toggleMenu(event) {
    console.log('toggleMenu called', { eventType: event?.type || 'unknown' });
    const menu = document.getElementById('navbarMenu');
    const toggle = document.querySelector('.navbar-toggle');
    if (menu && toggle) {
        const isExpanded = menu.classList.toggle('active');
        toggle.setAttribute('aria-expanded', isExpanded);
        console.log('Menu toggled:', isExpanded ? 'visible' : 'hidden', { menuDisplay: getComputedStyle(menu).display });
    } else {
        console.error('Navbar menu or toggle not found', { menu: !!menu, toggle: !!toggle });
    }
}

function sanitizeInput(input) {
    return input.replace(/[<>]/g, '').trim().toLowerCase();
}

function sanitizeFileNameForZip(name, index = 0) {
    if (!name || name.trim() === '') {
        return `unnamed_nft_${index}`;
    }
    // Supprimer les caract√®res non valides pour les noms de fichiers
    let sanitized = name.replace(/[\/\\:*?"<>|]/g, '').trim();
    // Limiter la longueur √† 100 caract√®res
    sanitized = sanitized.substring(0, 100);
    return sanitized || `unnamed_nft_${index}`;
}

function toggleTheme() {
    const themeButton = document.getElementById('themeButton');
    if (!themeButton) {
        console.error('Theme button not found');
        return;
    }
    const currentTheme = document.documentElement.getAttribute('data-theme');
    const newTheme = currentTheme === 'dark' ? 'cdc' : 'dark'; // Remplacer 'light' par 'cdc'
    document.documentElement.setAttribute('data-theme', newTheme);
    localStorage.setItem('theme', newTheme);
    themeButton.textContent = newTheme === 'dark' ? 'CDC' : 'Dark'; // Mettre √† jour le texte du bouton
    console.log('Theme set to:', newTheme);
}

function normalizeText(text) {
    if (!text) return '';
    let normalized = text.normalize('NFKD').replace(/[\u0300-\u036f]/g, '');
    normalized = normalized.replace(/\n\s*\n/g, '\n').trim();
    return normalized;
}

function updateLoginLink() {
    const userProfile = document.getElementById('userProfile');
    const userProfilePicture = document.getElementById('userProfilePicture');
    const myProfileLink = document.getElementById('myProfileLink');
    const logoutLink = document.getElementById('logoutLink');
    const loginLink = document.getElementById('loginLink');

    if (!userProfile || !userProfilePicture || !myProfileLink || !logoutLink || !loginLink) return;

    if (loggedInUser) {
        userProfilePicture.src = loggedInUser.avatar || '/assets/fallback-icon.png';
        myProfileLink.textContent = 'My Profile';
        myProfileLink.href = `#${loggedInUser.username.toLowerCase()}`;
        userProfile.style.display = 'flex';
        myProfileLink.style.display = 'inline-block';
        logoutLink.style.display = 'inline-block';
        loginLink.style.display = 'none';
    } else {
        userProfile.style.display = 'none';
        myProfileLink.style.display = 'none';
        logoutLink.style.display = 'none';
        loginLink.style.display = 'inline-block';
    }
}

function showLoginModal(event) {
    event.preventDefault();
    const loginModal = document.getElementById('loginModal');
    const loginUsernameInput = document.getElementById('loginUsernameInput');
    const loginSearchContainer = document.getElementById('loginSearchContainer');
    if (loginModal && loginUsernameInput && loginSearchContainer) {
        loginModal.style.display = 'flex';
        loginUsernameInput.value = '';
        loginUsernameInput.focus();
        loginSearchContainer.style.display = 'flex';
        clearLoginSuggestions();
        const navbarMenu = document.getElementById('navbarMenu');
        if (navbarMenu) {
            navbarMenu.classList.remove('active');
            const toggle = document.querySelector('.navbar-toggle');
            if (toggle) toggle.setAttribute('aria-expanded', 'false');
        }
    }
}


function clearLoginSuggestions() {
    const suggestions = document.getElementById('loginSuggestions');
    if (suggestions) {
        suggestions.innerHTML = '';
        suggestions.style.display = 'none';
    }
}

function resetLoginForm() {
    const loginModal = document.getElementById('loginModal');
    const loginUsernameInput = document.getElementById('loginUsernameInput');
    const loginSearchContainer = document.getElementById('loginSearchContainer');
    if (loginModal && loginUsernameInput && loginSearchContainer) {
        loginModal.style.display = 'none';
        loginUsernameInput.value = '';
        loginSearchContainer.style.display = 'flex';
        clearLoginSuggestions();
    }
}

function logout(event) {
    event.preventDefault();
    const username = loggedInUser?.username;
    loggedInUser = null;
    localStorage.removeItem('loggedInUser');
    updateLoginLink();
    const profileHeader = document.getElementById('profileHeader');
    const nftContainer = document.getElementById('nftContainer');
    const nftCountContainer = document.getElementById('nftCountContainer');
    const noResultsDiv = document.getElementById('noResults');
    const controls = document.getElementById('controls');
    const collectionTitle = document.getElementById('collectionTitle');
    const collectionFilter = document.getElementById('collectionFilter');
    const chainFilter = document.getElementById('chainFilter');
    const curatedFilter = document.getElementById('curatedFilter');
    const usernameInput = document.getElementById('usernameInput');
    const downloadZipButton = document.getElementById('downloadZipButton');
    const downloadCollageButton = document.getElementById('downloadCollageButton');

    if (profileHeader) profileHeader.style.display = 'none';
    if (nftContainer) nftContainer.innerHTML = '';
    if (nftCountContainer) nftCountContainer.innerHTML = '';
    if (noResultsDiv) noResultsDiv.style.display = 'none';
    if (controls) controls.classList.remove('visible');
    if (collectionTitle) {
        collectionTitle.textContent = '';
        collectionTitle.classList.remove('visible');
    }
    if (collectionFilter) {
        collectionFilter.innerHTML = '<option value="">All Collections</option>';
        collectionFilter.disabled = true;
    }
    if (chainFilter) chainFilter.value = '';
    if (curatedFilter) curatedFilter.value = '';
    if (usernameInput) usernameInput.value = '';
    if (downloadZipButton) downloadZipButton.style.display = 'none';
    if (downloadCollageButton) downloadCollageButton.style.display = 'none';

    allNFTs = [];
    currentUsername = '';
    history.pushState({}, '', window.location.pathname);
    window.location.href = homeUrl;
}

async function fetchWithCache(key, fetchFn, retries = 3, delay = 1000) {
    if (key.startsWith('image_')) {
        // Ignorer le cache pour les URLs d'images
        return await fetchFn();
    }
    if (cache.has(key)) {
        console.log(`Cache hit for ${key}`);
        return cache.get(key);
    }
    for (let i = 0; i < retries; i++) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000);
            const data = await fetchFn(controller.signal);
            clearTimeout(timeoutId);
            if (data) {
                cache.set(key, data);
            } else {
                console.log(`Not caching null response for ${key}`);
            }
            return data;
        } catch (error) {
            if (i < retries - 1 && error.message.includes('429')) {
                console.log(`Rate limit hit for ${key}, retrying in ${delay}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                delay *= 2;
            } else {
                console.error(`Fetch error for ${key}:`, error.message);
                throw error;
            }
        }
    }
}

async function fetchAllNFTs(ownerId, progressCallback) {
    const first = 60;
    let skip = 0;
    let allAssets = [];
    let hasMore = true;

    while (hasMore && !isProfileLoadingCancelled) {
        const nftVariables = { ownerId, first, skip };
        try {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query: nftQuery, variables: nftVariables })
            });

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            const assets = result.data?.public?.profileAssets || [];
            assets.forEach((asset, index) => {
                console.log(`Asset ${skip + index + 1}:`, {
                    id: asset.id,
                    name: asset.name || 'No name',
                    collectionName: asset.collection?.name || 'No collection name',
                    collectionId: asset.collection?.id || 'No collection ID',
                    creatorId: asset.collection?.creator?.id || 'No creator ID',
                    creatorDisplayName: asset.collection?.creator?.displayName || 'No creator displayName',
                    isCurated: asset.isCurated,
                    isExternalNft: asset.isExternalNft,
                    network: asset.externalNftMetadata?.network || 'No network'
                });
            });
            allAssets = [...allAssets, ...assets];
            skip += first;
            hasMore = assets.length === first;

            if (progressCallback) {
                progressCallback(allAssets.length);
            }
        } catch (error) {
            console.error(`Failed to fetch NFTs: ${error.message}`);
            throw error;
        }
    }

    console.log('All NFTs fetched:', {
        total: allAssets.length,
        hasCollections: allAssets.some(asset => asset.collection?.name),
        hasCreators: allAssets.some(asset => asset.collection?.creator?.id),
        collectionNames: allAssets
            .filter(asset => asset.collection?.name)
            .map(asset => asset.collection.name)
            .filter((name, index, self) => self.indexOf(name) === index)
    });

    return allAssets;
}

async function searchProfiles(query) {
    const suggestions = document.getElementById('suggestions');
    if (!suggestions) {
        console.error('Suggestions container not found');
        return;
    }

    if (!query || query.length < 3) {
        suggestions.innerHTML = '';
        suggestions.style.display = 'none';
        console.log('Query too short, clearing suggestions');
        return;
    }

    suggestions.innerHTML = '<div class="suggestion-item">Searching...</div>';
    suggestions.style.display = 'block';

    if (activeSearch) {
        activeSearch.cancel = true;
    }

    const searchToken = { cancel: false };
    activeSearch = searchToken;

    try {
        const profileData = await fetchWithCache(`profile_${query}`, async (signal) => {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: profileQuery,
                    variables: { id: query, cacheId: `getUserQuery-Profile-${query}` }
                }),
                signal
            });

            if (searchToken.cancel) {
                throw new Error('Search cancelled');
            }

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            return result.data?.public?.user;
        });

        if (searchToken.cancel) {
            console.log('Search cancelled, ignoring result');
            return;
        }

        suggestions.innerHTML = '';
        if (profileData && profileData.username) {
            const item = document.createElement('div');
            item.className = 'suggestion-item';
            
            if (profileData.avatar?.url) {
                const img = document.createElement('img');
                img.src = profileData.avatar.url;
                img.alt = `${profileData.username} avatar`;
                img.onerror = () => {
                    console.error(`Failed to load avatar for ${profileData.username}`);
                    img.style.display = 'none';
                };
                item.appendChild(img);
            }

            const text = document.createElement('span');
            text.textContent = profileData.username;
            item.appendChild(text);

            item.dataset.username = profileData.username;
            item.addEventListener('click', () => {
                selectSuggestion(profileData.username);
            });
            suggestions.appendChild(item);
            suggestions.style.display = 'block';
        } else {
            suggestions.innerHTML = '<div class="suggestion-item">No profile found</div>';
            suggestions.style.display = 'block';
        }
    } catch (error) {
        if (error.message !== 'Search cancelled') {
            console.error(`Error in searchProfiles: ${error.message}`);
            suggestions.innerHTML = `<div class="suggestion-item">${
                error.message.includes('user[id=') && error.message.includes('not found')
                    ? 'No profile found'
                    : `Error: ${error.message}`
            }</div>`;
            suggestions.style.display = 'block';
        }
    } finally {
        if (activeSearch === searchToken) {
            activeSearch = null;
        }
    }
}

function clearSuggestions() {
    const suggestions = document.getElementById('suggestions');
    if (suggestions) {
        suggestions.innerHTML = '';
        suggestions.style.display = 'none';
    }
}

function selectSuggestion(username) {
    const usernameInput = document.getElementById('usernameInput');
    if (usernameInput) {
        usernameInput.value = username;
        clearSuggestions();
        fetchProfileAndNFTs();
        resetSearchBar(); // R√©initialiser la barre apr√®s validation
    }
}

async function searchLoginProfiles(query) {
    const suggestions = document.getElementById('loginSuggestions');
    if (!suggestions) {
        console.error('Login suggestions container not found');
        return;
    }

    if (!query || query.length < 3) {
        suggestions.innerHTML = '';
        suggestions.style.display = 'none';
        return;
    }

    suggestions.innerHTML = '<div class="suggestion-item">Searching...</div>';
    suggestions.style.display = 'block';

    if (activeSearch) {
        activeSearch.cancel = true;
    }

    const searchToken = { cancel: false };
    activeSearch = searchToken;

    try {
        const profileData = await fetchWithCache(`profile_${query}`, async (signal) => {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: profileQuery,
                    variables: { id: query, cacheId: `getUserQuery-Profile-${query}` }
                }),
                signal
            });

            if (searchToken.cancel) {
                throw new Error('Search cancelled');
            }

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            return result.data?.public?.user;
        });

        if (searchToken.cancel) {
            console.log('Search cancelled, ignoring result');
            return;
        }

        suggestions.innerHTML = '';
        if (profileData && profileData.username) {
            const item = document.createElement('div');
            item.className = 'suggestion-item';
            
            if (profileData.avatar?.url) {
                const img = document.createElement('img');
                img.src = profileData.avatar.url;
                img.alt = `${profileData.username} avatar`;
                img.onerror = () => {
                    console.error(`Failed to load avatar for ${profileData.username}`);
                    img.style.display = 'none';
                };
                item.appendChild(img);
            }

            const text = document.createElement('span');
            text.textContent = profileData.username;
            item.appendChild(text);

            item.dataset.username = profileData.username;
            item.dataset.avatar = profileData.avatar?.url || '';
            item.addEventListener('click', () => {
                selectLoginSuggestion(profileData.username, profileData.avatar?.url);
            });
            suggestions.appendChild(item);
            suggestions.style.display = 'block';
        } else {
            suggestions.innerHTML = '<div class="suggestion-item">No profile found</div>';
            suggestions.style.display = 'block';
        }
    } catch (error) {
        if (error.message !== 'Search cancelled') {
            console.error(`Error in searchLoginProfiles: ${error.message}`);
            suggestions.innerHTML = `<div class="suggestion-item">${
                error.message.includes('user[id=') && error.message.includes('not found')
                    ? 'No profile found'
                    : `Error: ${error.message}`
            }</div>`;
            suggestions.style.display = 'block';
        }
    } finally {
        if (activeSearch === searchToken) {
            activeSearch = null;
        }
    }
}

async function selectLoginSuggestion(username, avatarUrl) {
    const loginUsernameInput = document.getElementById('loginUsernameInput');
    const loginModal = document.getElementById('loginModal');
    const errorDiv = document.getElementById('error');

    if (!loginUsernameInput || !loginModal || !errorDiv) {
        console.error('Required DOM elements not found');
        return;
    }

    try {
        // R√©cup√©rer les donn√©es du profil via l'API
        const profileData = await fetchWithCache(`profile_${username}`, async (signal) => {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: profileQuery,
                    variables: { id: username, cacheId: `getUserQuery-Profile-${username}` }
                }),
                signal
            });

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            return result.data?.public?.user;
        });

        if (profileData && profileData.username) {
            // Stocker les informations de l'utilisateur connect√©
            loggedInUser = {
                username: profileData.username,
                displayName: profileData.displayName || profileData.username,
                avatar: profileData.avatar?.url || '',
                twitterUsername: profileData.twitterUsername || '',
                facebookUsername: profileData.facebookUsername || '',
                instagramUsername: profileData.instagramUsername || '',
                verified: profileData.verified || false
            };
            localStorage.setItem('loggedInUser', JSON.stringify(loggedInUser));

            // Mettre √† jour l'interface de connexion (navbar)
            updateLoginLink();

            // Fermer le modal
            loginModal.style.display = 'none';
            errorDiv.textContent = '';
            loginUsernameInput.value = '';

            // Charger et afficher le profil complet
            updateProfileUI(profileData);
            fetchProfileAndNFTsForLogin(profileData.username);
        } else {
            errorDiv.textContent = 'No profile found';
        }
    } catch (error) {
        console.error(`Error in selectLoginSuggestion: ${error.message}`);
        errorDiv.textContent = error.message.includes('user[id=') && error.message.includes('not found')
            ? 'No profile found'
            : `Error: ${error.message}`;
    }
}

function updateProfileUI(profileData) {
    const profileHeader = document.getElementById('profileHeader');
    const profilePicture = document.getElementById('profilePicture');
    const username = document.getElementById('username');
    const verifiedBadge = document.getElementById('verifiedBadge');
    const displayName = document.getElementById('displayName');
    const socialContainer = document.getElementById('socialContainer');
    const croLink = document.getElementById('croLink');
    const croUrl = document.getElementById('croUrl');
    const twitterLink = document.getElementById('twitterLink');
    const twitterUrl = document.getElementById('twitterUrl');
    const facebookLink = document.getElementById('facebookLink');
    const facebookUrl = document.getElementById('facebookUrl');
    const instagramLink = document.getElementById('instagramLink');
    const instagramUrl = document.getElementById('instagramUrl');
    const usernameInput = document.getElementById('usernameInput');

    if (!profileHeader || !profilePicture || !username || !verifiedBadge || !displayName || !socialContainer ||
        !croLink || !croUrl || !twitterLink || !twitterUrl || !facebookLink || !facebookUrl || !instagramLink || !instagramUrl || !usernameInput) {
        console.error('Profile UI elements not found');
        return;
    }

    if (!profileData || !profileData.username) {
        console.error('Invalid profile data');
        return;
    }

    username.textContent = profileData.username || 'Unknown';
    currentUsername = profileData.username || '';
    displayName.textContent = profileData.displayName || '';
    displayName.style.display = profileData.displayName ? 'block' : 'none';
    currentDisplayName = profileData.displayName || profileData.username || 'Unknown';

    verifiedBadge.style.display = profileData.verified === true ? 'inline-block' : 'none';
    profilePicture.src = profileData.avatar?.url || '';
    profilePicture.style.display = profileData.avatar?.url ? 'block' : 'none';

    let hasSocialLinks = false;

    if (currentUsername) {
        croUrl.href = `https://crypto.com/nft/profile/${sanitizeInput(currentUsername)}`;
        croLink.style.display = 'inline-block';
        hasSocialLinks = true;
    } else {
        croLink.style.display = 'none';
    }

    if (profileData.twitterUsername) {
        twitterUrl.href = `https://x.com/${sanitizeInput(profileData.twitterUsername)}`;
        twitterLink.style.display = 'inline-block';
        hasSocialLinks = true;
    } else {
        twitterLink.style.display = 'none';
    }

    if (profileData.facebookUsername) {
        facebookUrl.href = `https://facebook.com/${sanitizeInput(profileData.facebookUsername)}`;
        facebookLink.style.display = 'inline-block';
        hasSocialLinks = true;
    } else {
        facebookLink.style.display = 'none';
    }

    if (profileData.instagramUsername) {
        instagramUrl.href = `https://instagram.com/${sanitizeInput(profileData.instagramUsername)}`;
        instagramLink.style.display = 'inline-block';
        hasSocialLinks = true;
    } else {
        instagramLink.style.display = 'none';
    }

    socialContainer.style.display = hasSocialLinks ? 'flex' : 'none';
    profileHeader.style.display = 'block';
    usernameInput.value = '';
}

function populateCreatorFilter(nfts) {
    const creatorFilter = document.getElementById('creatorFilter');
    if (!creatorFilter) {
        console.error('Creator filter element not found');
        return;
    }

    // Cr√©er un objet pour stocker les comptes de NFTs par cr√©ateur
    const creatorCounts = {};
    nfts.forEach(nft => {
        const creatorId = nft.collection?.creator?.id;
        const creatorDisplayName = nft.collection?.creator?.displayName || creatorId || 'Unknown';
        if (creatorId) {
            if (!creatorCounts[creatorId]) {
                creatorCounts[creatorId] = {
                    displayName: creatorDisplayName,
                    count: 0
                };
            }
            creatorCounts[creatorId].count += 1;
        }
    });

    // Trier les cr√©ateurs par nombre de NFTs (d√©croissant), puis par displayName
    const sortedCreators = Object.keys(creatorCounts).sort((a, b) => {
        const countDiff = creatorCounts[b].count - creatorCounts[a].count;
        if (countDiff !== 0) return countDiff;
        return creatorCounts[a].displayName.localeCompare(creatorCounts[b].displayName);
    });

    // V√©rifier les displayNames dupliqu√©s
    const displayNameCounts = {};
    sortedCreators.forEach(creatorId => {
        const displayName = creatorCounts[creatorId].displayName;
        displayNameCounts[displayName] = (displayNameCounts[displayName] || 0) + 1;
    });

    // D√©terminer si l'appareil est mobile
    const isMobile = window.innerWidth <= 768;

    // Peupler le menu d√©roulant
    creatorFilter.innerHTML = '<option value="">ALL ARTISTS</option>';
    sortedCreators.forEach(creatorId => {
        const option = document.createElement('option');
        option.value = creatorId;
        const displayName = creatorCounts[creatorId].displayName;
        const count = creatorCounts[creatorId].count;
        // Appliquer majuscules pour mobile, sinon garder le texte original
        const displayText = isMobile ? displayName.toUpperCase() : displayName;
        option.textContent = displayNameCounts[displayName] > 1
            ? `${displayText} (${creatorId}) (${count})`
            : `${displayText} (${count})`;
        creatorFilter.appendChild(option);
    });

    console.log('Creator filter populated with:', sortedCreators.map(id => ({
        id,
        displayName: creatorCounts[id].displayName,
        count: creatorCounts[id].count
    })));
}

function populateCollectionFilter(nfts) {
    const collectionFilter = document.getElementById('collectionFilter');
    const creatorFilter = document.getElementById('creatorFilter');
    if (!collectionFilter || !creatorFilter) {
        console.error('Collection or creator filter element not found');
        return;
    }

    const selectedCreator = creatorFilter.value;
    const collectionCounts = {};

    nfts.forEach((nft, index) => {
        const collectionName = nft.collection?.name || 'Unknown Collection';
        const creatorId = nft.collection?.creator?.id;
        if (!creatorId) {
            console.warn(`NFT ${index} missing creator data:`, {
                collectionName,
                nftId: nft.id,
                nftName: nft.name
            });
        }
        if (!selectedCreator || creatorId === selectedCreator) {
            collectionCounts[collectionName] = (collectionCounts[collectionName] || 0) + 1;
        }
    });

    const sortedCollections = Object.keys(collectionCounts).sort((a, b) => {
        const countDiff = collectionCounts[b] - collectionCounts[a];
        return countDiff !== 0 ? countDiff : a.localeCompare(b);
    });

    const currentValue = collectionFilter.value;
    // D√©terminer si l'appareil est mobile
    const isMobile = window.innerWidth <= 768;
    collectionFilter.innerHTML = '<option value="">ALL COLLECTIONS</option>';
    sortedCollections.forEach(collection => {
        const option = document.createElement('option');
        option.value = collection;
        // Appliquer majuscules pour mobile, sinon garder le texte original
        const displayText = isMobile ? collection.toUpperCase() : collection;
        option.textContent = `${displayText} (${collectionCounts[collection]})`;
        collectionFilter.appendChild(option);
    });

    // Restaurer la valeur actuelle si elle existe toujours
    if (currentValue && sortedCollections.includes(currentValue)) {
        collectionFilter.value = currentValue;
    } else {
        collectionFilter.value = '';
    }

    // Activer le filtre si des NFTs existent
    collectionFilter.disabled = nfts.length === 0;
    console.log('Collection filter populated:', {
        selectedCreator,
        totalNFTs: nfts.length,
        collections: sortedCollections,
        collectionCounts,
        selectedValue: collectionFilter.value,
        disabled: collectionFilter.disabled
    });
}

async function fetchProfileAndNFTs() {
    const usernameInput = document.getElementById('usernameInput');
    const errorDiv = document.getElementById('error');
    const noResultsDiv = document.getElementById('noResults');
    const controls = document.getElementById('controls');
    const collectionTitle = document.getElementById('collectionTitle');
    const profileHeader = document.getElementById('profileHeader');
    const nftContainer = document.getElementById('nftContainer');
    const nftCountContainer = document.getElementById('nftCountContainer');
    const collectionFilter = document.getElementById('collectionFilter');
    const creatorFilter = document.getElementById('creatorFilter');
    const chainFilter = document.getElementById('chainFilter');
    const curatedFilter = document.getElementById('curatedFilter');
    const cardSize = document.getElementById('cardSize');
    const sortBy = document.getElementById('sortBy');
    const downloadZipButton = document.getElementById('downloadZipButton');
    const downloadCollageButton = document.getElementById('downloadCollageButton');
    const progressModal = document.getElementById('progressModal');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const modalTitle = document.getElementById('modalTitle');
    const cancelButton = document.getElementById('cancelDownloadButton');
    const availableFeaturesModal = document.getElementById('availableFeaturesModal');
    const inProgressModal = document.getElementById('inProgressModal');

    if (!usernameInput || !errorDiv || !noResultsDiv || !controls || !collectionTitle ||
        !profileHeader || !nftContainer || !nftCountContainer || !collectionFilter ||
        !creatorFilter || !chainFilter || !curatedFilter || !cardSize || !sortBy ||
        !downloadZipButton || !downloadCollageButton || !progressModal ||
        !progressBar || !progressText || !modalTitle || !cancelButton) {
        console.error('Required DOM elements not found');
        if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
        return;
    }

    const username = sanitizeInput(usernameInput.value.trim());
    if (!username || username.toLowerCase() === currentUsername.toLowerCase()) {
        console.log('fetchProfileAndNFTs skipped:', { username, currentUsername });
        return;
    }

    console.log('Starting fetchProfileAndNFTs for:', username);

    currentUsername = '';
    allNFTs = [];
    cardSize.value = 'small';
    sortBy.value = 'newest';
    collectionFilter.innerHTML = '<option value="">All Collections</option>';
    collectionFilter.value = '';
    creatorFilter.innerHTML = '<option value="">ALL CREATORS</option>';
    creatorFilter.value = '';
    chainFilter.value = '';
    curatedFilter.value = '';
    chainFilter.disabled = false;
    curatedFilter.disabled = false;
    creatorFilter.disabled = false; // Ne pas d√©sactiver initialement
    collectionFilter.disabled = false; // Ne pas d√©sactiver initialement

    currentUsername = username;
    lastSearchedUsername = currentUsername;
    clearSuggestions();

    if (availableFeaturesModal) availableFeaturesModal.style.display = 'none';
    if (inProgressModal) inProgressModal.style.display = 'none';

    profileHeader.style.display = 'none';
    nftContainer.innerHTML = '';
    nftCountContainer.innerHTML = '';
    noResultsDiv.style.display = 'none';
    controls.classList.remove('visible');
    collectionTitle.textContent = '';
    collectionTitle.classList.remove('visible');
    errorDiv.textContent = '';
    downloadZipButton.style.display = 'none';
    downloadCollageButton.style.display = 'none';
    resetSearchBar();

    modalTitle.textContent = 'Loading Profile';
    progressText.textContent = `Loading profile for ${username}...`;
    progressBar.style.width = '0%';
    progressModal.style.display = 'flex';
    cancelButton.style.display = 'block';

    isProfileLoadingCancelled = false;
    cancelButton.onclick = () => {
        isProfileLoadingCancelled = true;
        progressText.textContent = 'Profile loading cancelled.';
        progressBar.style.width = '0%';
        setTimeout(() => {
            progressModal.style.display = 'none';
            window.location.href = homeUrl;
        }, 1000);
    };

    let progress = 0;
    const progressInterval = setInterval(() => {
        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }
        progress += 10;
        progressBar.style.width = `${Math.min(progress, 80)}%`;
    }, 500);

    try {
        const profileData = await fetchWithCache(`profile_${currentUsername}`, async (signal) => {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: profileQuery,
                    variables: { id: currentUsername, cacheId: `getUserQuery-Profile-${currentUsername}` }
                }),
                signal
            });

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            return result.data?.public?.user;
        });

        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }

        if (!profileData) {
            clearInterval(progressInterval);
            progressModal.style.display = 'none';
            noResultsDiv.style.display = 'block';
            errorDiv.textContent = 'No profile found';
            resetViewport();
            return;
        }

        updateProfileUI(profileData);

        progressText.textContent = `0 assets`;
        allNFTs = await fetchWithCache(`nfts_${currentUsername}`, () => fetchAllNFTs(currentUsername, (nftCount) => {
            if (isProfileLoadingCancelled) return;
            progressText.textContent = `${nftCount} assets`;
        }));

        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }

        clearInterval(progressInterval);
        progressBar.style.width = '100%';
        progressText.textContent = `${allNFTs.length} assets loaded successfully!`;
        setTimeout(() => {
            progressModal.style.display = 'none';
            resetViewport();
        }, 500);

        if (allNFTs.length > 0) {
            populateCreatorFilter(allNFTs);
            populateCollectionFilter(allNFTs);
            const hasCollections = allNFTs.some(nft => nft.collection?.name || nft.collection);
            const hasCreators = allNFTs.some(nft => nft.collection?.creator?.id);
            collectionFilter.disabled = !hasCollections; // D√©sactiver uniquement si aucune collection
            creatorFilter.disabled = !hasCreators; // D√©sactiver uniquement si aucun cr√©ateur
            controls.classList.add('visible');
            console.log('Filter state after population:', {
                collectionDisabled: collectionFilter.disabled,
                creatorDisabled: creatorFilter.disabled,
                hasCollections,
                collectionOptions: Array.from(collectionFilter.options).map(opt => opt.value)
            });

            const { collection } = parseUrlHash();
            if (collection) {
                const optionExists = Array.from(collectionFilter.options).some(opt => opt.value === collection);
                collectionFilter.value = optionExists ? collection : '';
                console.log('URL collection applied:', { collection, optionExists, selectedValue: collectionFilter.value });
            }

            filterNFTs();
        } else {
            noResultsDiv.style.display = 'block';
            collectionFilter.disabled = true;
            creatorFilter.disabled = true;
            resetViewport();
        }
    } catch (error) {
        if (!isProfileLoadingCancelled) {
            console.error(`Error in fetchProfileAndNFTs: ${error.message}`);
            clearInterval(progressInterval);
            progressModal.style.display = 'none';
            errorDiv.textContent = error.message.includes('user[id=') && error.message.includes('not found')
                ? 'No profile found'
                : `Error: ${error.message}`;
            resetViewport();
        }
    }
}

async function fetchProfileAndNFTsForLogin(username) {
    console.log('fetchProfileAndNFTsForLogin called for username:', username);
    const errorDiv = document.getElementById('error');
    const noResultsDiv = document.getElementById('noResults');
    const controls = document.getElementById('controls');
    const collectionTitle = document.getElementById('collectionTitle');
    const profileHeader = document.getElementById('profileHeader');
    const nftContainer = document.getElementById('nftContainer');
    const nftCountContainer = document.getElementById('nftCountContainer');
    const collectionFilter = document.getElementById('collectionFilter');
    const creatorFilter = document.getElementById('creatorFilter');
    const chainFilter = document.getElementById('chainFilter');
    const curatedFilter = document.getElementById('curatedFilter');
    const cardSize = document.getElementById('cardSize');
    const sortBy = document.getElementById('sortBy');
    const downloadZipButton = document.getElementById('downloadZipButton');
    const downloadCollageButton = document.getElementById('downloadCollageButton');
    const progressModal = document.getElementById('progressModal');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const modalTitle = document.getElementById('modalTitle');
    const cancelButton = document.getElementById('cancelDownloadButton');
    const availableFeaturesModal = document.getElementById('availableFeaturesModal');
    const inProgressModal = document.getElementById('inProgressModal');

    if (!errorDiv || !noResultsDiv || !controls || !collectionTitle ||
        !profileHeader || !nftContainer || !nftCountContainer || !collectionFilter ||
        !creatorFilter || !chainFilter || !curatedFilter || !cardSize || !sortBy ||
        !downloadZipButton || !downloadCollageButton || !progressModal ||
        !progressBar || !progressText || !modalTitle || !cancelButton) {
        console.error('Required DOM elements not found');
        if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
        return;
    }

    const sanitizedUsername = sanitizeInput(username.trim());
    if (!sanitizedUsername) {
        console.log('No username provided');
        errorDiv.textContent = 'No username provided';
        return;
    }

    console.log('Starting fetchProfileAndNFTsForLogin for:', sanitizedUsername);

    currentUsername = '';
    allNFTs = [];
    cardSize.value = 'small';
    sortBy.value = 'newest';
    collectionFilter.innerHTML = '<option value="">All Collections</option>';
    collectionFilter.value = '';
    creatorFilter.innerHTML = '<option value="">ALL CREATORS</option>';
    creatorFilter.value = '';
    chainFilter.value = '';
    curatedFilter.value = '';
    chainFilter.disabled = false;
    curatedFilter.disabled = false;
    creatorFilter.disabled = true;
    collectionFilter.disabled = true;

    currentUsername = sanitizedUsername;
    lastSearchedUsername = currentUsername;
    clearSuggestions();

    if (availableFeaturesModal) availableFeaturesModal.style.display = 'none';
    if (inProgressModal) inProgressModal.style.display = 'none';

    profileHeader.style.display = 'none';
    nftContainer.innerHTML = '';
    nftCountContainer.innerHTML = '';
    noResultsDiv.style.display = 'none';
    controls.classList.remove('visible');
    collectionTitle.textContent = '';
    collectionTitle.classList.remove('visible');
    errorDiv.textContent = '';
    downloadZipButton.style.display = 'none';
    downloadCollageButton.style.display = 'none';

    modalTitle.textContent = 'Loading Profile';
    progressText.textContent = `Loading profile for ${sanitizedUsername}...`;
    progressBar.style.width = '0%';
    progressModal.style.display = 'flex';
    cancelButton.style.display = 'block';

    isProfileLoadingCancelled = false;
    cancelButton.onclick = () => {
        isProfileLoadingCancelled = true;
        progressText.textContent = 'Profile loading cancelled.';
        progressBar.style.width = '0%';
        setTimeout(() => {
            progressModal.style.display = 'none';
            window.location.href = homeUrl;
        }, 1000);
    };

    let progress = 0;
    const progressInterval = setInterval(() => {
        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }
        progress += 10;
        progressBar.style.width = `${Math.min(progress, 80)}%`;
    }, 500);

    try {
        const profileData = await fetchWithCache(`profile_${currentUsername}`, async (signal) => {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: profileQuery,
                    variables: { id: currentUsername, cacheId: `getUserQuery-Profile-${currentUsername}` }
                }),
                signal
            });

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            return result.data?.public?.user;
        });

        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }

        if (!profileData) {
            clearInterval(progressInterval);
            progressModal.style.display = 'none';
            noResultsDiv.style.display = 'block';
            errorDiv.textContent = 'No profile found';
            resetViewport();
            return;
        }

        updateProfileUI(profileData);

        progressText.textContent = `0 assets`;
        allNFTs = await fetchWithCache(`nfts_${currentUsername}`, () => fetchAllNFTs(currentUsername, (nftCount) => {
            if (isProfileLoadingCancelled) return;
            progressText.textContent = `${nftCount} assets`;
        }));

        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }

        clearInterval(progressInterval);
        progressBar.style.width = '100%';
        progressText.textContent = `${allNFTs.length} assets loaded successfully!`;
        setTimeout(() => {
            progressModal.style.display = 'none';
            resetViewport();
        }, 500);

        if (allNFTs.length > 0) {
            console.log('Populating creator filter with', allNFTs.length, 'NFTs');
            populateCreatorFilter(allNFTs);
            console.log('Populating collection filter with', allNFTs.length, 'NFTs');
            populateCollectionFilter(allNFTs);
            const hasCollections = allNFTs.some(nft => nft.collection?.name);
            collectionFilter.disabled = !hasCollections;
            creatorFilter.disabled = !allNFTs.some(nft => nft.collection?.creator?.id);
            controls.classList.add('visible');
            console.log('Filter state after population:', {
                collectionDisabled: collectionFilter.disabled,
                creatorDisabled: creatorFilter.disabled,
                hasCollections,
                collectionOptions: Array.from(collectionFilter.options).map(opt => opt.value)
            });

            const { collection } = parseUrlHash();
            if (collection) {
                const optionExists = Array.from(collectionFilter.options).some(
                    option => option.value === collection
                );
                collectionFilter.value = optionExists ? collection : '';
                console.log('URL collection parameter applied:', { collection, optionExists, selectedValue: collectionFilter.value });
            } else {
                collectionFilter.value = '';
                creatorFilter.value = '';
                chainFilter.value = '';
                curatedFilter.value = '';
                chainFilter.disabled = false;
                curatedFilter.disabled = false;
                creatorFilter.disabled = !allNFTs.some(nft => nft.collection?.creator?.id);
                collectionFilter.disabled = !hasCollections;
                console.log('No collection in URL:', {
                    curationEnabled: !curatedFilter.disabled,
                    curationValue: curatedFilter.value,
                    chainsEnabled: !chainFilter.disabled,
                    chainsValue: chainFilter.value,
                    creatorEnabled: !creatorFilter.disabled,
                    creatorValue: creatorFilter.value,
                    collectionEnabled: !collectionFilter.disabled,
                    collectionValue: collectionFilter.value
                });
            }

            console.log('Initial filter state:', {
                creator: creatorFilter.value,
                collection: collectionFilter.value,
                collectionDisabled: collectionFilter.disabled,
                chain: chainFilter.value,
                curated: curatedFilter.value
            });

            filterNFTs();
        } else {
            console.log('No NFTs found, showing no results');
            noResultsDiv.style.display = 'block';
            collectionFilter.disabled = true;
            creatorFilter.disabled = true;
            resetViewport();
        }
    } catch (error) {
        if (!isProfileLoadingCancelled) {
            console.error(`Error in fetchProfileAndNFTsForLogin: ${error.message}`);
            clearInterval(progressInterval);
            progressModal.style.display = 'none';
            errorDiv.textContent = error.message.includes('user[id=') && error.message.includes('not found')
                ? 'No profile found'
                : `Error: ${error.message}`;
            resetViewport();
        }
    }
}

function filterNFTs() {
    const collectionFilter = document.getElementById('collectionFilter');
    const creatorFilter = document.getElementById('creatorFilter');
    const chainFilter = document.getElementById('chainFilter');
    const curatedFilter = document.getElementById('curatedFilter');
    const cardSize = document.getElementById('cardSize');
    const sortBy = document.getElementById('sortBy');
    const collectionTitle = document.getElementById('collectionTitle');

    if (!collectionFilter || !creatorFilter || !chainFilter || !curatedFilter || !cardSize || !sortBy || !collectionTitle) {
        console.error('Filter elements not found');
        return;
    }

    console.log('Filtering NFTs with', allNFTs.length, 'assets', {
        creator: creatorFilter.value,
        collection: collectionFilter.value,
        chain: chainFilter.value,
        curated: curatedFilter.value
    });

    if (!allNFTs || !allNFTs.length) {
        displayNFTs([], '');
        collectionTitle.textContent = '';
        collectionTitle.classList.remove('visible');
        collectionFilter.disabled = true;
        creatorFilter.disabled = true;
        console.log('No NFTs to filter, collection and creator filters disabled');
        return;
    }

    let filteredNFTs = [...allNFTs];

    // Apply creator filter
    const creatorValue = creatorFilter.value;
    if (creatorValue) {
        filteredNFTs = filteredNFTs.filter(nft => nft.collection?.creator?.id === creatorValue);
        console.log('After creator filter:', filteredNFTs.length, 'NFTs');
    }

    // Apply collection filter
    const collectionValue = collectionFilter.value;
    if (collectionValue) {
        filteredNFTs = filteredNFTs.filter(nft => (nft.collection?.name || 'Unknown Collection') === collectionValue);
        console.log('After collection filter:', filteredNFTs.length, 'NFTs');
    }

    // Populate the collection filter based on the current creator filter
    populateCollectionFilter(creatorValue ? allNFTs.filter(nft => nft.collection?.creator?.id === creatorValue) : allNFTs);

    // Update chain and curated filters based on the filtered NFTs
    let allCurated = true, allNonCurated = true, allCronos = true, allCronosPos = true;
    filteredNFTs.forEach(nft => {
        const isCurated = nft.isCurated !== undefined ? nft.isCurated : false;
        const isExternalNft = nft.isExternalNft;
        const network = nft.externalNftMetadata?.network?.toUpperCase() || '';
        if (!isCurated) allCurated = false;
        if (isCurated) allNonCurated = false;
        if (isExternalNft !== true || network !== 'CRONOS') allCronos = false;
        if (isExternalNft !== false) allCronosPos = false;
    });

    curatedFilter.value = allCurated ? 'true' : allNonCurated ? 'false' : '';
    curatedFilter.disabled = allCurated || allNonCurated;
    chainFilter.value = allCronos ? 'CRONOS' : allCronosPos ? 'CRONOS_POS' : '';
    chainFilter.disabled = allCronos || allCronosPos;
    hasSelectedSpecificCollection = !!collectionValue;

    // Ensure filters are enabled if any NFTs exist
    const hasCollections = allNFTs.some(nft => nft.collection?.name || nft.collection);
    const hasCreators = allNFTs.some(nft => nft.collection?.creator?.id);
    collectionFilter.disabled = !hasCollections;
    creatorFilter.disabled = !hasCreators;
    console.log('Filter states:', {
        collectionDisabled: collectionFilter.disabled,
        creatorDisabled: creatorFilter.disabled,
        hasCollections,
        hasCreators,
        chainDisabled: chainFilter.disabled,
        curatedDisabled: curatedFilter.disabled
    });

    // Apply chain filter
    if (chainFilter.value) {
        filteredNFTs = filteredNFTs.filter(nft => {
            const isExternalNft = nft.isExternalNft;
            const network = nft.externalNftMetadata?.network?.toUpperCase() || '';
            if (chainFilter.value === 'CRONOS') {
                return isExternalNft === true && network === 'CRONOS';
            } else if (chainFilter.value === 'CRONOS_POS') {
                return isExternalNft === false;
            }
            return true;
        });
        console.log('After chain filter:', filteredNFTs.length, 'NFTs');
    }

    // Apply curated filter
    if (curatedFilter.value) {
        filteredNFTs = filteredNFTs.filter(nft => {
            const isCurated = nft.isCurated !== undefined ? nft.isCurated : false;
            return curatedFilter.value === 'true' ? isCurated : curatedFilter.value === 'false' ? !isCurated : true;
        });
        console.log('After curated filter:', filteredNFTs.length, 'NFTs');
    }

    // Sort NFTs
    const sortValue = sortBy.value || 'newest';
    filteredNFTs.sort((a, b) => {
        if (sortValue === 'rank') {
            return (a.defaultRarityRank || Infinity) - (b.defaultRarityRank || Infinity);
        } else if (sortValue === 'oldest') {
            return new Date(a.createdAt) - new Date(b.createdAt);
        }
        return new Date(b.createdAt) - new Date(a.createdAt);
    });

    // Mettre √† jour le titre de la collection
    let titleText = '';
    let creatorDisplayName = '';
    if (creatorValue) {
        const creatorOption = creatorFilter.querySelector(`option[value="${creatorValue}"]`);
        if (creatorOption) {
            // Extraire le displayName (en ignorant le compteur et l'ID entre parenth√®ses)
            creatorDisplayName = creatorOption.textContent.replace(/\s*\(\d+\)$/, '').trim();
            creatorDisplayName = creatorDisplayName.replace(/\s*\([^)]+\)$/, '').trim();
        }
    }

    // Construire le titre avec balises span pour stylisation
    if (creatorValue && creatorDisplayName) {
        titleText = `<span style="color: var(--color1);">${creatorDisplayName.toUpperCase()}</span> / ${collectionValue ? collectionValue.toUpperCase() : 'ALL COLLECTIONS'}`;
    } else {
        titleText = collectionValue ? collectionValue.toUpperCase() : 'ALL COLLECTIONS';
    }

    collectionTitle.innerHTML = titleText;
    collectionTitle.classList.add('visible');

    console.log('Final filtered NFTs:', filteredNFTs.length, 'for creator:', creatorFilter.value || 'All', 'collection:', collectionValue || 'All');
    displayNFTs(filteredNFTs, collectionValue);

    // Update the URL hash to reflect the current filters
    const hash = collectionValue
        ? `${encodeURIComponent(currentUsername)}/#${encodeURIComponent(collectionValue)}`
        : encodeURIComponent(currentUsername);
    history.pushState({}, '', `#${hash}`);
}

function displayNFTs(assets, selectedCollection) {
    const container = document.getElementById('nftContainer');
    const countContainer = document.getElementById('nftCountContainer');
    const downloadZipButton = document.getElementById('downloadZipButton');
    const downloadCollageButton = document.getElementById('downloadCollageButton');
    const cardSize = document.getElementById('cardSize')?.value || 'small';

    if (!container || !countContainer || !downloadZipButton || !downloadCollageButton) {
        console.error('NFT container, count container, or download buttons not found');
        return;
    }

    console.log(`displayNFTs called at ${new Date().toISOString()}:`, {
        assetCount: assets.length,
        selectedCollection: selectedCollection || 'All'
    });

    const seenIds = new Set();
    const uniqueAssets = assets.filter((asset, index) => {
        const key = asset.id || `index-${index}`;
        if (seenIds.has(key)) {
            console.warn(`Duplicate asset detected and skipped:`, {
                assetId: asset.id,
                name: asset.name,
                collectionId: asset.collection?.id
            });
            return false;
        }
        seenIds.add(key);
        return true;
    });

    console.log('Unique assets after deduplication:', uniqueAssets.map(a => ({
        id: a.id,
        name: a.name,
        collectionId: a.collection?.id
    })));

    countContainer.innerHTML = '';
    container.innerHTML = '';
    container.className = `nft-container thumbnail-mode ${cardSize}-size`;

    const countElement = document.createElement('p');
    countElement.className = 'nft-count';
    countElement.innerHTML = selectedCollection
        ? `<span style="color: var(--color1);">${currentUsername.toUpperCase()}</span> has <span class="count">${uniqueAssets.length}</span> assets on this collection.`
        : `<span style="color: var(--color1);">${currentUsername.toUpperCase()}</span> has <span class="count">${uniqueAssets.length}</span> assets.`;
    countContainer.appendChild(countElement);

    downloadZipButton.style.display = uniqueAssets.length > 0 && currentUsername ? 'inline-block' : 'none';
    downloadCollageButton.style.display = uniqueAssets.length > 0 && currentUsername ? 'inline-block' : 'none';
    if (uniqueAssets.length > 0) {
        downloadZipButton.textContent = `DOWNLOAD ${uniqueAssets.length} ASSETS`;
    }

    uniqueAssets.forEach((asset, index) => {
        const imageUrl = asset.cover?.url || 'https://via.placeholder.com/150';
        console.log(`Processing asset ${index + 1}:`, { id: asset.id, name: asset.name, imageUrl });

        const card = document.createElement('div');
        card.className = 'nft-card';

        let mediaElement;
        if (imageUrl.endsWith('.mp4')) {
            mediaElement = document.createElement('video');
            mediaElement.src = imageUrl;
            mediaElement.controls = true;
            mediaElement.muted = true;
            mediaElement.loop = true;
            mediaElement.setAttribute('playsinline', '');
        } else {
            mediaElement = document.createElement('img');
            mediaElement.src = imageUrl;
            mediaElement.alt = asset.name || 'NFT Image';
            mediaElement.loading = 'lazy'; // Restaurer lazy loading
            mediaElement.decoding = 'async';
            mediaElement.sizes = '(max-width: 768px) 80px, 200px';
        }

        mediaElement.onload = () => {
            console.log(`Media loaded successfully for asset ${index + 1}:`, { imageUrl, dimensions: `${mediaElement.naturalWidth}x${mediaElement.naturalHeight}` });
        };

        mediaElement.onerror = () => {
            console.error('Media failed to load for asset:', asset.name || 'Unnamed', { index, imageUrl });
            card.innerHTML = '';
            const placeholder = document.createElement('div');
            placeholder.className = 'media-placeholder';
            placeholder.textContent = 'M√©dia indisponible';
            card.appendChild(placeholder);
        };

        const tooltipText = (asset.name && asset.name.trim() !== '') 
            ? asset.name 
            : (asset.id ? `NFT #${asset.id}` : `Unnamed NFT #${index + 1}`);
        console.log(`Tooltip for asset ${index + 1}:`, {
            name: asset.name,
            id: asset.id,
            tooltipText,
            collection: asset.collection?.name || 'No collection'
        });

        const tooltip = document.createElement('span');
        tooltip.className = 'tooltip';
        tooltip.textContent = tooltipText;
        tooltip.style.zIndex = '300';
        card.appendChild(tooltip);

        if (imageUrl !== 'https://via.placeholder.com/150') {
            const downloadButton = document.createElement('button');
            downloadButton.className = 'download-nft-btn';
            downloadButton.title = 'Download NFT';
            downloadButton.style.zIndex = '100';
            downloadButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="#000000" class="size-4">
                    <path d="M8.75 2.75a.75.75 0 0 0-1.5 0v5.69L5.03 6.22a.75.75 0 0 0-1.06 1.06l3.5 3.5a.75.75 0 0 0 1.06 0l3.5-3.5a.75.75 0 0 0-1.06-1.06L8.75 8.44V2.75Z" />
                    <path d="M3.5 9.75a.75.75 0 0 0-1.5 0v1.5A2.75 2.75 0 0 0 4.75 14h6.5A2.75 2.75 0 0 0 14 11.25v-1.5a.75.75 0 0 0-1.5 0v1.5c0 .69-.56 1.25-1.25 1.25h-6.5c-.69 0-1.25-.56-1.25-1.25v-1.5Z" />
                </svg>
            `;
            downloadButton.onclick = () => downloadSingleNFT(imageUrl, asset.name || `NFT_${index + 1}`, index);
            card.appendChild(downloadButton);
        }

        if (asset.id) {
            const cryptoButton = document.createElement('a');
            cryptoButton.className = 'crypto-nft-btn';
            cryptoButton.title = 'View on Crypto.com';
            let searchParam = '';
            if (asset.name && asset.name.trim() !== '') {
                searchParam = `&search=${encodeURIComponent(asset.name.trim())}`;
            }
            cryptoButton.href = asset.collection?.id
                ? `https://crypto.com/nft/collection/${asset.collection.id}?tab=items${searchParam}&asset=${asset.id}`
                : `https://crypto.com/nft/profile/${currentUsername || 'unknown'}`;
            cryptoButton.target = '_blank';
            cryptoButton.setAttribute('aria-label', 'View NFT on Crypto.com');
            cryptoButton.style.zIndex = '100';
            cryptoButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="#000000">
                    <path fill-rule="evenodd" d="M8.914 6.025a.75.75 0 0 1 1.06 0 3.5 3.5 0 0 1 0 4.95l-2 2a3.5 3.5 0 0 1-5.396-4.402.75.75 0 0 1 1.251.827 2 2 0 0 0 3.085 2.514l2-2a2 2 0 0 0 0-2.828.75.75 0 0 1 0-1.06Z" clip-rule="evenodd" />
                    <path fill-rule="evenodd" d="M7.086 9.975a.75.75 0 0 1-1.06 0 3.5 3.5 0 0 1 0-4.95l2-2a3.5 3.5 0 0 1 5.396 4.402.75.75 0 0 1-1.251-.827 2 2 0 0 0-3.085-2.514l-2 2a2 2 0 0 0 0 2.828.75.75 0 0 1 0 1.06Z" clip-rule="evenodd" />
                </svg>
            `;
            cryptoButton.addEventListener('click', (e) => {
                e.stopPropagation();
                console.log(`Crypto.com button clicked for asset ${index + 1}:`, { href: cryptoButton.href });
            });
            card.appendChild(cryptoButton);
        }

        card.appendChild(mediaElement);
        container.appendChild(card);
    });

    updateDisplay();
}

async function fetchWithRetry(url, retries = 3, delay = 1000) {
    for (let i = 0; i < retries; i++) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // Timeout de 30s
            const response = await fetch(url, {
                method: 'GET',
                mode: 'cors',
                cache: 'no-cache',
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            if (!response.ok) {
                if (response.status === 429 && i < retries - 1) {
                    console.log(`Rate limit hit for ${url}, retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                    continue;
                }
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }
            return response;
        } catch (error) {
            if (i === retries - 1) throw error;
        }
    }
}

async function downloadSingleNFT(url, name, index) {
    const errorDiv = document.getElementById('error');
    if (!errorDiv) {
        console.error('Error div not found');
        return;
    }

    try {
        const response = await fetchWithRetry(url, 3, 2000);
        if (!response.ok) {
            throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
        }
        const contentType = response.headers.get('content-type');
        let extension = 'png';
        if (contentType.includes('video/mp4')) {
            extension = 'mp4';
        } else if (contentType.includes('image/jpeg')) {
            extension = 'jpg';
        } else if (contentType.includes('image/gif')) {
            extension = 'gif';
        } else if (!contentType.includes('image/png')) {
            throw new Error(`Unsupported file type: ${contentType}`);
        }
        const blob = await response.blob();
        if (!blob || blob.size === 0) {
            throw new Error('Received empty or invalid blob');
        }
        console.log(`Downloading ${name}: URL=${url}, Content-Type=${contentType}, Status=${response.status}`);
        const sanitizedName = sanitizeFileNameForZip(name, index);
        const fileName = `${sanitizedName}.${extension}`;
        const urlObj = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = urlObj;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(urlObj);
    } catch (error) {
        console.error(`Error downloading NFT ${name}: ${error.message}`);
        errorDiv.textContent = `Failed to download ${name}: ${error.message}`;
        setTimeout(() => errorDiv.textContent = '', 5000);
    }
}

async function downloadNFTsAsZip() {
    const zip = new JSZip();
    const nftContainer = document.getElementById('nftContainer');
    const errorDiv = document.getElementById('error');
    const progressModal = document.getElementById('progressModal');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const modalTitle = document.getElementById('modalTitle');
    const cancelButton = document.getElementById('cancelDownloadButton');

    if (!nftContainer || !errorDiv || !progressModal || !progressBar || !progressText || !modalTitle || !cancelButton) {
        console.error('Required DOM elements for download not found');
        if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
        return;
    }

    const filteredNFTs = Array.from(nftContainer.querySelectorAll('.nft-card')).map((card, index) => {
        const img = card.querySelector('img');
        const video = card.querySelector('video');
        const titleElement = card.querySelector('h3') || card.querySelector('.tooltip');
        const title = titleElement ? titleElement.textContent : `NFT_${index + 1}`;
        return {
            url: img ? img.src : video ? video.src : null,
            name: title,
        };
    }).filter(nft => nft.url && nft.url !== 'https://via.placeholder.com/150');

    if (filteredNFTs.length === 0) {
        errorDiv.textContent = 'No valid assets to download.';
        return;
    }

    modalTitle.textContent = 'Creating ZIP File';
    progressText.textContent = `Preparing ${filteredNFTs.length} assets`;
    progressBar.style.width = '0%';
    progressModal.style.display = 'flex';
    cancelButton.style.display = 'block';

    isDownloadCancelled = false;
    cancelButton.onclick = () => {
        isDownloadCancelled = true;
        progressText.textContent = 'Download cancelled.';
        progressBar.style.width = '0%';
        setTimeout(() => {
            progressModal.style.display = 'none';
        }, 1000);
    };

    let processed = 0;
    for (const [index, nft] of filteredNFTs.entries()) {
        if (isDownloadCancelled) {
            console.log('Download cancelled by user');
            return;
        }

        try {
            const response = await fetch(nft.url);
            if (!response.ok) {
                console.error(`Failed to fetch asset ${nft.name}: ${response.statusText}`);
                continue;
            }
            const blob = await response.blob();
            const extension = nft.url.endsWith('.mp4') ? 'mp4' : 'png';
            const sanitizedName = sanitizeFileNameForZip(nft.name);
            const fileName = `${sanitizedName}.${extension}`;
            zip.file(fileName, blob);
            processed++;
            const progressPercent = (processed / filteredNFTs.length) * 100;
            progressBar.style.width = `${progressPercent}%`;
            progressText.textContent = `Downloading: ${processed}/${filteredNFTs.length}`;
        } catch (error) {
            console.error(`Error downloading ${nft.name}: ${error.message}`);
        }
    }

    if (isDownloadCancelled) {
        console.log('Download process aborted');
        return;
    }

    if (processed === 0) {
        progressModal.style.display = 'none';
        errorDiv.textContent = 'No assets could be downloaded';
        return;
    }

    progressText.textContent = 'Generating ZIP file';
    try {
        const content = await zip.generateAsync({ type: 'blob' });
        saveAs(content, `${currentUsername}_nfts.zip`);
        progressText.textContent = 'Download complete!';
        progressBar.style.width = '100%';
        setTimeout(() => {
            progressModal.style.display = 'none';
        }, 1000);
    } catch (error) {
        console.error(`Error generating ZIP: ${error.message}`);
        progressModal.style.display = 'none';
        errorDiv.textContent = 'Failed to generate ZIP file';
    }
}

async function downloadCollage() {
    const nftContainer = document.getElementById('nftContainer');
    const errorDiv = document.getElementById('error');
    const progressModal = document.getElementById('progressModal');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const modalTitle = document.getElementById('modalTitle');
    const cancelButton = document.getElementById('cancelDownloadButton');
    const collectionFilter = document.getElementById('collectionFilter');
    const collectionTitle = document.getElementById('collectionTitle');

    if (!nftContainer || !errorDiv || !progressModal || !progressBar || !progressText || !modalTitle || !cancelButton || !collectionFilter || !collectionTitle) {
        console.error('Required DOM elements for collage download not found');
        if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
        return;
    }

    // Silently ignore if a download is already in progress
    if (window.isDownloading) {
        console.log('Download already in progress, ignoring new attempt.');
        return;
    }

    window.isDownloading = true;

    // Collect valid assets from nftContainer
    const cards = Array.from(nftContainer.querySelectorAll('.nft-card:not(.empty)'));
    if (cards.length === 0) {
        errorDiv.textContent = 'No assets to include in the collage.';
        window.isDownloading = false;
        return;
    }

    const validCards = cards
        .map((card, index) => {
            const img = card.querySelector('img');
            const video = card.querySelector('video');
            const titleElement = card.querySelector('.tooltip');
            const title = titleElement ? titleElement.textContent : `NFT_${index + 1}`;
            const src = img ? img.src : null;
            return { src, title, index, isVideo: !!video };
        })
        .filter(card => card.src && card.src !== 'https://via.placeholder.com/150' && !card.isVideo);

    if (validCards.length === 0) {
        errorDiv.textContent = 'No valid image assets to include in the collage. Try downloading individual assets as a ZIP.';
        window.isDownloading = false;
        return;
    }

    console.log(`Valid cards for collage: ${validCards.length}`, validCards.map(card => ({
        title: card.title,
        index: card.index,
        src: card.src
    })));

    modalTitle.textContent = 'Creating Collage';
    progressText.textContent = `Fetching ${validCards.length} assets`;
    progressBar.style.width = '0%';
    progressModal.style.display = 'flex';
    cancelButton.style.display = 'block';

    window.isDownloadCancelled = false;
    let collageContainer = null;
    const objectUrls = [];

    cancelButton.onclick = () => {
        window.isDownloadCancelled = true;
        progressText.textContent = 'Collage creation cancelled.';
        progressBar.style.width = '0%';
        if (collageContainer && document.body.contains(collageContainer)) {
            document.body.removeChild(collageContainer);
            console.log('Collage container removed on cancel');
        }
        setTimeout(() => {
            progressModal.style.display = 'none';
            window.isDownloading = false;
        }, 1000);
        objectUrls.forEach(url => URL.revokeObjectURL(url));
    };

    // Fetch images as blobs
    const loadedCards = [];
    const failedImages = [];
    let processed = 0;

    for (const card of validCards) {
        if (window.isDownloadCancelled) {
            console.log('Collage creation cancelled during fetch');
            window.isDownloading = false;
            objectUrls.forEach(url => URL.revokeObjectURL(url));
            return;
        }

        try {
            const response = await fetchWithRetry(card.src, 3, 5000);
            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('image/')) {
                throw new Error(`Invalid content type: ${contentType || 'none'}`);
            }
            const blob = await response.blob();
            if (!blob || blob.size === 0) {
                throw new Error('Received empty or invalid blob');
            }
            console.log(`Fetched image: ${card.title} (index ${card.index}, src: ${card.src}, size: ${blob.size} bytes)`);
            loadedCards.push({ blob, title: card.title, index: card.index });
        } catch (error) {
            console.error(`Failed to fetch image ${card.title} (index ${card.index}, src: ${card.src}): ${error.message}`);
            failedImages.push({ title: card.title, index: card.index, url: card.src, error: error.message });
        }

        processed++;
        const progressPercent = (processed / validCards.length) * 100;
        progressBar.style.width = `${progressPercent}%`;
        progressText.textContent = `Fetching: ${processed}/${validCards.length}`;
    }

    if (window.isDownloadCancelled) {
        console.log('Collage creation cancelled after fetch');
        window.isDownloading = false;
        objectUrls.forEach(url => URL.revokeObjectURL(url));
        return;
    }

    if (loadedCards.length === 0) {
        progressModal.style.display = 'none';
        errorDiv.textContent = 'No valid images could be fetched for the collage. Try downloading individual assets as a ZIP.';
        window.isDownloading = false;
        objectUrls.forEach(url => URL.revokeObjectURL(url));
        return;
    }

    if (failedImages.length > 0) {
        console.warn(`${failedImages.length} images failed to fetch:`, failedImages);
        errorDiv.textContent = `${failedImages.length} image(s) failed to fetch. ${loadedCards.length} will be included in the collage.`;
        setTimeout(() => (errorDiv.textContent = ''), 5000);
    }

    progressText.textContent = `Creating collage with ${loadedCards.length} assets`;

    try {
        const numCards = loadedCards.length;
        let cols = Math.ceil(Math.sqrt(numCards));
        let rows = Math.ceil(numCards / cols);
        if (numCards > 1) {
            while (rows * (cols - 1) >= numCards && cols > 1) {
                cols--;
                rows = Math.ceil(numCards / cols);
            }
        }
        const cardSize = 300;
        const gridWidth = cols * cardSize;
        const gridHeight = rows * cardSize;
        const borderWidth = Math.min(Math.max(Math.round(gridWidth / 20), 30), 60);
        const headerHeight = Math.min(Math.max(Math.round(gridWidth * 0.1), 80), 150);
        const margin = Math.min(Math.max(Math.round(gridWidth / 50), 10), 30);
        // Ajuster la taille de la police pour CRONOS.WTF | DEVELOPED BY UNSCOOP
        const baseCronosFontSize = Math.min(Math.max(Math.round(gridWidth / 25), 16), 32) * 0.75;
        const cronosFontSize = numCards <= 4 ? baseCronosFontSize * 0.7 : baseCronosFontSize; // R√©duire la taille pour peu de NFTs

        // Calculate dynamic font size for header to fill available width
        const availableTextWidth = gridWidth - 2 * borderWidth; // Width excluding left and right borders
        const estimatedCharWidthRatio = 0.55; // Adjusted ratio for Geomanist-Bold to better fit
        const headerText = `${currentUsername.toUpperCase() || 'UNKNOWN'} / ${collectionTitle.textContent || collectionFilter.value || 'ALL_COLLECTIONS'}`;
        const estimatedTextLength = headerText.length;
        let fontSize = Math.round(availableTextWidth / (estimatedTextLength * estimatedCharWidthRatio));
        // Ajuster la taille de la police si moins de 9 NFTs
        if (numCards < 9) {
            fontSize = Math.round(fontSize * 0.7); // R√©duire de 30% pour √©viter le troncage
        }
        fontSize = Math.min(Math.max(fontSize, 16), 50); // Limit font size between 16px and 50px

        // Create a temporary container for the collage
        collageContainer = document.createElement('div');
        collageContainer.style.position = 'absolute';
        collageContainer.style.left = '-9999px';
        collageContainer.style.width = `${gridWidth + 2 * borderWidth}px`;
        collageContainer.style.height = `${gridHeight + headerHeight + borderWidth}px`;
        collageContainer.style.backgroundColor = '#000';
        document.body.appendChild(collageContainer);

        // Add header
        const header = document.createElement('div');
        header.style.width = '100%';
        header.style.height = `${headerHeight}px`;
        header.style.display = 'flex';
        header.style.alignItems = 'center';
        header.style.justifyContent = 'space-between'; // Alignement gauche/droite
        header.style.padding = `0 ${borderWidth}px`; // Respecter la bordure √† gauche et √† droite
        header.style.boxSizing = 'border-box';
        collageContainer.appendChild(header);

        // Prepare header text (aligned left)
        const usernameText = currentUsername.toUpperCase() || 'UNKNOWN';
        const collectionText = collectionTitle.textContent || collectionFilter.value || 'ALL_COLLECTIONS';
        const theme = document.documentElement.getAttribute('data-theme') || 'dark';
        const color1 = theme === 'cdc' ? '#11bafa' : '#FF5733';

        // Create header text container (aligned left)
        const headerTextContainer = document.createElement('div');
        headerTextContainer.style.textAlign = 'left';
        headerTextContainer.style.fontFamily = 'Geomanist-Bold, Arial, sans-serif';
        headerTextContainer.style.fontSize = `${fontSize}px`; // M√™me taille pour tout l'en-t√™te
        headerTextContainer.style.lineHeight = '1.2';
        headerTextContainer.style.color = '#fff';
        headerTextContainer.style.overflow = 'hidden';
        headerTextContainer.style.textOverflow = 'ellipsis';
        headerTextContainer.style.whiteSpace = 'nowrap';
        headerTextContainer.style.margin = '0';
        headerTextContainer.style.padding = '0';
        headerTextContainer.innerHTML = `<span style="color: ${color1}">${usernameText}</span> / ${collectionText.toUpperCase()}`;
        header.appendChild(headerTextContainer);

        // Create NFT count text (aligned right)
        const nftCountText = document.createElement('div');
        nftCountText.style.textAlign = 'right';
        nftCountText.style.fontFamily = 'Geomanist-Bold, Arial, sans-serif';
        nftCountText.style.fontSize = `${fontSize}px`; // M√™me taille que l'en-t√™te
        nftCountText.style.lineHeight = '1.2';
        nftCountText.style.color = '#fff';
        nftCountText.style.overflow = 'hidden';
        nftCountText.style.whiteSpace = 'nowrap';
        nftCountText.style.margin = '0';
        nftCountText.style.padding = '0';
        nftCountText.textContent = `${loadedCards.length} NFT`; // Afficher "x NFT"
        header.appendChild(nftCountText);

        // Add grid with lateral borders
        const grid = document.createElement('div');
        grid.style.display = 'grid';
        grid.style.gridTemplateColumns = `repeat(${cols}, ${cardSize}px)`;
        grid.style.gridTemplateRows = `repeat(${rows}, ${cardSize}px)`;
        grid.style.width = `${gridWidth}px`;
        grid.style.height = `${gridHeight}px`;
        grid.style.margin = `0 ${borderWidth}px`;
        collageContainer.appendChild(grid);

        // Add images to grid
        processed = 0;
        for (let i = 0; i < loadedCards.length; i++) {
            if (window.isDownloadCancelled) {
                console.log('Collage creation cancelled');
                if (collageContainer && document.body.contains(collageContainer)) {
                    document.body.removeChild(collageContainer);
                    console.log('Collage container removed on cancel');
                }
                window.isDownloading = false;
                objectUrls.forEach(url => URL.revokeObjectURL(url));
                return;
            }

            const { blob, title, index } = loadedCards[i];
            const img = document.createElement('img');
            const objectUrl = URL.createObjectURL(blob);
            objectUrls.push(objectUrl);
            img.src = objectUrl;
            img.style.width = `${cardSize}px`;
            img.style.height = `${cardSize}px`;
            img.style.objectFit = 'cover';
            img.onerror = () => {
                console.error(`Failed to load image ${title} (index ${index}) in DOM`);
                img.style.backgroundColor = '#555';
                img.style.display = 'flex';
                img.style.alignItems = 'center';
                img.style.justifyContent = 'center';
                img.style.color = '#fff';
                img.style.fontFamily = 'Geomanist-Bold, Arial, sans-serif';
                img.style.fontSize = '16px';
                img.style.textAlign = 'center';
                img.textContent = 'Image Failed';
                failedImages.push({ title, index, error: 'Failed to load in DOM' });
            };
            grid.appendChild(img);

            processed++;
            const progressPercent = (processed / loadedCards.length) * 100;
            progressBar.style.width = `${progressPercent}%`;
            progressText.textContent = `Processing: ${processed}/${loadedCards.length}`;
        }

        // Add CRONOS.WTF | DEVELOPED BY UNSCOOP text in bottom-right corner
        const cronosText = document.createElement('div');
        cronosText.style.position = 'absolute';
        cronosText.style.bottom = `${borderWidth / 2 - cronosFontSize / 2}px`;
        cronosText.style.right = `${borderWidth}px`; // Utiliser borderWidth pour respecter la bordure droite
        cronosText.style.fontFamily = 'Geomanist-Bold, Arial, sans-serif';
        cronosText.style.fontSize = `${cronosFontSize}px`;
        cronosText.style.lineHeight = '1';
        cronosText.style.whiteSpace = 'nowrap';
        // Construire le texte avec CRONOS.WTF en blanc et UNSCOOP en couleur du th√®me
        cronosText.innerHTML = `CRONOS.WTF | DEVELOPPED BY <span style="color: ${color1}">UNSCOOP</span>`;
        collageContainer.appendChild(cronosText);

        // Wait for all images to load with timeout
        await Promise.race([
            Promise.all(
                Array.from(grid.querySelectorAll('img')).map(
                    img => new Promise(resolve => {
                        if (img.complete) {
                            console.log(`Image loaded: ${img.src}`);
                            resolve();
                        } else {
                            img.onload = () => {
                                console.log(`Image loaded: ${img.src}`);
                                resolve();
                            };
                            img.onerror = () => {
                                console.error(`Image failed to load in DOM: ${img.src}`);
                                resolve();
                            };
                        }
                    })
                )
            ),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Image loading timeout')), 30000))
        ]).catch(error => {
            console.error(`Image loading error: ${error.message}`);
            throw error;
        });

        if (window.isDownloadCancelled) {
            console.log('Collage creation cancelled');
            if (collageContainer && document.body.contains(collageContainer)) {
                document.body.removeChild(collageContainer);
                console.log('Collage container removed on cancel');
            }
            window.isDownloading = false;
            objectUrls.forEach(url => URL.revokeObjectURL(url));
            return;
        }

        if (failedImages.length > 0) {
            console.warn(`${failedImages.length} images failed to process:`, failedImages);
            errorDiv.textContent = `${failedImages.length} image(s) failed to process. ${loadedCards.length} included in the collage.`;
            setTimeout(() => (errorDiv.textContent = ''), 5000);
        }

        progressText.textContent = 'Generating collage image';
        console.log('Generating collage with html2canvas');
        try {
            const canvas = await Promise.race([
                html2canvas(collageContainer, { scale: 1, useCORS: false, logging: true }),
                new Promise((_, reject) => setTimeout(() => reject(new Error('html2canvas rendering timeout')), 60000))
            ]);

            if (collageContainer && document.body.contains(collageContainer)) {
                document.body.removeChild(collageContainer);
                console.log('Collage container removed after html2canvas');
            }
            collageContainer = null;
            objectUrls.forEach(url => URL.revokeObjectURL(url));
            objectUrls.length = 0;

            canvas.toBlob(
                (blob) => {
                    try {
                        if (!blob) {
                            throw new Error('Failed to generate blob');
                        }
                        if (window.isDownloadCancelled) {
                            console.log('Download cancelled before blob generation');
                            window.isDownloading = false;
                            return;
                        }

                        console.log('Blob generated, initiating download');
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;

                        const cleanUsername = (currentUsername || 'unknown').replace(/[^a-zA-Z0-9-_]/g, '');
                        const capitalizedUsername = cleanUsername.charAt(0).toUpperCase() + cleanUsername.slice(1);
                        const cleanCollectionText = (collectionText || 'all_collections').replace(/[^a-zA-Z0-9-_]/g, '');
                        a.download = `${capitalizedUsername}_${cleanCollectionText}.png`;

                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        progressText.textContent = 'Collage download complete!';
                        progressBar.style.width = '100%';
                        setTimeout(() => {
                            progressModal.style.display = 'none';
                            window.isDownloading = false;
                        }, 1500);
                    } catch (error) {
                        console.error(`Error during download: ${error.message}`);
                        errorDiv.textContent = `Failed to initiate download: ${error.message}. Try downloading individual assets as a ZIP.`;
                        setTimeout(() => (errorDiv.textContent = ''), 5000);
                        window.isDownloading = false;
                    }
                },
                'image/png',
                1.0
            );
        } catch (error) {
            console.error(`Error generating collage with html2canvas: ${error.message}`);
            if (collageContainer && document.body.contains(collageContainer)) {
                document.body.removeChild(collageContainer);
                console.log('Collage container removed on html2canvas error');
            }
            collageContainer = null;
            objectUrls.forEach(url => URL.revokeObjectURL(url));
            objectUrls.length = 0;
            errorDiv.textContent = `Failed to generate collage: ${error.message}. Try downloading individual assets as a ZIP.`;
            setTimeout(() => (errorDiv.textContent = ''), 5000);
            window.isDownloading = false;
        }
    } catch (error) {
        console.error(`Error generating collage: ${error.message}`);
        if (collageContainer && document.body.contains(collageContainer)) {
            document.body.removeChild(collageContainer);
            console.log('Collage container removed on general error');
        }
        collageContainer = null;
        objectUrls.forEach(url => URL.revokeObjectURL(url));
        objectUrls.length = 0;
        progressModal.style.display = 'none';
        errorDiv.textContent = `Failed to generate collage: ${error.message}. Try downloading individual assets as a ZIP.`;
        setTimeout(() => (errorDiv.textContent = ''), 5000);
        window.isDownloading = false;
    }
}

function updateDisplay() {
    const cardSize = document.getElementById('cardSize')?.value || 'small';
    const nftContainer = document.getElementById('nftContainer');

    if (!nftContainer) {
        console.error('Conteneur NFT non trouv√©');
        return;
    }

    nftContainer.className = `nft-container thumbnail-mode ${cardSize}-size`;

    // Ignorer les ajustements dynamiques sur mobile (‚â§ 768px)
    if (window.innerWidth <= 768) {
        nftContainer.style.gridTemplateColumns = ''; // Supprimer tout style inline
        console.log('Mobile view: Using CSS grid-template-columns for', cardSize);
        return;
    }

    // Calculs pour √©crans > 768px (PC)
    const baseCardWidth = cardSize === 'small' ? 110 : cardSize === 'medium' ? 180 : 280;
    const gap = 4; // √âcart fixe de 4px

    // Marges fixes de nftContainer (50px √† gauche, 50px √† droite)
    const marginLeft = 50;
    const marginRight = 50;
    const totalMargin = marginLeft + marginRight;

    // Calculer la largeur disponible
    const availableWidth = document.documentElement.clientWidth - totalMargin;

    // Calculer le nombre de colonnes
    const columnWidthWithGap = baseCardWidth + gap;
    let numColumns = Math.floor((availableWidth + gap) / columnWidthWithGap);
    numColumns = Math.max(1, numColumns); // Minimum 1 colonne

    // Calculer la largeur ajust√©e des colonnes
    const totalGaps = (numColumns - 1) * gap;
    let adjustedColumnWidth = (availableWidth - totalGaps) / numColumns;

    // Appliquer des contraintes de taille minimale/maximale
    const minWidth = baseCardWidth * 0.8; // 80% de la taille de base
    let maxWidth = baseCardWidth * 1.2; // 120% de la taille de base
    if (cardSize === 'large') {
        maxWidth = baseCardWidth * 1.5; // Assouplir pour mode large
    }
    adjustedColumnWidth = Math.min(Math.max(adjustedColumnWidth, minWidth), maxWidth);

    // R√©ajuster si la largeur totale d√©passe availableWidth
    let totalWidthWithAdjusted = numColumns * adjustedColumnWidth + totalGaps;
    if (totalWidthWithAdjusted > availableWidth) {
        numColumns = Math.max(1, numColumns - 1);
        const newTotalGaps = (numColumns - 1) * gap;
        adjustedColumnWidth = (availableWidth - newTotalGaps) / numColumns;
        adjustedColumnWidth = Math.min(Math.max(adjustedColumnWidth, minWidth), maxWidth);
        totalWidthWithAdjusted = numColumns * adjustedColumnWidth + newTotalGaps;
    }

    // Maximiser l'espace en mode "large"
    if (cardSize === 'large' && totalWidthWithAdjusted < availableWidth * 0.95) {
        adjustedColumnWidth = (availableWidth - totalGaps) / numColumns;
        adjustedColumnWidth = Math.min(Math.max(adjustedColumnWidth, minWidth), maxWidth);
    }

    // Appliquer la grille
    nftContainer.style.gridTemplateColumns = `repeat(${numColumns}, ${adjustedColumnWidth}px)`;

    // V√©rifier les d√©bordements
    const containerRect = nftContainer.getBoundingClientRect();
    const windowRightEdge = document.documentElement.clientWidth - marginRight;
    if (containerRect.right > windowRightEdge + 1) {
        console.warn(`D√©bordement d√©tect√©: container.right=${containerRect.right}px, windowRightEdge=${windowRightEdge}px`);
        numColumns = Math.max(1, numColumns - 1);
        const newTotalGaps = (numColumns - 1) * gap;
        adjustedColumnWidth = (availableWidth - newTotalGaps) / numColumns;
        adjustedColumnWidth = Math.min(Math.max(adjustedColumnWidth, minWidth), maxWidth);
        nftContainer.style.gridTemplateColumns = `repeat(${numColumns}, ${adjustedColumnWidth}px)`;
    }

    // Forcer un recalcul du layout
    nftContainer.style.display = 'none';
    nftContainer.offsetHeight; // Forcer un reflow
    nftContainer.style.display = 'grid';

    console.log(`updateDisplay (PC): clientWidth=${document.documentElement.clientWidth}px, marginLeft=${marginLeft}px, marginRight=${marginRight}px, availableWidth=${availableWidth}px, numColumns=${numColumns}, adjustedColumnWidth=${adjustedColumnWidth}px, container.right=${nftContainer.getBoundingClientRect().right}px, expectedRightEdge=${windowRightEdge}px`);
}

function setupEventListeners() {
    const usernameInput = document.getElementById('usernameInput');
    const loginUsernameInput = document.getElementById('loginUsernameInput');
    const themeButton = document.getElementById('themeButton');
    const collectionFilter = document.getElementById('collectionFilter');
    const creatorFilter = document.getElementById('creatorFilter');
    const chainFilter = document.getElementById('chainFilter');
    const curatedFilter = document.getElementById('curatedFilter');
    const cardSize = document.getElementById('cardSize');
    const sortBy = document.getElementById('sortBy');
    const navbarMenu = document.getElementById('navbarMenu');
    const cancelLoginButton = document.getElementById('cancelLoginButton');
    const myProfileLink = document.getElementById('myProfileLink');
    const logoutLink = document.getElementById('logoutLink');
    const loginLink = document.getElementById('loginLink');
    const scrollToTopButton = document.getElementById('scrollToTopButton');
    const scrollToBottomButton = document.getElementById('scrollToBottomButton');
    const navbarToggle = document.querySelector('.navbar-toggle');
    const downloadZipButton = document.getElementById('downloadZipButton');
    const downloadCollageButton = document.getElementById('downloadCollageButton');

    if (!usernameInput || !loginUsernameInput || !themeButton || !collectionFilter || 
        !creatorFilter || !chainFilter || !curatedFilter || !cardSize || !sortBy || 
        !navbarMenu || !cancelLoginButton || !myProfileLink || !logoutLink || !loginLink || 
        !navbarToggle || !downloadZipButton || !downloadCollageButton) {
        console.error('One or more DOM elements not found', {
            usernameInput: !!usernameInput,
            loginUsernameInput: !!loginUsernameInput,
            themeButton: !!themeButton,
            collectionFilter: !!collectionFilter,
            creatorFilter: !!creatorFilter,
            chainFilter: !!chainFilter,
            curatedFilter: !!curatedFilter,
            cardSize: !!cardSize,
            sortBy: !!sortBy,
            navbarMenu: !!navbarMenu,
            cancelLoginButton: !!cancelLoginButton,
            myProfileLink: !!myProfileLink,
            logoutLink: !!logoutLink,
            loginLink: !!loginLink,
            navbarToggle: !!navbarToggle,
            downloadZipButton: !!downloadZipButton,
            downloadCollageButton: !!downloadCollageButton
        });
        const errorDiv = document.getElementById('error');
        if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
        return;
    }

    themeButton.addEventListener('click', () => {
        toggleTheme();
        console.log('Theme toggle clicked');
    });

    navbarToggle.addEventListener('click', toggleMenu);
    navbarToggle.addEventListener('touchstart', (e) => {
        e.preventDefault();
        toggleMenu(e);
    }, { passive: false });

    usernameInput.addEventListener('input', debounce(async (e) => {
        const query = sanitizeInput(e.target.value);
        console.log('Main search input:', query);
        if (query.length > 2) {
            await searchProfiles(query);
        } else {
            clearSuggestions();
        }
    }, 300));

    usernameInput.addEventListener('focus', async () => {
        const query = sanitizeInput(usernameInput.value);
        if (query.length > 2) {
            console.log('Main search input focused, querying:', query);
            await searchProfiles(query);
        }
    });

    loginUsernameInput.addEventListener('input', debounce(async (e) => {
        const query = sanitizeInput(e.target.value);
        console.log('Login search input:', query);
        if (query.length > 2) {
            await searchLoginProfiles(query);
        } else {
            clearLoginSuggestions();
        }
    }, 300));

    loginUsernameInput.addEventListener('focus', async () => {
        const query = sanitizeInput(loginUsernameInput.value);
        if (query.length > 2) {
            console.log('Login search input focused, querying:', query);
            await searchLoginProfiles(query);
        }
    });

    document.addEventListener('click', (e) => {
        const suggestions = document.getElementById('suggestions');
        const loginSuggestions = document.getElementById('loginSuggestions');
        const availableFeaturesModal = document.getElementById('availableFeaturesModal');
        const inProgressModal = document.getElementById('inProgressModal');

        if (e.target.classList.contains('suggestion-item') || e.target.closest('.suggestion-item')) {
            const suggestionItem = e.target.closest('.suggestion-item');
            const username = suggestionItem.dataset.username;
            const avatar = suggestionItem.dataset.avatar;
            const isLoginModal = suggestionItem.closest('#loginModal');
            console.log('Suggestion clicked:', { username, isLoginModal });
            if (isLoginModal) {
                selectLoginSuggestion(username, avatar);
            } else {
                selectSuggestion(username);
            }
            return;
        }

        const isUpdateModalClick = (availableFeaturesModal && availableFeaturesModal.contains(e.target)) ||
                                  (inProgressModal && inProgressModal.contains(e.target));

        const isMainSearchClick = usernameInput.contains(e.target);
        const isMainSuggestionsClick = suggestions && suggestions.contains(e.target);
        const isLoginSearchClick = loginUsernameInput.contains(e.target);
        const isLoginSuggestionsClick = loginSuggestions && loginSuggestions.contains(e.target);

        if (!isMainSearchClick && !isMainSuggestionsClick && !isUpdateModalClick) {
            clearSuggestions();
        }

        if (!isLoginSearchClick && !isLoginSuggestionsClick && !isUpdateModalClick) {
            clearLoginSuggestions();
        }

        const isMenuClick = navbarMenu.contains(e.target);
        const isToggleClick = navbarToggle.contains(e.target);
        if (!isMenuClick && !isToggleClick && navbarMenu.classList.contains('active')) {
            console.log('Click outside menu, closing navbar');
            toggleMenu(e);
        }
    });

    // Gestion des filtres
    collectionFilter.addEventListener('change', () => {
        console.log('Collection filter changed:', {
            value: collectionFilter.value,
            disabled: collectionFilter.disabled,
            options: Array.from(collectionFilter.options).map(opt => ({
                value: opt.value,
                text: opt.textContent
            }))
        });
        filterNFTs();
    });

    creatorFilter.addEventListener('change', () => {
        console.log('Creator filter changed:', {
            value: creatorFilter.value,
            disabled: creatorFilter.disabled
        });
        collectionFilter.value = ''; // R√©initialiser pour √©viter les conflits
        filterNFTs();
    });

    chainFilter.addEventListener('change', () => {
        console.log('Chain filter changed:', { value: chainFilter.value });
        filterNFTs();
    });

    curatedFilter.addEventListener('change', () => {
        console.log('Curated filter changed:', { value: curatedFilter.value });
        filterNFTs();
    });

    cardSize.addEventListener('change', () => {
        console.log('Card size changed:', cardSize.value);
        updateDisplay();
    });

    sortBy.addEventListener('change', () => {
        console.log('Sort by changed:', sortBy.value);
        filterNFTs();
    });

    // Gestion du modal de connexion
    loginLink.addEventListener('click', showLoginModal);
    cancelLoginButton.addEventListener('click', resetLoginForm);

    myProfileLink.addEventListener('click', (e) => {
        e.preventDefault();
        if (loggedInUser?.username) {
            console.log('My Profile clicked, fetching for:', loggedInUser.username);
            fetchProfileAndNFTsForLogin(loggedInUser.username);
            if (navbarMenu.classList.contains('active')) {
                toggleMenu(e);
            }
        }
    });

    logoutLink.addEventListener('click', logout);

    downloadZipButton.addEventListener('click', downloadNFTsAsZip);
    downloadCollageButton.addEventListener('click', downloadCollage);

    // Gestion des boutons de d√©filement
    const toggleScrollButtons = () => {
        const scrollY = window.scrollY;
        const windowHeight = window.innerHeight;
        const documentHeight = document.documentElement.scrollHeight;
        const isScrollable = documentHeight > windowHeight + 100;

        scrollToTopButton.style.display = isScrollable && scrollY > 200 ? 'block' : 'none';
        scrollToBottomButton.style.display = isScrollable && (scrollY + windowHeight < documentHeight - 10) ? 'block' : 'none';
    };

    window.addEventListener('scroll', toggleScrollButtons);
    window.addEventListener('resize', toggleScrollButtons);
    const observer = new MutationObserver(toggleScrollButtons);
    observer.observe(document.body, { childList: true, subtree: true });

    scrollToTopButton.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
    });

    scrollToBottomButton.addEventListener('click', () => {
        window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'smooth' });
    });

    // D√©bogage pour collectionFilter
    collectionFilter.addEventListener('click', () => {
        console.log('Collection filter clicked:', {
            disabled: collectionFilter.disabled,
            value: collectionFilter.value,
            options: Array.from(collectionFilter.options).map(opt => ({
                value: opt.value,
                text: opt.textContent
            })),
            nftCount: allNFTs.length,
            hasCollections: allNFTs.some(nft => nft.collection?.name)
        });
    });

    console.log('Event listeners initialized');
    toggleScrollButtons();
}

function initialize() {
    const savedTheme = localStorage.getItem('theme') || 'dark';
    const initialTheme = savedTheme === 'light' ? 'cdc' : savedTheme;
    document.documentElement.setAttribute('data-theme', initialTheme);
    const themeButton = document.getElementById('themeButton');
    if (themeButton) {
        themeButton.textContent = initialTheme === 'dark' ? 'CDC' : 'Dark';
    }

    const savedUser = localStorage.getItem('loggedInUser');
    if (savedUser) {
        try {
            loggedInUser = JSON.parse(savedUser);
            updateLoginLink();
        } catch (error) {
            console.error('Error parsing saved user:', error);
            localStorage.removeItem('loggedInUser');
        }
    }

    resetSearchBar(); // R√©initialiser la barre de recherche au chargement

    // Afficher les fen√™tres des mises √† jour sur la page d'accueil
    const availableFeaturesModal = document.getElementById('availableFeaturesModal');
    const inProgressModal = document.getElementById('inProgressModal');
    const { username, collection } = parseUrlHash();
    if (availableFeaturesModal && inProgressModal && !username) {
        availableFeaturesModal.style.display = 'block';
        inProgressModal.style.display = 'block';
        console.log('Update modals displayed on home page');
    }

    if (username) {
        const usernameInput = document.getElementById('usernameInput');
        if (usernameInput) {
            usernameInput.value = username;
            fetchProfileAndNFTs();
        }
    }

    setupEventListeners();

    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(updateDisplay, 100);
    });

    updateDisplay();

    window.addEventListener('popstate', () => {
        const { username, collection } = parseUrlHash();
        if (username) {
            const usernameInput = document.getElementById('usernameInput');
            if (usernameInput) {
                usernameInput.value = username;
                fetchProfileAndNFTs();
            }
        }
    });
}

document.addEventListener('DOMContentLoaded', initialize);
    </script></body>
</html>
