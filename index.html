<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Browse smarter. Collect better ‚Äì Developed by Unscoop">
    <title>CRONOS.WTF | Developed by Unscoop</title>

    <!-- Favicon et ressources -->
    <link rel="icon" type="image/png" href="icon.png">
    <link rel="preload" href="icon.png" as="image">
    <link rel="preload" href="Geomanist-Bold.otf" as="font" type="font/otf" crossorigin>
    <link rel="stylesheet" href="styles.css">

    <!-- Librairies JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <!-- Open Graph (aper√ßu lien) -->
    <meta property="og:title" content="CRONOS.WTF | Developed by Unscoop">
    <meta property="og:description" content="Browse smarter. Collect better">
    <meta property="og:image" content="https://CronoBots.github.io/CronoBots/link.png">
    <meta property="og:url" content="https://CronoBots.github.io/CronoBots/">
    <meta property="og:type" content="website">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="CRONOS.WTF | Developed by Unscoop">
    <meta name="twitter:description" content="Browse smarter. Collect better">
    <meta name="twitter:image" content="https://www.cronos.wtf/link.png">
</head>

<body>
    <noscript>
        <div style="text-align: center; padding: 20px; color: var(--text-dark);">
            JavaScript is required to view this content. Please enable JavaScript in your browser settings.
        </div>
    </noscript>
    <nav class="navbar">
        <div class="navbar-logo-search-container">
            <div class="navbar-logo">
                <img src="CRONOBOTS.png" alt="Cronobots Logo">
                <span class="navbar-logo-text">CRONOS.WTF</span>
            </div>
            <div class="navbar-search">
                <input type="text" id="usernameInput" placeholder="üîé Search a profile" aria-describedby="usernameHelp" autocomplete="on" onfocus="this.placeholder=''" onblur="if(!this.value) this.placeholder='üîé Search a profile'" />
                <div class="suggestions" id="suggestions"></div>
            </div>
        </div>
        <div class="navbar-menu" id="navbarMenu">
            <a href="https://cronobots.github.io/Cronos" aria-label="Home">Home</a>
            <span class="navbar-divider"> | </span>
            <a href="#" id="myProfileLink" style="display: none;" aria-label="My Profile">My Profile</a>
            <a href="#" id="logoutLink" style="display: none;" aria-label="Logout">Logout</a>
            <a href="#" id="loginLink" aria-label="Login">Login</a>
            <div class="user-profile" id="userProfile" style="display: none;">
                <img id="userProfilePicture" src="" alt="User Profile" class="user-profile-picture" />
            </div>
        </div>
        <button class="navbar-toggle" aria-label="Toggle menu" aria-expanded="false">‚ò∞</button>
    </nav>
    <div class="main-content">
        <div class="updates-container">
            <div class="update-modal home-update-modal" id="availableFeaturesModal" role="region" aria-labelledby="availableFeaturesTitle">
                <div class="update-modal-content">
                    <div class="update-header">
                        <h3 id="availableFeaturesTitle">‚úÖ Available Features</h3>
                    </div>
                    <div class="update-content" id="availableFeaturesContent">
                        <ul>
                            <li>Profile exploration</li>
                            <li>Login</li>
                            <li>Filtering (Collection / Blockchain / Curated)</li>
                            <li>Display (Small / Medium / Large)</li>
                            <li>Sorting (Newest / Oldest / Rank)</li>
                            <li>Theme switching (Dark / CDC)</li>
                            <li>Full assets download (With NFT name)</li>
                            <li>Single asset download</li>
                            <li>Collage download</li>
                            <li>Scroll navigation buttons (Up / Down)</li>
                            <li>Community support tracking</li>
                            <li>Display name on hover üÜï</li>
	                    <li>Link to NFTs üÜï</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="update-modal home-update-modal" id="inProgressModal" role="region" aria-labelledby="inProgressTitle">
                <div class="update-modal-content">
                    <div class="update-header">
                        <h3 id="inProgressTitle">‚öôÔ∏è In development</h3>
                    </div>
                    <div class="update-content" id="inProgressContent">
                        <ul>
		            <li>Filter by artist</li>
		            <li>Filter by bundle (Manecity)</li>
		            <li>Collection viewer</li>
                            <li>Collection statistics (Floor / Volume / Owners)</li>
                            <li>Partner collections integration</li>
                            <li>Sales bot (Notifications / Automated alerts)</li>
                            <li>Leaderboards (Top holders / Top collections)</li>
                            <li>...</li>
                            <li>Send me your suggestions for improvements or bug reports on X.</li>
			    <ul>
                            	<li><a href="https://x.com/LoadedPixel_CDC" target="_blank">Twitter/X</a></li>
			    </ul>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="profile-section">
            <div class="profile-header" id="profileHeader" style="display: none;">
                <div class="profile-header-content">
                    <div class="profile-picture">
                        <img id="profilePicture" src="" alt="Profile Picture" />
                        <div class="social-container" style="display: none;" id="socialContainer">
                            <p id="croLink" style="display: none;">
                                <a href="#" target="_blank" id="croUrl" title="Visit Crypto.com/NFT Profile">
                                    <img src="CRO.png" alt="CRO Profile" class="social-icon" onerror="console.error('Failed to load CRO.png'); this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                            <p id="twitterLink" style="display: none;">
                                <a href="#" target="_blank" id="twitterUrl" title="Visit X Profile">
                                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/X_icon_2.svg/512px-X_icon_2.svg.png" alt="X Profile" class="social-icon" onerror="this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                            <p id="facebookLink" style="display: none;">
                                <a href="#" target="_blank" id="facebookUrl" title="Visit Facebook Profile">
                                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Facebook_f_logo_%282019%29.svg/512px-Facebook_f_logo_%282019%29.svg.png" alt="Facebook Profile" class="social-icon" onerror="this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                            <p id="instagramLink" style="display: none;">
                                <a href="#" target="_blank" id="instagramUrl" title="Visit Instagram Profile">
                                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/512px-Instagram_icon.png" alt="Instagram Profile" class="social-icon" onerror="this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                        </div>
                    </div>
                    <div class="profile-info">
                        <div class="username-container">
                            <h2 id="username" class="username"></h2>
                            <img id="verifiedBadge" class="verified-badge" src="https://parspng.com/wp-content/uploads/2022/07/tickpng.parspng.com-4-1024x1024.png" style="display: none;" alt="Verified" onerror="this.src='/assets/fallback-verified.png'" />
                        </div>
                        <p id="displayName" class="display-name"></p>
                    </div>
                </div>
            </div>
            <div class="controls" id="controls">
                <div class="control-group">
                    <label>COLLECTION:</label>
                    <select id="collectionFilter" onchange="filterNFTs()" disabled>
                        <option value="">ALL COLLECTIONS</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>CHAINS:</label>
                    <select id="chainFilter" onchange="filterNFTs()">
                        <option value="">ALL</option>
                        <option value="CRONOS">CRONOS</option>
                        <option value="CRONOS_POS">CRONOS POS CHAIN</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>CURATION:</label>
                    <select id="curatedFilter" onchange="filterNFTs()">
                        <option value="">ALL</option>
                        <option value="true">CURATED</option>
                        <option value="false">NON CURATED</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="cardSize">CARD SIZE:</label>
                    <select id="cardSize" onchange="updateDisplay()">
                        <option value="small" selected>SMALL</option>
                        <option value="medium">MEDIUM</option>
                        <option value="large">LARGE</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>SORT BY:</label>
                    <select id="sortBy" onchange="filterNFTs()">
                        <option value="newest" selected>NEWEST</option>
                        <option value="oldest">OLDEST</option>
                        <option value="rank">RANK</option>
                    </select>
                </div>
            </div>
            <h2 id="collectionTitle" class="collection-title"></h2>
        </div>
        <div class="timestamp" id="timestamp"></div>
        <div class="error" id="error" role="alert"></div>
        <div class="no-results" id="noResults" style="display: none;">No results found</div>
        <div id="nftCountContainer"></div>
        <div class="nft-container" id="nftContainer"></div>
        <div class="download-buttons">
            <button id="downloadZipButton" style="display: none;" onclick="downloadNFTsAsZip()">DOWNLOAD ASSETS</button>
            <button id="downloadCollageButton" style="display: none;" onclick="downloadCollage()">DOWNLOAD COLLAGE</button>
        </div>
        <div class="modal" id="progressModal">
            <div class="modal-content">
                <h3 id="modalTitle">Creating ZIP File</h3>
                <div class="progress-bar">
                    <div class="progress" id="progressBar"></div>
                </div>
                <p class="progress-text" id="progressText">Preparing</p>
                <div class="modal-buttons">
                    <button id="cancelDownloadButton" class="cancel-button">Cancel</button>
                </div>
            </div>
        </div>
        <div class="modal" id="loginModal">
            <div class="modal-content">
                <h3>Enter your Crypto.com/NFT Profile</h3>
                <div class="navbar-search" id="loginSearchContainer">
                    <input type="text" id="loginUsernameInput" placeholder="üîé Search a profile" autocomplete="on" onfocus="this.placeholder=''" onblur="if(!this.value) this.placeholder='üîé Search a profile'" />
                    <div class="suggestions" id="loginSuggestions"></div>
                </div>
                <div class="modal-buttons">
                    <button id="cancelLoginButton" class="cancel-button">Cancel</button>
                </div>
            </div>
        </div>
    </div>
    <footer class="footer">
        <div class="footer-left">
            <div class="footer-logo-container">
                <img src="CRONOBOTS.png" alt="Cronobots Logo" class="footer-logo">
                <p class="footer-text">DEVELOPED BY <a href="https://x.com/LoadedPixel_CDC" target="_blank" rel="noopener noreferrer" class="footer-link">UNSCOOP</a></p>
            </div>
        </div>
        <div class="footer-center">
            <div class="donation-section">
                <h4>Together, we make this possible</h4>
                <span class="wallet-address">0x9829e44fd04f3788F27096875Df0D2772173Ab3d</span>
                <div class="donation-progress">
                    <span class="progress-label">Community Supports: <span id="progressPercent">1143</span> CRO</span>
                    <div class="progress-bar">
                        <div class="progress" id="donationProgressBar" style="width: 8%;"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="footer-right">
            <div class="theme-toggle">
                <label>Theme:</label>
                <button id="themeButton">CDC</button>
            </div>
        </div>
    </footer>
    <button id="scrollToTopButton" aria-label="Scroll to top">‚Üë</button>
    <button id="scrollToBottomButton" aria-label="Scroll to bottom">‚Üì</button>
    <script>
        const cache = new Map();
let allNFTs = [];
let currentUsername = '';
let currentDisplayName = '';
let lastSearchedUsername = '';
let debounceTimeout = null;
let isDownloadCancelled = false;
let isProfileLoadingCancelled = false;
let loggedInUser = null;
let activeSearch = null;
let hasSelectedSpecificCollection = false;

const profileQuery = `
    query User($id: ID!, $cacheId: ID) {
        public(cacheId: $cacheId) {
            user(id: $id) {
                username
                displayName
                verified
                avatar {
                    url
                }
                twitterUsername
                facebookUsername
                instagramUsername
            }
        }
    }
`;

const nftQuery = `
    query GetProfileAssets($ownerId: ID!, $first: Int!, $skip: Int!) {
        public {
            profileAssets(ownerId: $ownerId, first: $first, skip: $skip) {
                id
                name
                cover {
                    url
                }
                collection {
                    id
                    name
                }
                isExternalNft
                externalNftMetadata {
                    network
                }
                defaultListingV2 {
                    salePriceDecimalUSD
                }
                latestPurchasedEdition {
                    priceUSD
                }
                createdAt
                defaultRarityRank
                isCurated
            }
        }
    }
`;

const graphqlEndpoint = "https://crypto.com/nft-api/graphql";
const homeUrl = "https://cronobots.github.io/Cronos";

function parseUrlHash() {
    const hash = window.location.hash.substring(1);
    if (!hash) return { username: null, collection: null };
    const parts = hash.split('/#').map(decodeURIComponent);
    return {
        username: parts[0] || null,
        collection: parts[1] || null
    };
}

function resetSearchBar() {
    const searchInput = document.getElementById('usernameInput');
    if (searchInput) {
        searchInput.value = ''; // Vider le contenu
        searchInput.blur(); // Retirer le focus
        searchInput.placeholder = 'üîé Search a profile'; // Restaurer le placeholder
    }
}

function resetViewport() {
    window.scrollTo(0, 0);
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function toggleMenu(event) {
    console.log('toggleMenu called', { eventType: event?.type || 'unknown' });
    const menu = document.getElementById('navbarMenu');
    const toggle = document.querySelector('.navbar-toggle');
    if (menu && toggle) {
        const isExpanded = menu.classList.toggle('active');
        toggle.setAttribute('aria-expanded', isExpanded);
        console.log('Menu toggled:', isExpanded ? 'visible' : 'hidden', { menuDisplay: getComputedStyle(menu).display });
    } else {
        console.error('Navbar menu or toggle not found', { menu: !!menu, toggle: !!toggle });
    }
}

function sanitizeInput(input) {
    return input.replace(/[<>]/g, '').trim().toLowerCase();
}

function sanitizeFileNameForZip(name, index = 0) {
    if (!name || name.trim() === '') {
        return `unnamed_nft_${index}`;
    }
    // Supprimer les caract√®res non valides pour les noms de fichiers
    let sanitized = name.replace(/[\/\\:*?"<>|]/g, '').trim();
    // Limiter la longueur √† 100 caract√®res
    sanitized = sanitized.substring(0, 100);
    return sanitized || `unnamed_nft_${index}`;
}

function toggleTheme() {
    const themeButton = document.getElementById('themeButton');
    if (!themeButton) {
        console.error('Theme button not found');
        return;
    }
    const currentTheme = document.documentElement.getAttribute('data-theme');
    const newTheme = currentTheme === 'dark' ? 'cdc' : 'dark'; // Remplacer 'light' par 'cdc'
    document.documentElement.setAttribute('data-theme', newTheme);
    localStorage.setItem('theme', newTheme);
    themeButton.textContent = newTheme === 'dark' ? 'CDC' : 'Dark'; // Mettre √† jour le texte du bouton
    console.log('Theme set to:', newTheme);
}

function normalizeText(text) {
    if (!text) return '';
    let normalized = text.normalize('NFKD').replace(/[\u0300-\u036f]/g, '');
    normalized = normalized.replace(/\n\s*\n/g, '\n').trim();
    return normalized;
}

function updateLoginLink() {
    const userProfile = document.getElementById('userProfile');
    const userProfilePicture = document.getElementById('userProfilePicture');
    const myProfileLink = document.getElementById('myProfileLink');
    const logoutLink = document.getElementById('logoutLink');
    const loginLink = document.getElementById('loginLink');

    if (!userProfile || !userProfilePicture || !myProfileLink || !logoutLink || !loginLink) return;

    if (loggedInUser) {
        userProfilePicture.src = loggedInUser.avatar || '/assets/fallback-icon.png';
        myProfileLink.textContent = 'My Profile';
        myProfileLink.href = `#${loggedInUser.username.toLowerCase()}`;
        userProfile.style.display = 'flex';
        myProfileLink.style.display = 'inline-block';
        logoutLink.style.display = 'inline-block';
        loginLink.style.display = 'none';
    } else {
        userProfile.style.display = 'none';
        myProfileLink.style.display = 'none';
        logoutLink.style.display = 'none';
        loginLink.style.display = 'inline-block';
    }
}

function showLoginModal(event) {
    event.preventDefault();
    const loginModal = document.getElementById('loginModal');
    const loginUsernameInput = document.getElementById('loginUsernameInput');
    const loginSearchContainer = document.getElementById('loginSearchContainer');
    if (loginModal && loginUsernameInput && loginSearchContainer) {
        loginModal.style.display = 'flex';
        loginUsernameInput.value = '';
        loginUsernameInput.focus();
        loginSearchContainer.style.display = 'flex';
        clearLoginSuggestions();
        const navbarMenu = document.getElementById('navbarMenu');
        if (navbarMenu) {
            navbarMenu.classList.remove('active');
            const toggle = document.querySelector('.navbar-toggle');
            if (toggle) toggle.setAttribute('aria-expanded', 'false');
        }
    }
}


function clearLoginSuggestions() {
    const suggestions = document.getElementById('loginSuggestions');
    if (suggestions) {
        suggestions.innerHTML = '';
        suggestions.style.display = 'none';
    }
}

function resetLoginForm() {
    const loginModal = document.getElementById('loginModal');
    const loginUsernameInput = document.getElementById('loginUsernameInput');
    const loginSearchContainer = document.getElementById('loginSearchContainer');
    if (loginModal && loginUsernameInput && loginSearchContainer) {
        loginModal.style.display = 'none';
        loginUsernameInput.value = '';
        loginSearchContainer.style.display = 'flex';
        clearLoginSuggestions();
    }
}

function logout(event) {
    event.preventDefault();
    const username = loggedInUser?.username;
    loggedInUser = null;
    localStorage.removeItem('loggedInUser');
    updateLoginLink();
    const profileHeader = document.getElementById('profileHeader');
    const nftContainer = document.getElementById('nftContainer');
    const nftCountContainer = document.getElementById('nftCountContainer');
    const noResultsDiv = document.getElementById('noResults');
    const controls = document.getElementById('controls');
    const collectionTitle = document.getElementById('collectionTitle');
    const collectionFilter = document.getElementById('collectionFilter');
    const chainFilter = document.getElementById('chainFilter');
    const curatedFilter = document.getElementById('curatedFilter');
    const usernameInput = document.getElementById('usernameInput');
    const downloadZipButton = document.getElementById('downloadZipButton');
    const downloadCollageButton = document.getElementById('downloadCollageButton');

    if (profileHeader) profileHeader.style.display = 'none';
    if (nftContainer) nftContainer.innerHTML = '';
    if (nftCountContainer) nftCountContainer.innerHTML = '';
    if (noResultsDiv) noResultsDiv.style.display = 'none';
    if (controls) controls.classList.remove('visible');
    if (collectionTitle) {
        collectionTitle.textContent = '';
        collectionTitle.classList.remove('visible');
    }
    if (collectionFilter) {
        collectionFilter.innerHTML = '<option value="">All Collections</option>';
        collectionFilter.disabled = true;
    }
    if (chainFilter) chainFilter.value = '';
    if (curatedFilter) curatedFilter.value = '';
    if (usernameInput) usernameInput.value = '';
    if (downloadZipButton) downloadZipButton.style.display = 'none';
    if (downloadCollageButton) downloadCollageButton.style.display = 'none';

    allNFTs = [];
    currentUsername = '';
    history.pushState({}, '', window.location.pathname);
    window.location.href = homeUrl;
}

async function fetchWithCache(key, fetchFn, retries = 3, delay = 1000) {
    if (key.startsWith('image_')) {
        // Ignorer le cache pour les URLs d'images
        return await fetchFn();
    }
    if (cache.has(key)) {
        console.log(`Cache hit for ${key}`);
        return cache.get(key);
    }
    for (let i = 0; i < retries; i++) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000);
            const data = await fetchFn(controller.signal);
            clearTimeout(timeoutId);
            if (data) {
                cache.set(key, data);
            } else {
                console.log(`Not caching null response for ${key}`);
            }
            return data;
        } catch (error) {
            if (i < retries - 1 && error.message.includes('429')) {
                console.log(`Rate limit hit for ${key}, retrying in ${delay}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                delay *= 2;
            } else {
                console.error(`Fetch error for ${key}:`, error.message);
                throw error;
            }
        }
    }
}

async function fetchAllNFTs(ownerId, progressCallback) {
    const first = 60;
    let skip = 0;
    let allAssets = [];
    let hasMore = true;

    while (hasMore && !isProfileLoadingCancelled) {
        const nftVariables = { ownerId, first, skip };
        try {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query: nftQuery, variables: nftVariables })
            });

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            const assets = result.data?.public?.profileAssets || [];
            // D√©bogage : Journaliser les noms des assets
            assets.forEach((asset, index) => {
                console.log(`Asset ${skip + index + 1}:`, {
                    name: asset.name || 'No name',
                    id: asset.id,
                    collection: asset.collection?.name || 'No collection'
                });
            });
            allAssets = [...allAssets, ...assets];
            skip += first;
            hasMore = assets.length === first;

            if (progressCallback) {
                progressCallback(allAssets.length);
            }
        } catch (error) {
            console.error(`Failed to fetch NFTs: ${error.message}`);
            throw error;
        }
    }

    return allAssets;
}

async function searchProfiles(query) {
    const suggestions = document.getElementById('suggestions');
    if (!suggestions) {
        console.error('Suggestions container not found');
        return;
    }

    if (!query || query.length < 3) {
        suggestions.innerHTML = '';
        suggestions.style.display = 'none';
        console.log('Query too short, clearing suggestions');
        return;
    }

    suggestions.innerHTML = '<div class="suggestion-item">Searching...</div>';
    suggestions.style.display = 'block';

    if (activeSearch) {
        activeSearch.cancel = true;
    }

    const searchToken = { cancel: false };
    activeSearch = searchToken;

    try {
        const profileData = await fetchWithCache(`profile_${query}`, async (signal) => {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: profileQuery,
                    variables: { id: query, cacheId: `getUserQuery-Profile-${query}` }
                }),
                signal
            });

            if (searchToken.cancel) {
                throw new Error('Search cancelled');
            }

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            return result.data?.public?.user;
        });

        if (searchToken.cancel) {
            console.log('Search cancelled, ignoring result');
            return;
        }

        suggestions.innerHTML = '';
        if (profileData && profileData.username) {
            const item = document.createElement('div');
            item.className = 'suggestion-item';
            
            if (profileData.avatar?.url) {
                const img = document.createElement('img');
                img.src = profileData.avatar.url;
                img.alt = `${profileData.username} avatar`;
                img.onerror = () => {
                    console.error(`Failed to load avatar for ${profileData.username}`);
                    img.style.display = 'none';
                };
                item.appendChild(img);
            }

            const text = document.createElement('span');
            text.textContent = profileData.username;
            item.appendChild(text);

            item.dataset.username = profileData.username;
            item.addEventListener('click', () => {
                selectSuggestion(profileData.username);
            });
            suggestions.appendChild(item);
            suggestions.style.display = 'block';
        } else {
            suggestions.innerHTML = '<div class="suggestion-item">No profile found</div>';
            suggestions.style.display = 'block';
        }
    } catch (error) {
        if (error.message !== 'Search cancelled') {
            console.error(`Error in searchProfiles: ${error.message}`);
            suggestions.innerHTML = `<div class="suggestion-item">${
                error.message.includes('user[id=') && error.message.includes('not found')
                    ? 'No profile found'
                    : `Error: ${error.message}`
            }</div>`;
            suggestions.style.display = 'block';
        }
    } finally {
        if (activeSearch === searchToken) {
            activeSearch = null;
        }
    }
}

function clearSuggestions() {
    const suggestions = document.getElementById('suggestions');
    if (suggestions) {
        suggestions.innerHTML = '';
        suggestions.style.display = 'none';
    }
}

function selectSuggestion(username) {
    const usernameInput = document.getElementById('usernameInput');
    if (usernameInput) {
        usernameInput.value = username;
        clearSuggestions();
        fetchProfileAndNFTs();
        resetSearchBar(); // R√©initialiser la barre apr√®s validation
    }
}

async function searchLoginProfiles(query) {
    const suggestions = document.getElementById('loginSuggestions');
    if (!suggestions) {
        console.error('Login suggestions container not found');
        return;
    }

    if (!query || query.length < 3) {
        suggestions.innerHTML = '';
        suggestions.style.display = 'none';
        return;
    }

    suggestions.innerHTML = '<div class="suggestion-item">Searching...</div>';
    suggestions.style.display = 'block';

    if (activeSearch) {
        activeSearch.cancel = true;
    }

    const searchToken = { cancel: false };
    activeSearch = searchToken;

    try {
        const profileData = await fetchWithCache(`profile_${query}`, async (signal) => {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: profileQuery,
                    variables: { id: query, cacheId: `getUserQuery-Profile-${query}` }
                }),
                signal
            });

            if (searchToken.cancel) {
                throw new Error('Search cancelled');
            }

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            return result.data?.public?.user;
        });

        if (searchToken.cancel) {
            console.log('Search cancelled, ignoring result');
            return;
        }

        suggestions.innerHTML = '';
        if (profileData && profileData.username) {
            const item = document.createElement('div');
            item.className = 'suggestion-item';
            
            if (profileData.avatar?.url) {
                const img = document.createElement('img');
                img.src = profileData.avatar.url;
                img.alt = `${profileData.username} avatar`;
                img.onerror = () => {
                    console.error(`Failed to load avatar for ${profileData.username}`);
                    img.style.display = 'none';
                };
                item.appendChild(img);
            }

            const text = document.createElement('span');
            text.textContent = profileData.username;
            item.appendChild(text);

            item.dataset.username = profileData.username;
            item.dataset.avatar = profileData.avatar?.url || '';
            item.addEventListener('click', () => {
                selectLoginSuggestion(profileData.username, profileData.avatar?.url);
            });
            suggestions.appendChild(item);
            suggestions.style.display = 'block';
        } else {
            suggestions.innerHTML = '<div class="suggestion-item">No profile found</div>';
            suggestions.style.display = 'block';
        }
    } catch (error) {
        if (error.message !== 'Search cancelled') {
            console.error(`Error in searchLoginProfiles: ${error.message}`);
            suggestions.innerHTML = `<div class="suggestion-item">${
                error.message.includes('user[id=') && error.message.includes('not found')
                    ? 'No profile found'
                    : `Error: ${error.message}`
            }</div>`;
            suggestions.style.display = 'block';
        }
    } finally {
        if (activeSearch === searchToken) {
            activeSearch = null;
        }
    }
}

async function selectLoginSuggestion(username, avatarUrl) {
    const loginUsernameInput = document.getElementById('loginUsernameInput');
    const loginModal = document.getElementById('loginModal');
    const errorDiv = document.getElementById('error');

    if (!loginUsernameInput || !loginModal || !errorDiv) {
        console.error('Required DOM elements not found');
        return;
    }

    try {
        // R√©cup√©rer les donn√©es du profil via l'API
        const profileData = await fetchWithCache(`profile_${username}`, async (signal) => {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: profileQuery,
                    variables: { id: username, cacheId: `getUserQuery-Profile-${username}` }
                }),
                signal
            });

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            return result.data?.public?.user;
        });

        if (profileData && profileData.username) {
            // Stocker les informations de l'utilisateur connect√©
            loggedInUser = {
                username: profileData.username,
                displayName: profileData.displayName || profileData.username,
                avatar: profileData.avatar?.url || '',
                twitterUsername: profileData.twitterUsername || '',
                facebookUsername: profileData.facebookUsername || '',
                instagramUsername: profileData.instagramUsername || '',
                verified: profileData.verified || false
            };
            localStorage.setItem('loggedInUser', JSON.stringify(loggedInUser));

            // Mettre √† jour l'interface de connexion (navbar)
            updateLoginLink();

            // Fermer le modal
            loginModal.style.display = 'none';
            errorDiv.textContent = '';
            loginUsernameInput.value = '';

            // Charger et afficher le profil complet
            updateProfileUI(profileData);
            fetchProfileAndNFTsForLogin(profileData.username);
        } else {
            errorDiv.textContent = 'No profile found';
        }
    } catch (error) {
        console.error(`Error in selectLoginSuggestion: ${error.message}`);
        errorDiv.textContent = error.message.includes('user[id=') && error.message.includes('not found')
            ? 'No profile found'
            : `Error: ${error.message}`;
    }
}

function updateProfileUI(profileData) {
    const profileHeader = document.getElementById('profileHeader');
    const profilePicture = document.getElementById('profilePicture');
    const username = document.getElementById('username');
    const verifiedBadge = document.getElementById('verifiedBadge');
    const displayName = document.getElementById('displayName');
    const socialContainer = document.getElementById('socialContainer');
    const croLink = document.getElementById('croLink');
    const croUrl = document.getElementById('croUrl');
    const twitterLink = document.getElementById('twitterLink');
    const twitterUrl = document.getElementById('twitterUrl');
    const facebookLink = document.getElementById('facebookLink');
    const facebookUrl = document.getElementById('facebookUrl');
    const instagramLink = document.getElementById('instagramLink');
    const instagramUrl = document.getElementById('instagramUrl');
    const usernameInput = document.getElementById('usernameInput');

    if (!profileHeader || !profilePicture || !username || !verifiedBadge || !displayName || !socialContainer ||
        !croLink || !croUrl || !twitterLink || !twitterUrl || !facebookLink || !facebookUrl || !instagramLink || !instagramUrl || !usernameInput) {
        console.error('Profile UI elements not found');
        return;
    }

    if (!profileData || !profileData.username) {
        console.error('Invalid profile data');
        return;
    }

    username.textContent = profileData.username || 'Unknown';
    currentUsername = profileData.username || '';
    displayName.textContent = profileData.displayName || '';
    displayName.style.display = profileData.displayName ? 'block' : 'none';
    currentDisplayName = profileData.displayName || profileData.username || 'Unknown';

    verifiedBadge.style.display = profileData.verified === true ? 'inline-block' : 'none';
    profilePicture.src = profileData.avatar?.url || '';
    profilePicture.style.display = profileData.avatar?.url ? 'block' : 'none';

    let hasSocialLinks = false;

    if (currentUsername) {
        croUrl.href = `https://crypto.com/nft/profile/${sanitizeInput(currentUsername)}`;
        croLink.style.display = 'inline-block';
        hasSocialLinks = true;
    } else {
        croLink.style.display = 'none';
    }

    if (profileData.twitterUsername) {
        twitterUrl.href = `https://x.com/${sanitizeInput(profileData.twitterUsername)}`;
        twitterLink.style.display = 'inline-block';
        hasSocialLinks = true;
    } else {
        twitterLink.style.display = 'none';
    }

    if (profileData.facebookUsername) {
        facebookUrl.href = `https://facebook.com/${sanitizeInput(profileData.facebookUsername)}`;
        facebookLink.style.display = 'inline-block';
        hasSocialLinks = true;
    } else {
        facebookLink.style.display = 'none';
    }

    if (profileData.instagramUsername) {
        instagramUrl.href = `https://instagram.com/${sanitizeInput(profileData.instagramUsername)}`;
        instagramLink.style.display = 'inline-block';
        hasSocialLinks = true;
    } else {
        instagramLink.style.display = 'none';
    }

    socialContainer.style.display = hasSocialLinks ? 'flex' : 'none';
    profileHeader.style.display = 'block';
    usernameInput.value = '';
}

async function fetchProfileAndNFTs() {
    const usernameInput = document.getElementById('usernameInput');
    const errorDiv = document.getElementById('error');
    const noResultsDiv = document.getElementById('noResults');
    const controls = document.getElementById('controls');
    const collectionTitle = document.getElementById('collectionTitle');
    const profileHeader = document.getElementById('profileHeader');
    const nftContainer = document.getElementById('nftContainer');
    const nftCountContainer = document.getElementById('nftCountContainer');
    const collectionFilter = document.getElementById('collectionFilter');
    const chainFilter = document.getElementById('chainFilter');
    const curatedFilter = document.getElementById('curatedFilter');
    const cardSize = document.getElementById('cardSize');
    const sortBy = document.getElementById('sortBy');
    const downloadZipButton = document.getElementById('downloadZipButton');
    const downloadCollageButton = document.getElementById('downloadCollageButton');
    const progressModal = document.getElementById('progressModal');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const modalTitle = document.getElementById('modalTitle');
    const cancelButton = document.getElementById('cancelDownloadButton');
    const availableFeaturesModal = document.getElementById('availableFeaturesModal');
    const inProgressModal = document.getElementById('inProgressModal');

    if (!usernameInput || !errorDiv || !noResultsDiv || !controls || !collectionTitle ||
        !profileHeader || !nftContainer || !nftCountContainer || !collectionFilter || 
        !chainFilter || !curatedFilter || !cardSize || !sortBy || 
        !downloadZipButton || !downloadCollageButton || !progressModal || 
        !progressBar || !progressText || !modalTitle || !cancelButton) {
        console.error('Required DOM elements not found');
        if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
        return;
    }

    const username = sanitizeInput(usernameInput.value.trim());
    if (!username || username.toLowerCase() === currentUsername.toLowerCase()) {
        console.log('fetchProfileAndNFTs skipped:', { username, currentUsername });
        return;
    }

    console.log('Starting fetchProfileAndNFTs for:', username);

    currentUsername = '';
    allNFTs = [];
    cardSize.value = 'small';
    sortBy.value = 'newest';
    collectionFilter.innerHTML = '<option value="">All Collections</option>';
    collectionFilter.value = '';
    chainFilter.value = '';
    curatedFilter.value = '';
    chainFilter.disabled = false;
    curatedFilter.disabled = false;

    currentUsername = username;
    lastSearchedUsername = currentUsername;
    clearSuggestions();

    // Masquer les modales de mise √† jour
    if (availableFeaturesModal) availableFeaturesModal.style.display = 'none';
    if (inProgressModal) inProgressModal.style.display = 'none';

    profileHeader.style.display = 'none';
    nftContainer.innerHTML = '';
    nftCountContainer.innerHTML = '';
    noResultsDiv.style.display = 'none';
    controls.classList.remove('visible');
    collectionTitle.textContent = '';
    collectionTitle.classList.remove('visible');
    errorDiv.textContent = '';
    downloadZipButton.style.display = 'none';
    downloadCollageButton.style.display = 'none';
    resetSearchBar();

    modalTitle.textContent = 'Loading Profile';
    progressText.textContent = `Loading profile for ${username}...`;
    progressBar.style.width = '0%';
    progressModal.style.display = 'flex';
    cancelButton.style.display = 'block';

    isProfileLoadingCancelled = false;
    cancelButton.onclick = () => {
        isProfileLoadingCancelled = true;
        progressText.textContent = 'Profile loading cancelled.';
        progressBar.style.width = '0%';
        setTimeout(() => {
            progressModal.style.display = 'none';
            window.location.href = homeUrl;
        }, 1000);
    };

    let progress = 0;
    const progressInterval = setInterval(() => {
        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }
        progress += 10;
        progressBar.style.width = `${Math.min(progress, 80)}%`;
    }, 500);

    try {
        const profileData = await fetchWithCache(`profile_${currentUsername}`, async (signal) => {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: profileQuery,
                    variables: { id: currentUsername, cacheId: `getUserQuery-Profile-${currentUsername}` }
                }),
                signal
            });

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            return result.data?.public?.user;
        });

        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }

        if (!profileData) {
            clearInterval(progressInterval);
            progressModal.style.display = 'none';
            noResultsDiv.style.display = 'block';
            errorDiv.textContent = 'No profile found';
            resetViewport();
            return;
        }

        updateProfileUI(profileData);

        progressText.textContent = `0 assets`;
        allNFTs = await fetchWithCache(`nfts_${currentUsername}`, () => fetchAllNFTs(currentUsername, (nftCount) => {
            if (isProfileLoadingCancelled) return;
            progressText.textContent = `${nftCount} assets`;
        }));

        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }

        clearInterval(progressInterval);
        progressBar.style.width = '100%';
        progressText.textContent = `${allNFTs.length} assets loaded successfully!`;
        setTimeout(() => {
            progressModal.style.display = 'none';
            resetViewport();
        }, 500);

        if (allNFTs.length > 0) {
            console.log('Populating collection filter with', allNFTs.length, 'NFTs');
            populateCollectionFilter(allNFTs);
            collectionFilter.disabled = false;
            controls.classList.add('visible');
            console.log('Applying filters and displaying NFTs with', allNFTs.length, 'assets');

            const { collection } = parseUrlHash();
            if (collection) {
                const optionExists = Array.from(collectionFilter.options).some(
                    option => option.value === collection
                );
                collectionFilter.value = optionExists ? collection : '';
            } else {
                collectionFilter.value = '';
                chainFilter.value = '';
                curatedFilter.value = '';
                chainFilter.disabled = false;
                curatedFilter.disabled = false;
                console.log('No collection in URL: CURATION enabled=', !curatedFilter.disabled, 'value=', curatedFilter.value);
                console.log('No collection in URL: CHAINS enabled=', !chainFilter.disabled, 'value=', chainFilter.value);
            }

            // Garde-fou : s'assurer que les filtres sont activ√©s apr√®s le chargement
            if (!collectionFilter.value) {
                chainFilter.value = '';
                curatedFilter.value = '';
                chainFilter.disabled = false;
                curatedFilter.disabled = false;
                console.log('Post-loading check: CURATION enabled=', !curatedFilter.disabled, 'value=', curatedFilter.value);
                console.log('Post-loading check: CHAINS enabled=', !chainFilter.disabled, 'value=', chainFilter.value);
            }

            filterNFTs();
        } else {
            console.log('No NFTs found, showing no results');
            noResultsDiv.style.display = 'block';
            resetViewport();
        }
    } catch (error) {
        if (!isProfileLoadingCancelled) {
            console.error(`Error in fetchProfileAndNFTs: ${error.message}`);
            clearInterval(progressInterval);
            progressModal.style.display = 'none';
            errorDiv.textContent = error.message.includes('user[id=') && error.message.includes('not found')
                ? 'No profile found'
                : `Error: ${error.message}`;
            resetViewport();
        }
    }
}

async function fetchProfileAndNFTsForLogin(username) {
    console.log('fetchProfileAndNFTsForLogin called for username:', username);
    const errorDiv = document.getElementById('error');
    const noResultsDiv = document.getElementById('noResults');
    const controls = document.getElementById('controls');
    const collectionTitle = document.getElementById('collectionTitle');
    const profileHeader = document.getElementById('profileHeader');
    const nftContainer = document.getElementById('nftContainer');
    const nftCountContainer = document.getElementById('nftCountContainer');
    const collectionFilter = document.getElementById('collectionFilter');
    const chainFilter = document.getElementById('chainFilter');
    const curatedFilter = document.getElementById('curatedFilter');
    const cardSize = document.getElementById('cardSize');
    const sortBy = document.getElementById('sortBy');
    const downloadZipButton = document.getElementById('downloadZipButton');
    const downloadCollageButton = document.getElementById('downloadCollageButton');
    const progressModal = document.getElementById('progressModal');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const modalTitle = document.getElementById('modalTitle');
    const cancelButton = document.getElementById('cancelDownloadButton');
    const availableFeaturesModal = document.getElementById('availableFeaturesModal');
    const inProgressModal = document.getElementById('inProgressModal');

    if (!errorDiv || !noResultsDiv || !controls || !collectionTitle ||
        !profileHeader || !nftContainer || !nftCountContainer || !collectionFilter || 
        !chainFilter || !curatedFilter || !cardSize || !sortBy || 
        !downloadZipButton || !downloadCollageButton || !progressModal || 
        !progressBar || !progressText || !modalTitle || !cancelButton) {
        console.error('Required DOM elements not found');
        if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
        return;
    }

    const sanitizedUsername = sanitizeInput(username.trim());
    if (!sanitizedUsername) {
        console.log('No username provided');
        errorDiv.textContent = 'No username provided';
        return;
    }

    console.log('Starting fetchProfileAndNFTsForLogin for:', sanitizedUsername);

    currentUsername = '';
    allNFTs = [];
    cardSize.value = 'small';
    sortBy.value = 'newest';
    collectionFilter.innerHTML = '<option value="">All Collections</option>';
    collectionFilter.value = '';
    chainFilter.value = '';
    curatedFilter.value = '';
    chainFilter.disabled = false;
    curatedFilter.disabled = false;

    currentUsername = sanitizedUsername;
    lastSearchedUsername = currentUsername;
    clearSuggestions();

    // Masquer les modales de mise √† jour
    if (availableFeaturesModal) availableFeaturesModal.style.display = 'none';
    if (inProgressModal) inProgressModal.style.display = 'none';

    profileHeader.style.display = 'none';
    nftContainer.innerHTML = '';
    nftCountContainer.innerHTML = '';
    noResultsDiv.style.display = 'none';
    controls.classList.remove('visible');
    collectionTitle.textContent = '';
    collectionTitle.classList.remove('visible');
    errorDiv.textContent = '';
    downloadZipButton.style.display = 'none';
    downloadCollageButton.style.display = 'none';

    modalTitle.textContent = 'Loading Profile';
    progressText.textContent = `Loading profile for ${sanitizedUsername}...`;
    progressBar.style.width = '0%';
    progressModal.style.display = 'flex';
    cancelButton.style.display = 'block';

    isProfileLoadingCancelled = false;
    cancelButton.onclick = () => {
        isProfileLoadingCancelled = true;
        progressText.textContent = 'Profile loading cancelled.';
        progressBar.style.width = '0%';
        setTimeout(() => {
            progressModal.style.display = 'none';
            window.location.href = homeUrl;
        }, 1000);
    };

    let progress = 0;
    const progressInterval = setInterval(() => {
        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }
        progress += 10;
        progressBar.style.width = `${Math.min(progress, 80)}%`;
    }, 500);

    try {
        const profileData = await fetchWithCache(`profile_${currentUsername}`, async (signal) => {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: profileQuery,
                    variables: { id: currentUsername, cacheId: `getUserQuery-Profile-${currentUsername}` }
                }),
                signal
            });

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            return result.data?.public?.user;
        });

        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }

        if (!profileData) {
            clearInterval(progressInterval);
            progressModal.style.display = 'none';
            noResultsDiv.style.display = 'block';
            errorDiv.textContent = 'No profile found';
            resetViewport();
            return;
        }

        updateProfileUI(profileData);

        progressText.textContent = `0 assets`;
        allNFTs = await fetchWithCache(`nfts_${currentUsername}`, () => fetchAllNFTs(currentUsername, (nftCount) => {
            if (isProfileLoadingCancelled) return;
            progressText.textContent = `${nftCount} assets`;
        }));

        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }

        clearInterval(progressInterval);
        progressBar.style.width = '100%';
        progressText.textContent = `${allNFTs.length} assets loaded successfully!`;
        setTimeout(() => {
            progressModal.style.display = 'none';
            resetViewport();
        }, 500);

        if (allNFTs.length > 0) {
            console.log('Populating collection filter with', allNFTs.length, 'NFTs');
            populateCollectionFilter(allNFTs);
            collectionFilter.disabled = false;
            controls.classList.add('visible');
            console.log('Applying filters and displaying NFTs with', allNFTs.length, 'assets');

            const { collection } = parseUrlHash();
            if (collection) {
                const optionExists = Array.from(collectionFilter.options).some(
                    option => option.value === collection
                );
                collectionFilter.value = optionExists ? collection : '';
            } else {
                collectionFilter.value = '';
                chainFilter.value = '';
                curatedFilter.value = '';
                chainFilter.disabled = false;
                curatedFilter.disabled = false;
                console.log('No collection in URL: CURATION enabled=', !curatedFilter.disabled, 'value=', curatedFilter.value);
                console.log('No collection in URL: CHAINS enabled=', !chainFilter.disabled, 'value=', chainFilter.value);
            }

            // Garde-fou : s'assurer que les filtres sont activ√©s apr√®s le chargement
            if (!collectionFilter.value) {
                chainFilter.value = '';
                curatedFilter.value = '';
                chainFilter.disabled = false;
                curatedFilter.disabled = false;
                console.log('Post-loading check: CURATION enabled=', !curatedFilter.disabled, 'value=', curatedFilter.value);
                console.log('Post-loading check: CHAINS enabled=', !chainFilter.disabled, 'value=', chainFilter.value);
            }

            filterNFTs();
        } else {
            console.log('No NFTs found, showing no results');
            noResultsDiv.style.display = 'block';
            resetViewport();
        }
    } catch (error) {
        if (!isProfileLoadingCancelled) {
            console.error(`Error in fetchProfileAndNFTsForLogin: ${error.message}`);
            clearInterval(progressInterval);
            progressModal.style.display = 'none';
            errorDiv.textContent = error.message.includes('user[id=') && error.message.includes('not found')
                ? 'No profile found'
                : `Error: ${error.message}`;
            resetViewport();
        }
    }
}

function populateCollectionFilter(nfts) {
    const collectionFilter = document.getElementById('collectionFilter');
    if (!collectionFilter) return;

    const collectionCounts = {};
    nfts.forEach(nft => {
        const collectionName = nft.collection?.name;
        if (collectionName) {
            collectionCounts[collectionName] = (collectionCounts[collectionName] || 0) + 1;
        }
    });

    const sortedCollections = Object.keys(collectionCounts).sort((a, b) => {
        return collectionCounts[b] - collectionCounts[a];
    });

    collectionFilter.innerHTML = '<option value="">All Collections</option>';
    sortedCollections.forEach(collection => {
        const option = document.createElement('option');
        option.value = collection;
        option.textContent = `${collection} (${collectionCounts[collection]})`;
        collectionFilter.appendChild(option);
    });
}

function filterNFTs() {
    const collectionFilter = document.getElementById('collectionFilter');
    const chainFilter = document.getElementById('chainFilter');
    const curatedFilter = document.getElementById('curatedFilter');
    const cardSize = document.getElementById('cardSize');
    const sortBy = document.getElementById('sortBy');
    const collectionTitle = document.getElementById('collectionTitle');

    if (!collectionFilter || !chainFilter || !curatedFilter || !cardSize || !sortBy || !collectionTitle) {
        console.error('Filter elements not found');
        return;
    }

    console.log('Filtering NFTs with', allNFTs.length, 'assets', {
        collection: collectionFilter.value,
        chain: chainFilter.value,
        curated: curatedFilter.value
    });

    if (!allNFTs || !allNFTs.length) {
        console.log('No NFTs to filter, displaying empty');
        displayNFTs([], '');
        collectionTitle.textContent = '';
        collectionTitle.classList.remove('visible');
        return;
    }

    let filteredNFTs = [...allNFTs];

    const collectionValue = collectionFilter.value;

    if (collectionValue) {
        filteredNFTs = filteredNFTs.filter(nft => nft.collection?.name === collectionValue);
        console.log('After collection filter:', filteredNFTs.length, 'NFTs');

        let allCurated = true;
        let allNonCurated = true;
        let allCronos = true;
        let allCronosPos = true;

        filteredNFTs.forEach(nft => {
            const isCurated = nft.isCurated !== undefined ? nft.isCurated : false;
            const isExternalNft = nft.isExternalNft;
            const network = nft.externalNftMetadata?.network?.toUpperCase() || '';

            if (!isCurated) allCurated = false;
            if (isCurated) allNonCurated = false;
            if (isExternalNft !== true || network !== 'CRONOS') allCronos = false;
            if (isExternalNft !== false) allCronosPos = false;
        });

        curatedFilter.value = allCurated ? 'true' : allNonCurated ? 'false' : '';
        curatedFilter.disabled = true;
        chainFilter.value = allCronos ? 'CRONOS' : allCronosPos ? 'CRONOS_POS' : '';
        chainFilter.disabled = true;
        hasSelectedSpecificCollection = true; // Indiquer qu'une collection sp√©cifique a √©t√© s√©lectionn√©e
        console.log('CURATION filter: value=', curatedFilter.value, 'disabled=', curatedFilter.disabled);
        console.log('CHAINS filter: value=', chainFilter.value, 'disabled=', chainFilter.disabled);
    } else {
        // Lorsque "ALL Collections" est s√©lectionn√©
        chainFilter.disabled = false;
        curatedFilter.disabled = false;
        if (hasSelectedSpecificCollection) {
            // R√©initialiser les filtres √† "ALL" une seule fois apr√®s une collection sp√©cifique
            chainFilter.value = '';
            curatedFilter.value = '';
            hasSelectedSpecificCollection = false; // R√©initialiser pour √©viter une nouvelle r√©initialisation
            console.log('ALL Collections selected after specific collection: CURATION reset to value=', curatedFilter.value, 'disabled=', curatedFilter.disabled);
            console.log('ALL Collections selected after specific collection: CHAINS reset to value=', chainFilter.value, 'disabled=', curatedFilter.disabled);
        } else {
            console.log('ALL Collections selected: CURATION value=', curatedFilter.value, 'disabled=', curatedFilter.disabled);
            console.log('ALL Collections selected: CHAINS value=', chainFilter.value, 'disabled=', chainFilter.disabled);
        }
    }

    // Apply CHAINS filter if a value is selected
    if (chainFilter.value) {
        filteredNFTs = filteredNFTs.filter(nft => {
            const isExternalNft = nft.isExternalNft;
            const network = nft.externalNftMetadata?.network?.toUpperCase() || '';
            if (chainFilter.value === 'CRONOS') {
                return isExternalNft === true && network === 'CRONOS';
            } else if (chainFilter.value === 'CRONOS_POS') {
                return isExternalNft === false;
            }
            return true;
        });
        console.log('After chain filter:', filteredNFTs.length, 'NFTs');
    }

    // Apply CURATION filter if a value is selected
    if (curatedFilter.value) {
        filteredNFTs = filteredNFTs.filter(nft => {
            const isCurated = nft.isCurated !== undefined ? nft.isCurated : false;
            return curatedFilter.value === 'true' ? isCurated : curatedFilter.value === 'false' ? !isCurated : true;
        });
        console.log('After curated filter:', filteredNFTs.length, 'NFTs');
    }

    // Apply sorting
    const sortValue = sortBy.value || 'newest';
    console.log('Selected sort value:', sortValue);
    if (sortValue === 'rank') {
        filteredNFTs.sort((a, b) => (a.defaultRarityRank || Infinity) - (b.defaultRarityRank || Infinity));
    } else if (sortValue === 'oldest') {
        filteredNFTs.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
    } else {
        filteredNFTs.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    }

    console.log('Final filtered NFTs:', filteredNFTs.length, 'for collection:', collectionValue || 'All', 'chain:', chainFilter.value || 'All', 'curated:', curatedFilter.value || 'All');

    collectionTitle.textContent = collectionValue || 'All Collections';
    collectionTitle.classList.add('visible');

    displayNFTs(filteredNFTs, collectionValue);
}

function displayNFTs(assets, selectedCollection) {
    const container = document.getElementById('nftContainer');
    const countContainer = document.getElementById('nftCountContainer');
    const downloadZipButton = document.getElementById('downloadZipButton');
    const downloadCollageButton = document.getElementById('downloadCollageButton');
    const cardSize = document.getElementById('cardSize')?.value || 'small';

    if (!container || !countContainer || !downloadZipButton || !downloadCollageButton) {
        console.error('NFT container, count container, or download buttons not found');
        return;
    }

    console.log(`displayNFTs called at ${new Date().toISOString()}:`, {
        assetCount: assets.length,
        selectedCollection: selectedCollection || 'All'
    });

    const seenIds = new Set();
    const uniqueAssets = assets.filter((asset, index) => {
        const key = asset.id || `index-${index}`;
        if (seenIds.has(key)) {
            console.warn(`Duplicate asset detected and skipped:`, {
                assetId: asset.id,
                name: asset.name,
                collectionId: asset.collection?.id
            });
            return false;
        }
        seenIds.add(key);
        return true;
    });
    console.log('Unique assets after deduplication:', uniqueAssets.map(a => ({
        id: a.id,
        name: a.name,
        collectionId: a.collection?.id
    })));

    countContainer.innerHTML = '';
    container.innerHTML = '';
    container.className = `nft-container thumbnail-mode ${cardSize}-size`;

    const countElement = document.createElement('p');
    countElement.className = 'nft-count';
    countElement.innerHTML = selectedCollection
        ? `<span style="color: var(--color1);">${currentUsername.toUpperCase()}</span> has <span class="count">${uniqueAssets.length}</span> assets on this collection.`
        : `<span style="color: var(--color1);">${currentUsername.toUpperCase()}</span> has <span class="count">${uniqueAssets.length}</span> assets.`;
    countContainer.appendChild(countElement);

    downloadZipButton.style.display = uniqueAssets.length > 0 && currentUsername ? 'inline-block' : 'none';
    downloadCollageButton.style.display = uniqueAssets.length > 0 && currentUsername ? 'inline-block' : 'none';
    if (uniqueAssets.length > 0) {
        downloadZipButton.textContent = `DOWNLOAD ${uniqueAssets.length} ASSETS`;
    }

    uniqueAssets.forEach((asset, index) => {
        const imageUrl = asset.cover?.url || 'https://via.placeholder.com/150';
        const card = document.createElement('div');
        card.className = 'nft-card';

        let mediaElement;
        if (imageUrl.endsWith('.mp4')) {
            mediaElement = document.createElement('video');
            mediaElement.src = imageUrl;
            mediaElement.controls = true;
            mediaElement.muted = true;
            mediaElement.loop = true;
            mediaElement.setAttribute('playsinline', '');
        } else {
            mediaElement = document.createElement('img');
            mediaElement.src = imageUrl;
            mediaElement.alt = asset.name || 'NFT Image';
            mediaElement.loading = 'lazy';
            mediaElement.decoding = 'async';
            mediaElement.sizes = '(max-width: 768px) 80px, 200px';
        }

        mediaElement.onerror = () => {
            console.error('Media failed to load for asset:', asset.name || 'Unnamed', { index, imageUrl });
            card.innerHTML = '';
            const placeholder = document.createElement('div');
            placeholder.className = 'media-placeholder';
            placeholder.textContent = 'M√©dia indisponible';
            card.appendChild(placeholder);
        };

        const tooltipText = (asset.name && asset.name.trim() !== '') 
            ? asset.name 
            : (asset.id ? `NFT #${asset.id}` : `Unnamed NFT #${index + 1}`);
        console.log(`Tooltip for asset ${index + 1}:`, {
            name: asset.name,
            id: asset.id,
            tooltipText,
            collection: asset.collection?.name || 'No collection'
        });

        const tooltip = document.createElement('span');
        tooltip.className = 'tooltip';
        tooltip.textContent = tooltipText;
        tooltip.style.zIndex = '300';
        card.appendChild(tooltip);

        if (imageUrl !== 'https://via.placeholder.com/150') {
            const downloadButton = document.createElement('button');
            downloadButton.className = 'download-nft-btn';
            downloadButton.title = 'Download NFT';
            downloadButton.style.zIndex = '100';
            downloadButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="#000000" class="size-4">
                    <path d="M8.75 2.75a.75.75 0 0 0-1.5 0v5.69L5.03 6.22a.75.75 0 0 0-1.06 1.06l3.5 3.5a.75.75 0 0 0 1.06 0l3.5-3.5a.75.75 0 0 0-1.06-1.06L8.75 8.44V2.75Z" />
                    <path d="M3.5 9.75a.75.75 0 0 0-1.5 0v1.5A2.75 2.75 0 0 0 4.75 14h6.5A2.75 2.75 0 0 0 14 11.25v-1.5a.75.75 0 0 0-1.5 0v1.5c0 .69-.56 1.25-1.25 1.25h-6.5c-.69 0-1.25-.56-1.25-1.25v-1.5Z" />
                </svg>
            `;
            downloadButton.onclick = () => downloadSingleNFT(imageUrl, asset.name || `NFT_${index + 1}`, index);
            card.appendChild(downloadButton);
        }

        // Log d√©taill√© pour diagnostiquer pourquoi le bouton Crypto.com n'appara√Æt pas
        console.log(`Attempting to create Crypto.com button for asset ${index + 1}:`, {
            assetId: asset.id,
            collectionId: asset.collection?.id,
            collectionName: asset.collection?.name,
            assetName: asset.name
        });

        // Ajout du bouton Crypto.com avec URL au format demand√©
        if (asset.id) {
            const cryptoButton = document.createElement('a');
            cryptoButton.className = 'crypto-nft-btn';
            cryptoButton.title = 'View on Crypto.com';
            let searchParam = '';
            if (asset.name && asset.name.trim() !== '') {
                searchParam = `&search=${encodeURIComponent(asset.name.trim())}`;
            }
            // Utiliser l'URL compl√®te si collection.id est disponible, sinon une URL de secours
            cryptoButton.href = asset.collection?.id
                ? `https://crypto.com/nft/collection/${asset.collection.id}?tab=items${searchParam}&asset=${asset.id}`
                : `https://crypto.com/nft/profile/${currentUsername || 'unknown'}`;
            cryptoButton.target = '_blank';
            cryptoButton.setAttribute('aria-label', 'View NFT on Crypto.com');
            cryptoButton.style.zIndex = '100';
            cryptoButton.innerHTML = `
    	    	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="#000000">
        		<path fill-rule="evenodd" d="M8.914 6.025a.75.75 0 0 1 1.06 0 3.5 3.5 0 0 1 0 4.95l-2 2a3.5 3.5 0 0 1-5.396-4.402.75.75 0 0 1 1.251.827 2 2 0 0 0 3.085 2.514l2-2a2 2 0 0 0 0-2.828.75.75 0 0 1 0-1.06Z" clip-rule="evenodd" />
        		<path fill-rule="evenodd" d="M7.086 9.975a.75.75 0 0 1-1.06 0 3.5 3.5 0 0 1 0-4.95l2-2a3.5 3.5 0 0 1 5.396 4.402.75.75 0 0 1-1.251-.827 2 2 0 0 0-3.085-2.514l-2 2a2 2 0 0 0 0 2.828.75.75 0 0 1 0 1.06Z" clip-rule="evenodd" />
   		</svg>
	    `;
            cryptoButton.addEventListener('click', (e) => {
                e.stopPropagation();
                console.log(`Crypto.com button clicked for asset ${index + 1}:`, { href: cryptoButton.href });
            });
            card.appendChild(cryptoButton);
            console.log(`Crypto.com button created successfully for asset ${index + 1}:`, {
                href: cryptoButton.href
            });
        } else {
            console.warn(`Cannot add Crypto.com button: missing asset ID`, {
                assetId: asset.id,
                collectionId: asset.collection?.id,
                collectionName: asset.collection?.name,
                assetName: asset.name
            });
        }

        card.appendChild(mediaElement);
        container.appendChild(card);
    });

    updateDisplay();
}

async function fetchWithRetry(url, retries = 3, delay = 1000) {
    for (let i = 0; i < retries; i++) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // Timeout de 30s
            const response = await fetch(url, {
                method: 'GET',
                mode: 'cors',
                cache: 'no-cache',
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            if (!response.ok) {
                if (response.status === 429 && i < retries - 1) {
                    console.log(`Rate limit hit for ${url}, retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                    continue;
                }
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }
            return response;
        } catch (error) {
            if (i === retries - 1) throw error;
        }
    }
}

async function downloadSingleNFT(url, name, index) {
    const errorDiv = document.getElementById('error');
    if (!errorDiv) {
        console.error('Error div not found');
        return;
    }

    try {
        const response = await fetchWithRetry(url, 3, 2000);
        if (!response.ok) {
            throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
        }
        const contentType = response.headers.get('content-type');
        let extension = 'png';
        if (contentType.includes('video/mp4')) {
            extension = 'mp4';
        } else if (contentType.includes('image/jpeg')) {
            extension = 'jpg';
        } else if (contentType.includes('image/gif')) {
            extension = 'gif';
        } else if (!contentType.includes('image/png')) {
            throw new Error(`Unsupported file type: ${contentType}`);
        }
        const blob = await response.blob();
        if (!blob || blob.size === 0) {
            throw new Error('Received empty or invalid blob');
        }
        console.log(`Downloading ${name}: URL=${url}, Content-Type=${contentType}, Status=${response.status}`);
        const sanitizedName = sanitizeFileNameForZip(name, index);
        const fileName = `${sanitizedName}.${extension}`;
        const urlObj = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = urlObj;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(urlObj);
    } catch (error) {
        console.error(`Error downloading NFT ${name}: ${error.message}`);
        errorDiv.textContent = `Failed to download ${name}: ${error.message}`;
        setTimeout(() => errorDiv.textContent = '', 5000);
    }
}

async function downloadNFTsAsZip() {
    const zip = new JSZip();
    const nftContainer = document.getElementById('nftContainer');
    const errorDiv = document.getElementById('error');
    const progressModal = document.getElementById('progressModal');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const modalTitle = document.getElementById('modalTitle');
    const cancelButton = document.getElementById('cancelDownloadButton');

    if (!nftContainer || !errorDiv || !progressModal || !progressBar || !progressText || !modalTitle || !cancelButton) {
        console.error('Required DOM elements for download not found');
        if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
        return;
    }

    const filteredNFTs = Array.from(nftContainer.querySelectorAll('.nft-card')).map((card, index) => {
        const img = card.querySelector('img');
        const video = card.querySelector('video');
        const titleElement = card.querySelector('h3') || card.querySelector('.tooltip');
        const title = titleElement ? titleElement.textContent : `NFT_${index + 1}`;
        return {
            url: img ? img.src : video ? video.src : null,
            name: title,
        };
    }).filter(nft => nft.url && nft.url !== 'https://via.placeholder.com/150');

    if (filteredNFTs.length === 0) {
        errorDiv.textContent = 'No valid assets to download.';
        return;
    }

    modalTitle.textContent = 'Creating ZIP File';
    progressText.textContent = `Preparing ${filteredNFTs.length} assets`;
    progressBar.style.width = '0%';
    progressModal.style.display = 'flex';
    cancelButton.style.display = 'block';

    isDownloadCancelled = false;
    cancelButton.onclick = () => {
        isDownloadCancelled = true;
        progressText.textContent = 'Download cancelled.';
        progressBar.style.width = '0%';
        setTimeout(() => {
            progressModal.style.display = 'none';
        }, 1000);
    };

    let processed = 0;
    for (const [index, nft] of filteredNFTs.entries()) {
        if (isDownloadCancelled) {
            console.log('Download cancelled by user');
            return;
        }

        try {
            const response = await fetch(nft.url);
            if (!response.ok) {
                console.error(`Failed to fetch asset ${nft.name}: ${response.statusText}`);
                continue;
            }
            const blob = await response.blob();
            const extension = nft.url.endsWith('.mp4') ? 'mp4' : 'png';
            const sanitizedName = sanitizeFileNameForZip(nft.name);
            const fileName = `${sanitizedName}.${extension}`;
            zip.file(fileName, blob);
            processed++;
            const progressPercent = (processed / filteredNFTs.length) * 100;
            progressBar.style.width = `${progressPercent}%`;
            progressText.textContent = `Downloading: ${processed}/${filteredNFTs.length}`;
        } catch (error) {
            console.error(`Error downloading ${nft.name}: ${error.message}`);
        }
    }

    if (isDownloadCancelled) {
        console.log('Download process aborted');
        return;
    }

    if (processed === 0) {
        progressModal.style.display = 'none';
        errorDiv.textContent = 'No assets could be downloaded';
        return;
    }

    progressText.textContent = 'Generating ZIP file';
    try {
        const content = await zip.generateAsync({ type: 'blob' });
        saveAs(content, `${currentUsername}_nfts.zip`);
        progressText.textContent = 'Download complete!';
        progressBar.style.width = '100%';
        setTimeout(() => {
            progressModal.style.display = 'none';
        }, 1000);
    } catch (error) {
        console.error(`Error generating ZIP: ${error.message}`);
        progressModal.style.display = 'none';
        errorDiv.textContent = 'Failed to generate ZIP file';
    }
}

async function downloadCollage() {
    const nftContainer = document.getElementById('nftContainer');
    const errorDiv = document.getElementById('error');
    const progressModal = document.getElementById('progressModal');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const modalTitle = document.getElementById('modalTitle');
    const cancelButton = document.getElementById('cancelDownloadButton');
    const profilePicture = document.getElementById('profilePicture');
    const collectionFilter = document.getElementById('collectionFilter');
    const collectionTitle = document.getElementById('collectionTitle');

    if (!nftContainer || !errorDiv || !progressModal || !progressBar || !progressText || !modalTitle || !cancelButton || !profilePicture || !collectionFilter || !collectionTitle) {
        console.error('Required DOM elements for collage download not found');
        if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
        return;
    }

    if (window.isDownloading) {
        console.warn('Download already in progress, please wait.');
        return;
    }

    window.isDownloading = true;

    const cards = Array.from(nftContainer.querySelectorAll('.nft-card:not(.empty)'));
    if (cards.length === 0) {
        errorDiv.textContent = 'No assets to include in the collage.';
        window.isDownloading = false;
        return;
    }

    const validCards = cards
        .map((card, index) => {
            const img = card.querySelector('img');
            const video = card.querySelector('video');
            const mediaUrl = img ? img.src : video ? video.currentSrc : null;
            const mediaElement = img || video;
            const titleElement = card.querySelector('.tooltip');
            const title = titleElement ? titleElement.textContent : `NFT_${index + 1}`;
            return { mediaUrl, mediaElement, title, index };
        })
        .filter(({ mediaUrl }) => mediaUrl && mediaUrl !== 'https://via.placeholder.com/150' && !mediaUrl.endsWith('.mp4'));

    if (validCards.length === 0) {
        errorDiv.textContent = 'No valid image assets to include in the collage.';
        window.isDownloading = false;
        return;
    }

    modalTitle.textContent = 'Creating Collage';
    progressText.textContent = `Preparing collage with ${validCards.length} assets`;
    progressBar.style.width = '0%';
    progressModal.style.display = 'flex';
    cancelButton.style.display = 'block';

    window.isDownloadCancelled = false;
    cancelButton.onclick = () => {
        window.isDownloadCancelled = true;
        progressText.textContent = 'Collage creation cancelled.';
        progressBar.style.width = '0%';
        setTimeout(() => {
            progressModal.style.display = 'none';
            window.isDownloading = false;
        }, 1000);
    };

    try {
        console.log('Starting collage creation with', validCards.length, 'assets');

        const numCards = validCards.length;
        let cols = Math.ceil(Math.sqrt(numCards));
        let rows = Math.ceil(numCards / cols);
        if (numCards > 1) {
            while (rows * (cols - 1) >= numCards && cols > 1) {
                cols--;
                rows = Math.ceil(numCards / cols);
            }
        }
        const cardSize = 300;
        const gridWidth = cols * cardSize;
        const gridHeight = rows * cardSize;

        // Ajuster dynamiquement les tailles
        const headerHeight = Math.min(Math.max(Math.round(gridWidth * 0.1), 80), 150);
        const footerHeight = headerHeight;
        const fontSize = Math.min(Math.max(Math.round(gridWidth / 20), 20), 40);
        const imageSize = Math.min(Math.max(Math.round(headerHeight * 0.7), 50), 100);
        const margin = Math.min(Math.max(Math.round(gridWidth / 50), 10), 30);

        const canvas = document.createElement('canvas');
        canvas.width = gridWidth;
        canvas.height = gridHeight + headerHeight + footerHeight;
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // --- Ajouter l'en-t√™te ---
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, canvas.width, headerHeight);

        let profileImage = null;
        const profileImageUrl = profilePicture.src || loggedInUser?.avatar || '';
        if (profileImageUrl && profileImageUrl !== 'https://via.placeholder.com/150') {
            try {
                const response = await fetch(profileImageUrl, { cache: 'force-cache', mode: 'cors' });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const blob = await response.blob();
                profileImage = await createImageBitmap(blob);
            } catch (error) {
                console.warn(`Failed to load profile image: ${error.message}`);
            }
        }

        const profileImageX = margin;
        const profileImageY = (headerHeight - imageSize) / 2;
        if (profileImage) {
            ctx.drawImage(profileImage, profileImageX, profileImageY, imageSize, imageSize);
            profileImage.close();
        } else {
            ctx.fillStyle = '#555';
            ctx.fillRect(profileImageX, profileImageY, imageSize, imageSize);
            ctx.fillStyle = '#fff';
            ctx.font = '12px Geomanist-Bold';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('No Image', profileImageX + imageSize / 2, profileImageY + imageSize / 2);
        }

        const usernameText = currentUsername.toUpperCase() || 'UNKNOWN';
        let collectionText = collectionTitle.textContent || collectionFilter.value || 'ALL_COLLECTIONS';
        let adjustedFontSize = fontSize;
        ctx.font = `${adjustedFontSize}px Geomanist-Bold`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        const usernameX = profileImageX + imageSize + margin;
        const usernameY = profileImageY + imageSize / 2;

        const maxTextWidth = canvas.width - (profileImageX + imageSize + margin * 2) - 100;
        let combinedText = `${usernameText} / ${collectionText.toUpperCase()}`;
        while (ctx.measureText(combinedText).width > maxTextWidth && adjustedFontSize > 16) {
            adjustedFontSize -= 2;
            ctx.font = `${adjustedFontSize}px Geomanist-Bold`;
        }
        if (ctx.measureText(combinedText).width > maxTextWidth) {
            let truncatedCollection = collectionText.toUpperCase();
            while (ctx.measureText(`${usernameText} / ${truncatedCollection}...`).width > maxTextWidth && truncatedCollection.length > 0) {
                truncatedCollection = truncatedCollection.slice(0, -1);
            }
            collectionText = truncatedCollection + (truncatedCollection.length < collectionText.length ? '...' : '');
        }

        const theme = document.documentElement.getAttribute('data-theme') || 'dark';
        const color1 = theme === 'cdc' ? '#11bafa' : '#FF5733';
        ctx.fillStyle = color1;
        ctx.fillText(usernameText, usernameX, usernameY);

        const usernameWidth = ctx.measureText(usernameText).width;
        ctx.fillStyle = '#fff';
        const separator = ' / ';
        const separatorX = usernameX + usernameWidth;
        ctx.fillText(separator, separatorX, usernameY);
        const separatorWidth = ctx.measureText(separator).width;

        const collectionX = separatorX + separatorWidth;
        ctx.fillText(collectionText.toUpperCase(), collectionX, usernameY);

        const nftCountText = `${validCards.length} NFTS`;
        ctx.font = `${adjustedFontSize}px Geomanist-Bold`;
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        const nftCountX = canvas.width - margin;
        const nftCountY = usernameY;
        ctx.fillText(nftCountText, nftCountX, nftCountY);

        // --- Ajouter le pied de page ---
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, canvas.height - footerHeight, canvas.width, footerHeight);

        let logoImage = null;
        const logoUrl = 'https://media.nft.crypto.com/b58c11ef-9874-4157-afff-0bf6b059dce1/original.jpg?d=lg-logo';
        try {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.src = logoUrl;
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = () => reject(new Error(`Failed to load logo: ${logoUrl}`));
            });
            logoImage = await createImageBitmap(img);
        } catch (error) {
            console.error(`Failed to load logo: ${error.message}`);
        }

        // Logo et "CRONOS.WTF" √† gauche
        const logoX = margin;
        const logoY = canvas.height - footerHeight + (footerHeight - imageSize) / 2;
        if (logoImage) {
            ctx.drawImage(logoImage, logoX, logoY, imageSize, imageSize);
            logoImage.close();
        } else {
            ctx.fillStyle = '#555';
            ctx.fillRect(logoX, logoY, imageSize, imageSize);
            ctx.fillStyle = '#fff';
            ctx.font = '12px Geomanist-Bold';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('No Logo', logoX + imageSize / 2, logoY + imageSize / 2);
        }

        const cronosText = 'CRONOS.WTF';
        ctx.font = `${adjustedFontSize}px Geomanist-Bold`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        const cronosTextX = logoX + imageSize + margin;
        const textY = canvas.height - footerHeight / 2;
        ctx.fillStyle = '#fff';
        ctx.fillText(cronosText, cronosTextX, textY);

        // "DEVELOPED BY UNSCOOP" √† droite
        const devText = 'DEVELOPED BY ';
        const unscoopText = 'UNSCOOP';
        const devTextWidth = ctx.measureText(devText).width;
        const unscoopTextWidth = ctx.measureText(unscoopText).width;
        const totalDevTextWidth = devTextWidth + unscoopTextWidth;
        const devTextX = canvas.width - margin - totalDevTextWidth;
        ctx.fillStyle = '#fff';
        ctx.fillText(devText, devTextX, textY);
        ctx.fillStyle = color1;
        ctx.fillText(unscoopText, devTextX + devTextWidth, textY);

        // --- Dessiner les images du collage ---
        let processed = 0;
        const failedImages = [];

        const loadImageFromUrl = async (mediaUrl, title, index) => {
            try {
                const headResponse = await fetch(mediaUrl, { method: 'HEAD', mode: 'cors' });
                if (!headResponse.ok) {
                    throw new Error(`HEAD request failed: HTTP ${headResponse.status}`);
                }
                const contentType = headResponse.headers.get('content-type');
                if (!contentType?.includes('image/')) {
                    throw new Error(`Invalid content type: ${contentType}`);
                }

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);
                const response = await fetch(mediaUrl + (mediaUrl.includes('?') ? '&' : '?') + 'quality=high', {
                    signal: controller.signal,
                    mode: 'cors',
                    cache: 'no-cache'
                });
                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
                }

                const blob = await response.blob();
                if (!blob || blob.size === 0) {
                    throw new Error('Received empty or invalid blob');
                }

                const blobContentType = blob.type;
                if (!blobContentType.includes('image/')) {
                    throw new Error(`Unsupported blob content type: ${blobContentType}`);
                }

                return await createImageBitmap(blob);
            } catch (error) {
                console.error(`Failed to load image ${title} (index ${index}, URL: ${mediaUrl}): ${error.message}`);
                failedImages.push({ title, index, url: mediaUrl, error: error.message });
                return null;
            }
        };

        const loadImageFromDOM = async (mediaElement, title, index) => {
            try {
                if (mediaElement.tagName.toLowerCase() !== 'img') {
                    throw new Error('Media element is not an image');
                }
                if (!mediaElement.complete || mediaElement.naturalWidth === 0) {
                    throw new Error('Image not fully loaded or invalid');
                }
                return await createImageBitmap(mediaElement);
            } catch (error) {
                console.error(`Failed to load DOM image ${title} (index ${index}, src: ${mediaElement.src}): ${error.message}`);
                return null;
            }
        };

        for (let i = 0; i < validCards.length; i++) {
            if (window.isDownloadCancelled) {
                console.log('Collage creation cancelled');
                return;
            }

            const { mediaUrl, mediaElement, title, index } = validCards[i];
            const row = Math.floor(i / cols);
            const col = i % cols;
            const x = col * cardSize;
            const y = row * cardSize + headerHeight;

            let imageBitmap = await loadImageFromUrl(mediaUrl, title, index);
            if (!imageBitmap) {
                console.log(`Falling back to DOM for ${title} (index ${index})`);
                imageBitmap = await loadImageFromDOM(mediaElement, title, index);
            }

            if (imageBitmap) {
                ctx.drawImage(imageBitmap, x, y, cardSize, cardSize);
                imageBitmap.close();
            } else {
                ctx.fillStyle = '#555';
                ctx.fillRect(x, y, cardSize, cardSize);
                ctx.fillStyle = '#fff';
                ctx.font = '16px Geomanist-Bold';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Image Failed', x + cardSize / 2, y + cardSize / 2);
            }

            processed++;
            const progressPercent = (processed / validCards.length) * 100;
            progressBar.style.width = `${progressPercent}%`;
            progressText.textContent = `Processing: ${processed}/${validCards.length}`;
        }

        if (window.isDownloadCancelled) {
            console.log('Collage creation aborted');
            return;
        }

        if (processed === 0) {
            progressModal.style.display = 'none';
            errorDiv.textContent = 'No valid assets could be included in the collage.';
            return;
        }

        if (failedImages.length > 0) {
            console.warn(`${failedImages.length} images failed to load via URL, ${validCards.length - failedImages.length} loaded successfully:`, failedImages);
            errorDiv.textContent = `${failedImages.length} image(s) failed to load via URL. ${validCards.length - failedImages.length} loaded successfully.`;
            setTimeout(() => (errorDiv.textContent = ''), 5000);
        }

        progressText.textContent = 'Generating collage image';
        console.log('Generating blob for download');
        try {
            canvas.toBlob(
                (blob) => {
                    try {
                        if (!blob) {
                            throw new Error('Failed to generate blob');
                        }
                        if (window.isDownloadCancelled) {
                            console.log('Download cancelled before blob generation');
                            return;
                        }

                        console.log('Blob generated, initiating download');
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;

                        const cleanUsername = (currentUsername || 'unknown').replace(/[^a-zA-Z0-9-_]/g, '');
                        const capitalizedUsername = cleanUsername.charAt(0).toUpperCase() + cleanUsername.slice(1);
                        const cleanCollectionText = (collectionText || 'all_collections').replace(/[^a-zA-Z0-9-_]/g, '');
                        a.download = `${capitalizedUsername}_${cleanCollectionText}.png`;

                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        progressText.textContent = 'Collage download complete!';
                        progressBar.style.width = '100%';
                        setTimeout(() => {
                            progressModal.style.display = 'none';
                        }, 1500);
                    } catch (error) {
                        console.error(`Error during download: ${error.message}`);
                        errorDiv.textContent = `Failed to initiate download: ${error.message}`;
                        setTimeout(() => (errorDiv.textContent = ''), 5000);
                    }
                },
                'image/png',
                1.0
            );
        } catch (error) {
            console.error(`toBlob error: ${error.message}`);
            if (error.message.includes('Tainted canvases may not be exported')) {
                errorDiv.textContent = 'Failed to generate collage: Images from external sources cannot be exported due to security restrictions. Try downloading individual assets.';
            } else {
                errorDiv.textContent = `Failed to generate collage image: ${error.message}`;
            }
            setTimeout(() => (errorDiv.textContent = ''), 5000);
        }
    } catch (error) {
        console.error(`Error generating collage: ${error.message}`);
        progressModal.style.display = 'none';
        errorDiv.textContent = `Failed to generate collage: ${error.message}`;
        setTimeout(() => (errorDiv.textContent = ''), 5000);
    } finally {
        console.log('Collage creation completed, resetting download state');
        window.isDownloading = false;
    }
}

function updateDisplay() {
    const cardSize = document.getElementById('cardSize')?.value || 'small';
    const nftContainer = document.getElementById('nftContainer');

    if (!nftContainer) {
        console.error('Conteneur NFT non trouv√©');
        return;
    }

    nftContainer.className = `nft-container thumbnail-mode ${cardSize}-size`;

    // Ignorer les ajustements dynamiques sur mobile (‚â§ 768px)
    if (window.innerWidth <= 768) {
        nftContainer.style.gridTemplateColumns = ''; // Supprimer tout style inline
        console.log('Mobile view: Using CSS grid-template-columns for', cardSize);
        return;
    }

    // Calculs pour √©crans > 768px (PC)
    const baseCardWidth = cardSize === 'small' ? 110 : cardSize === 'medium' ? 180 : 280;
    const gap = 4; // √âcart fixe de 4px

    // Marges fixes de nftContainer (50px √† gauche, 50px √† droite)
    const marginLeft = 50;
    const marginRight = 50;
    const totalMargin = marginLeft + marginRight;

    // Calculer la largeur disponible
    const availableWidth = document.documentElement.clientWidth - totalMargin;

    // Calculer le nombre de colonnes
    const columnWidthWithGap = baseCardWidth + gap;
    let numColumns = Math.floor((availableWidth + gap) / columnWidthWithGap);
    numColumns = Math.max(1, numColumns); // Minimum 1 colonne

    // Calculer la largeur ajust√©e des colonnes
    const totalGaps = (numColumns - 1) * gap;
    let adjustedColumnWidth = (availableWidth - totalGaps) / numColumns;

    // Appliquer des contraintes de taille minimale/maximale
    const minWidth = baseCardWidth * 0.8; // 80% de la taille de base
    let maxWidth = baseCardWidth * 1.2; // 120% de la taille de base
    if (cardSize === 'large') {
        maxWidth = baseCardWidth * 1.5; // Assouplir pour mode large
    }
    adjustedColumnWidth = Math.min(Math.max(adjustedColumnWidth, minWidth), maxWidth);

    // R√©ajuster si la largeur totale d√©passe availableWidth
    let totalWidthWithAdjusted = numColumns * adjustedColumnWidth + totalGaps;
    if (totalWidthWithAdjusted > availableWidth) {
        numColumns = Math.max(1, numColumns - 1);
        const newTotalGaps = (numColumns - 1) * gap;
        adjustedColumnWidth = (availableWidth - newTotalGaps) / numColumns;
        adjustedColumnWidth = Math.min(Math.max(adjustedColumnWidth, minWidth), maxWidth);
        totalWidthWithAdjusted = numColumns * adjustedColumnWidth + newTotalGaps;
    }

    // Maximiser l'espace en mode "large"
    if (cardSize === 'large' && totalWidthWithAdjusted < availableWidth * 0.95) {
        adjustedColumnWidth = (availableWidth - totalGaps) / numColumns;
        adjustedColumnWidth = Math.min(Math.max(adjustedColumnWidth, minWidth), maxWidth);
    }

    // Appliquer la grille
    nftContainer.style.gridTemplateColumns = `repeat(${numColumns}, ${adjustedColumnWidth}px)`;

    // V√©rifier les d√©bordements
    const containerRect = nftContainer.getBoundingClientRect();
    const windowRightEdge = document.documentElement.clientWidth - marginRight;
    if (containerRect.right > windowRightEdge + 1) {
        console.warn(`D√©bordement d√©tect√©: container.right=${containerRect.right}px, windowRightEdge=${windowRightEdge}px`);
        numColumns = Math.max(1, numColumns - 1);
        const newTotalGaps = (numColumns - 1) * gap;
        adjustedColumnWidth = (availableWidth - newTotalGaps) / numColumns;
        adjustedColumnWidth = Math.min(Math.max(adjustedColumnWidth, minWidth), maxWidth);
        nftContainer.style.gridTemplateColumns = `repeat(${numColumns}, ${adjustedColumnWidth}px)`;
    }

    // Forcer un recalcul du layout
    nftContainer.style.display = 'none';
    nftContainer.offsetHeight; // Forcer un reflow
    nftContainer.style.display = 'grid';

    console.log(`updateDisplay (PC): clientWidth=${document.documentElement.clientWidth}px, marginLeft=${marginLeft}px, marginRight=${marginRight}px, availableWidth=${availableWidth}px, numColumns=${numColumns}, adjustedColumnWidth=${adjustedColumnWidth}px, container.right=${nftContainer.getBoundingClientRect().right}px, expectedRightEdge=${windowRightEdge}px`);
}

function setupEventListeners() {
    const usernameInput = document.getElementById('usernameInput');
    const loginUsernameInput = document.getElementById('loginUsernameInput');
    const themeButton = document.getElementById('themeButton');
    const collectionFilter = document.getElementById('collectionFilter');
    const chainFilter = document.getElementById('chainFilter');
    const curatedFilter = document.getElementById('curatedFilter');
    const cardSize = document.getElementById('cardSize');
    const sortBy = document.getElementById('sortBy');
    const navbarMenu = document.getElementById('navbarMenu');
    const cancelLoginButton = document.getElementById('cancelLoginButton');
    const myProfileLink = document.getElementById('myProfileLink');
    const logoutLink = document.getElementById('logoutLink');
    const loginLink = document.getElementById('loginLink');
    const scrollToTopButton = document.getElementById('scrollToTopButton');
    const scrollToBottomButton = document.getElementById('scrollToBottomButton');
    const navbarToggle = document.querySelector('.navbar-toggle');
    const downloadZipButton = document.getElementById('downloadZipButton');
    const downloadCollageButton = document.getElementById('downloadCollageButton');

    // V√©rification des √©l√©ments DOM critiques
    if (!usernameInput || !loginUsernameInput || !themeButton || !collectionFilter || 
        !chainFilter || !curatedFilter || !cardSize || !sortBy || !navbarMenu || 
        !cancelLoginButton || !myProfileLink || !logoutLink || !loginLink || !navbarToggle || 
        !downloadZipButton || !downloadCollageButton) {
        console.error('One or more DOM elements not found', {
            usernameInput: !!usernameInput,
            loginUsernameInput: !!loginUsernameInput,
            themeButton: !!themeButton,
            collectionFilter: !!collectionFilter,
            chainFilter: !!chainFilter,
            curatedFilter: !!curatedFilter,
            cardSize: !!cardSize,
            sortBy: !!sortBy,
            navbarMenu: !!navbarMenu,
            cancelLoginButton: !!cancelLoginButton,
            myProfileLink: !!myProfileLink,
            logoutLink: !!logoutLink,
            loginLink: !!loginLink,
            navbarToggle: !!navbarToggle,
            downloadZipButton: !!downloadZipButton,
            downloadCollageButton: !!downloadCollageButton
        });
        const errorDiv = document.getElementById('error');
        if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
        return;
    }

    // V√©rification sp√©cifique pour les boutons de d√©filement
    if (!scrollToTopButton || !scrollToBottomButton) {
        console.warn('Scroll buttons not found in DOM', {
            scrollToTopButton: !!scrollToTopButton,
            scrollToBottomButton: !!scrollToBottomButton
        });
    }

    // Gestion du basculement du th√®me
    themeButton.addEventListener('click', toggleTheme);
    console.log('Theme button listener attached');

    // Gestion du menu mobile (bouton hamburger)
    console.log('Attaching listeners to navbar toggle');
    navbarToggle.addEventListener('click', (e) => {
        console.log('Click event on navbar toggle');
        toggleMenu(e);
    });
    navbarToggle.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Emp√™cher le double d√©clenchement ou le zoom
        console.log('Touchstart event on navbar toggle');
        toggleMenu(e);
    }, { passive: false });

    // Gestion de la recherche principale
    usernameInput.addEventListener('input', debounce(async (e) => {
        const query = sanitizeInput(e.target.value);
        if (query.length > 2) {
            await searchProfiles(query);
        } else {
            clearSuggestions();
        }
    }, 300));
    console.log('Main search input listener attached');

    // R√©activer les suggestions sur focus si texte pr√©sent
    usernameInput.addEventListener('focus', async () => {
        const query = sanitizeInput(usernameInput.value);
        if (query.length > 2) {
            console.log('Search input focused, querying:', query);
            await searchProfiles(query);
        }
    });

    // Gestion de la recherche dans le modal de connexion
    loginUsernameInput.addEventListener('input', debounce(async (e) => {
        const query = sanitizeInput(e.target.value);
        if (query.length > 2) {
            console.log('Login input event:', query);
            await searchLoginProfiles(query);
        } else {
            clearLoginSuggestions();
        }
    }, 300));
    console.log('Login search input listener attached');

    // R√©activer les suggestions sur focus si texte pr√©sent dans le modal
    loginUsernameInput.addEventListener('focus', async () => {
        const query = sanitizeInput(loginUsernameInput.value);
        if (query.length > 2) {
            console.log('Login input focused, querying:', query);
            await searchLoginProfiles(query);
        }
    });

    // Gestion des clics pour les suggestions, les clics en dehors et la fermeture du menu
    document.addEventListener('click', (e) => {
        const suggestions = document.getElementById('suggestions');
        const loginSuggestions = document.getElementById('loginSuggestions');
        const availableFeaturesModal = document.getElementById('availableFeaturesModal');
        const inProgressModal = document.getElementById('inProgressModal');

        // V√©rifier si le clic est sur une suggestion
        if (e.target.classList.contains('suggestion-item') || e.target.closest('.suggestion-item')) {
            const suggestionItem = e.target.closest('.suggestion-item');
            const username = suggestionItem.dataset.username;
            const avatar = suggestionItem.dataset.avatar;
            const isLoginModal = suggestionItem.closest('#loginModal');
            console.log('Suggestion clicked:', { username, isLoginModal });
            if (isLoginModal) {
                selectLoginSuggestion(username, avatar);
            } else {
                selectSuggestion(username);
            }
            return;
        }

        // V√©rifier si le clic est dans une modale de mise √† jour
        const isUpdateModalClick = (availableFeaturesModal && availableFeaturesModal.contains(e.target)) ||
                                  (inProgressModal && inProgressModal.contains(e.target));

        // V√©rifier si le clic est en dehors de la barre de recherche et des suggestions
        const isMainSearchClick = usernameInput.contains(e.target);
        const isMainSuggestionsClick = suggestions && suggestions.contains(e.target);
        const isLoginSearchClick = loginUsernameInput.contains(e.target);
        const isLoginSuggestionsClick = loginSuggestions && loginSuggestions.contains(e.target);

        if (!isMainSearchClick && !isMainSuggestionsClick && !isUpdateModalClick) {
            clearSuggestions();
        }

        if (!isLoginSearchClick && !isLoginSuggestionsClick && !isUpdateModalClick) {
            clearLoginSuggestions();
        }

        // Fermer le menu si le clic est en dehors du menu et du bouton de bascule
        const isMenuClick = navbarMenu.contains(e.target);
        const isToggleClick = navbarToggle.contains(e.target);
        if (!isMenuClick && !isToggleClick && navbarMenu.classList.contains('active')) {
            console.log('Click outside menu, closing navbar');
            toggleMenu(e);
        }
    });
    console.log('Document click listener for suggestions and menu close attached');

    // Gestion des filtres
    collectionFilter.addEventListener('change', filterNFTs);
    chainFilter.addEventListener('change', filterNFTs);
    curatedFilter.addEventListener('change', filterNFTs);
    cardSize.addEventListener('change', updateDisplay);
    sortBy.addEventListener('change', filterNFTs);
    console.log('Filter listeners attached');

    // Gestion du modal de connexion
    loginLink.addEventListener('click', (e) => {
        showLoginModal(e);
        // Fermer le menu apr√®s avoir cliqu√© sur "Login"
        if (navbarMenu.classList.contains('active')) {
            console.log('Login clicked, closing navbar');
            toggleMenu(e);
        }
    });
    console.log('Login link listener attached');

    cancelLoginButton.addEventListener('click', resetLoginForm);
    console.log('Cancel login button listener attached');

    // Gestion du profil et d√©connexion
    myProfileLink.addEventListener('click', (e) => {
        e.preventDefault();
        if (loggedInUser?.username) {
            console.log('My Profile clicked, fetching for:', loggedInUser.username);
            fetchProfileAndNFTsForLogin(loggedInUser.username);
            // Fermer le menu apr√®s avoir cliqu√© sur "My Profile"
            if (navbarMenu.classList.contains('active')) {
                console.log('My Profile clicked, closing navbar');
                toggleMenu(e);
            }
        }
    });
    console.log('My profile link listener attached');

    logoutLink.addEventListener('click', (e) => {
        logout(e);
        // Fermer le menu apr√®s avoir cliqu√© sur "Logout"
        if (navbarMenu.classList.contains('active')) {
            console.log('Logout clicked, closing navbar');
            toggleMenu(e);
        }
    });
    console.log('Logout link listener attached');

    // Gestion des boutons de t√©l√©chargement
downloadZipButton.removeEventListener('click', downloadNFTsAsZip);
downloadZipButton.addEventListener('click', downloadNFTsAsZip);
downloadCollageButton.removeEventListener('click', downloadCollage);
downloadCollageButton.addEventListener('click', downloadCollage);
    console.log('Download buttons listeners attached');

    // Gestion des boutons de d√©filement
    const toggleScrollButtons = () => {
        const scrollY = window.scrollY;
        const windowHeight = window.innerHeight;
        const documentHeight = document.documentElement.scrollHeight;
        const isScrollable = documentHeight > windowHeight + 100;

        const showTopButton = isScrollable && scrollY > 200;
        scrollToTopButton.style.display = showTopButton ? 'block' : 'none';
        scrollToTopButton.classList.toggle('visible', showTopButton);

        const isAtBottom = scrollY + windowHeight >= documentHeight - 10;
        const showBottomButton = isScrollable && !isAtBottom;
        scrollToBottomButton.style.display = showBottomButton ? 'block' : 'none';
        scrollToBottomButton.classList.toggle('visible', showBottomButton);

        console.log('toggleScrollButtons:', {
            scrollY,
            windowHeight,
            documentHeight,
            isScrollable,
            showTopButton,
            showBottomButton
        });
    };

    window.addEventListener('scroll', toggleScrollButtons);
    window.addEventListener('resize', toggleScrollButtons);

    const observer = new MutationObserver(toggleScrollButtons);
    observer.observe(document.body, { childList: true, subtree: true });

    scrollToTopButton.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
        console.log('Scroll to top clicked');
    });

    scrollToBottomButton.addEventListener('click', () => {
        window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'smooth' });
        console.log('Scroll to bottom clicked');
    });

    toggleScrollButtons();
    console.log('Scroll buttons listeners and observer attached');
}

function initialize() {
    const savedTheme = localStorage.getItem('theme') || 'dark';
    const initialTheme = savedTheme === 'light' ? 'cdc' : savedTheme;
    document.documentElement.setAttribute('data-theme', initialTheme);
    const themeButton = document.getElementById('themeButton');
    if (themeButton) {
        themeButton.textContent = initialTheme === 'dark' ? 'CDC' : 'Dark';
    }

    const savedUser = localStorage.getItem('loggedInUser');
    if (savedUser) {
        try {
            loggedInUser = JSON.parse(savedUser);
            updateLoginLink();
        } catch (error) {
            console.error('Error parsing saved user:', error);
            localStorage.removeItem('loggedInUser');
        }
    }

    resetSearchBar(); // R√©initialiser la barre de recherche au chargement

    // Afficher les fen√™tres des mises √† jour sur la page d'accueil
    const availableFeaturesModal = document.getElementById('availableFeaturesModal');
    const inProgressModal = document.getElementById('inProgressModal');
    const { username, collection } = parseUrlHash();
    if (availableFeaturesModal && inProgressModal && !username) {
        availableFeaturesModal.style.display = 'block';
        inProgressModal.style.display = 'block';
        console.log('Update modals displayed on home page');
    }

    if (username) {
        const usernameInput = document.getElementById('usernameInput');
        if (usernameInput) {
            usernameInput.value = username;
            fetchProfileAndNFTs();
        }
    }

    setupEventListeners();

    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(updateDisplay, 100);
    });

    updateDisplay();

    window.addEventListener('popstate', () => {
        const { username, collection } = parseUrlHash();
        if (username) {
            const usernameInput = document.getElementById('usernameInput');
            if (usernameInput) {
                usernameInput.value = username;
                fetchProfileAndNFTs();
            }
        }
    });
}

document.addEventListener('DOMContentLoaded', initialize);
    </script></body>
</html>
