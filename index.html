<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Browse smarter. Collect better – Developed by Unscoop">
    <title>CRONOS.WTF | Developed by Unscoop</title>
    <link rel="icon" type="image/png" href="icon.png">
    <link rel="preload" href="icon.png" as="image">
    <link rel="preload" href="Geomanist-Bold.otf" as="font" type="font/otf" crossorigin>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
</head>
<body>
    <noscript>
        <div style="text-align: center; padding: 20px; color: var(--text-dark);">
            JavaScript is required to view this content. Please enable JavaScript in your browser settings.
        </div>
    </noscript>
    <nav class="navbar">
        <div class="navbar-logo">
            <img src="CRONOBOTS.png" alt="Cronobots Logo">
            <span class="navbar-logo-text">CRONOS.WTF</span>
        </div>
        <div class="navbar-search">
            <input type="text" id="usernameInput" placeholder="Crypto.com/nft/profile" aria-describedby="usernameHelp" autocomplete="on" />
            <div class="suggestions" id="suggestions"></div>
        </div>
        <div class="navbar-menu" id="navbarMenu">
            <a href="https://cronobots.github.io/Cronos" aria-label="Home">Home</a>
            <a href="" aria-label="Collections">Collections</a>
            <span class="navbar-divider"> | </span>
            <a href="#" id="myProfileLink" style="display: none;" aria-label="My Profile">My Profile</a>
            <a href="#" id="logoutLink" style="display: none;" aria-label="Logout">Logout</a>
            <a href="#" id="loginLink" aria-label="Login">Login</a>
            <div class="user-profile" id="userProfile" style="display: none;">
                <img id="userProfilePicture" src="" alt="User Profile" class="user-profile-picture" />
            </div>
        </div>
        <button class="navbar-toggle" aria-label="Toggle menu" aria-expanded="false" onclick="toggleMenu()">☰</button>
    </nav>

    <div class="main-content">
        <div class="profile-section">
            <div class="profile-header" id="profileHeader" style="display: none;">
                <div class="profile-header-content">
                    <div class="profile-picture">
                        <img id="profilePicture" src="" alt="Profile Picture" />
                        <div class="social-container" style="display: none;" id="socialContainer">
                            <p id="croLink" style="display: none;">
                                <a href="#" target="_blank" id="croUrl" title="Visit Crypto.com/NFT Profile">
                                    <img src="CRO.png" alt="CRO Profile" class="social-icon" onerror="console.error('Failed to load CRO.png'); this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                            <p id="twitterLink" style="display: none;">
                                <a href="#" target="_blank" id="twitterUrl" title="Visit X Profile">
                                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/X_icon_2.svg/512px-X_icon_2.svg.png" alt="X Profile" class="social-icon" onerror="this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                            <p id="facebookLink" style="display: none;">
                                <a href="#" target="_blank" id="facebookUrl" title="Visit Facebook Profile">
                                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Facebook_f_logo_%282019%29.svg/512px-Facebook_f_logo_%282019%29.svg.png" alt="Facebook Profile" class="social-icon" onerror="this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                            <p id="instagramLink" style="display: none;">
                                <a href="#" target="_blank" id="instagramUrl" title="Visit Instagram Profile">
                                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/512px-Instagram_icon.png" alt="Instagram Profile" class="social-icon" onerror="this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                        </div>
                    </div>
                    <div class="profile-info">
                        <div class="username-container">
                            <h2 id="username" class="username"></h2>
                            <img id="verifiedBadge" class="verified-badge" src="https://parspng.com/wp-content/uploads/2022/07/tickpng.parspng.com-4-1024x1024.png" style="display: none;" alt="Verified" onerror="this.src='/assets/fallback-verified.png'" />
                        </div>
                        <p id="displayName" class="display-name"></p>
                    </div>
                </div>
            </div>
            <div class="controls" id="controls">
                <div class="control-group">
                    <label for="collectionFilter">COLLECTION:</label>
                    <select id="collectionFilter" onchange="filterNFTs()" disabled>
                        <option value="">ALL COLLECTIONS</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="chainFilter">CHAINS:</label>
                    <select id="chainFilter" onchange="filterNFTs()">
                        <option value="">ALL</option>
                        <option value="CRONOS">CRONOS</option>
                        <option value="CRONOS_POS">CRONOS POS CHAIN</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="curatedFilter">CURATION:</label>
                    <select id="curatedFilter" onchange="filterNFTs()">
                        <option value="">ALL</option>
                        <option value="true">CURATED</option>
                        <option value="false">NON CURATED</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="displayMode">DISPLAY MODE:</label>
                    <select id="displayMode" onchange="updateDisplay()">
                        <option value="thumbnail" selected>THUMBNAIL</option>
                        <option value="full">CARD</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="cardSize">CARD SIZE:</label>
                    <select id="cardSize" onchange="updateDisplay()">
                        <option value="small" selected>SMALL</option>
                        <option value="medium">MEDIUM</option>
                        <option value="large">LARGE</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="sortBy">SORT BY:</label>
                    <select id="sortBy" onchange="filterNFTs()">
                        <option value="newest" selected>NEWEST</option>
                        <option value="oldest">OLDEST</option>
                        <option value="rank">RANK</option>
                    </select>
                </div>
            </div>
            <h2 id="collectionTitle" class="collection-title"></h2>
        </div>

        <div class="timestamp" id="timestamp"></div>
        <div class="error" id="error" role="alert"></div>
        <div class="no-results" id="noResults" style="display: none;">No results found</div>
        <div id="nftCountContainer"></div>
        <div class="nft-container" id="nftContainer"></div>
        <div class="download-buttons">
            <button id="downloadZipButton" style="display: none;" onclick="downloadNFTsAsZip()">DOWNLOAD ASSETS</button>
            <button id="downloadCollageButton" style="display: none;" onclick="downloadCollage()">DOWNLOAD COLLAGE</button>
        </div>

        <div class="modal" id="progressModal">
            <div class="modal-content">
                <h3 id="modalTitle">Creating ZIP File</h3>
                <div class="progress-bar">
                    <div class="progress" id="progressBar"></div>
                </div>
                <p class="progress-text" id="progressText">Preparing</p>
                <div class="modal-buttons">
                    <button id="cancelDownloadButton" class="cancel-button">Cancel</button>
                </div>
            </div>
        </div>

        <div class="modal" id="loginModal">
            <div class="modal-content">
                <h3>Enter your Crypto.com/NFT Profile</h3>
                <div class="navbar-search" id="loginSearchContainer">
                    <input type="text" id="loginUsernameInput" placeholder="Crypto.com/nft/profile" autocomplete="on" />
                    <div class="suggestions" id="loginSuggestions"></div>
                </div>
                <div class="selected-profile" id="selectedProfileContainer" style="display: none;">
                    <img id="selectedProfilePicture" src="" alt="Selected Profile" class="user-profile-picture" />
                    <span id="selectedUsername" class="selected-username"></span>
                </div>
                <div class="modal-buttons">
                    <button id="cancelLoginButton" class="cancel-button">Cancel</button>
                    <button id="confirmLoginButton" class="confirm-button" style="display: none;">Confirm</button>
                </div>
            </div>
        </div>
    </div>

    <footer class="footer">
        <img src="CRONOBOTS.png" alt="Cronobots Logo" class="footer-logo">
        <p>CRONOS.WTF | DEVELOPPED BY UNSCOOP</p>
        <div class="donation-section">
            <h4>Your support makes this possible</h4>
            <div class="donation-progress">
                <span class="progress-label">Progress: <span id="progressPercent">1</span>%</span>
                <div class="progress-bar">
                    <div class="progress" id="donationProgressBar" style="width: 1%;"></div>
                </div>
            </div>
            <div class="wallet-address">
                <button class="wallet-address-button" title="Copy Unscoop.cro Address">Unscoop.cro</button>
                <button class="wallet-address-button" title="Copy Wallet Address">0x9829e44fd04f3788F27096875Df0D2772173Ab3d</button>
            </div>
        </div>
        <div class="theme-toggle">
            <label for="themeButton">Theme:</label>
            <button id="themeButton">Dark</button>
        </div>
    </footer>

    <button id="scrollToTopButton" aria-label="Scroll to top">↑</button>

    <script>
        const cache = new Map();
        let allNFTs = [];
        let currentUsername = '';
        let currentDisplayName = '';
        let lastSearchedUsername = '';
        let debounceTimeout = null;
        let isDownloadCancelled = false;
        let isProfileLoadingCancelled = false;
        let loggedInUser = null;
        let activeSearch = null;

        const profileQuery = `
            query User($id: ID!, $cacheId: ID) {
                public(cacheId: $cacheId) {
                    user(id: $id) {
                        username
                        displayName
                        verified
                        avatar {
                            url
                        }
                        twitterUsername
                        facebookUsername
                        instagramUsername
                    }
                }
            }
        `;

        const nftQuery = `
            query GetProfileAssets($ownerId: ID!, $first: Int!, $skip: Int!) {
                public {
                    profileAssets(ownerId: $ownerId, first: $first, skip: $skip) {
                        id
                        name
                        cover {
                            url
                        }
                        collection {
                            name
                        }
                        isExternalNft
                        externalNftMetadata {
                            network
                        }
                        defaultListingV2 {
                            salePriceDecimalUSD
                        }
                        latestPurchasedEdition {
                            priceUSD
                        }
                        createdAt
                        defaultRarityRank
                        isCurated
                    }
                }
            }
        `;

        const graphqlEndpoint = "https://crypto.com/nft-api/graphql";
        const homeUrl = "https://cronobots.github.io/Cronos";

        function parseUrlHash() {
            const hash = window.location.hash.substring(1);
            if (!hash) return { username: null, collection: null };
            const parts = hash.split('/#').map(decodeURIComponent);
            return {
                username: parts[0] || null,
                collection: parts[1] || null
            };
        }

        function resetViewport() {
            window.scrollTo(0, 0);
        }

        function toggleMenu() {
            const menu = document.getElementById('navbarMenu');
            const toggle = document.querySelector('.navbar-toggle');
            if (menu && toggle) {
                const isExpanded = menu.classList.toggle('active');
                toggle.setAttribute('aria-expanded', isExpanded);
                console.log('Menu toggled:', isExpanded ? 'visible' : 'hidden');
            } else {
                console.error('Navbar menu or toggle not found');
            }
        }

        function sanitizeInput(input) {
            return input.replace(/[<>]/g, '').trim().toLowerCase();
        }

        function sanitizeFileNameForZip(name) {
            if (!name || name.trim() === '') {
                return 'unnamed_nft';
            }
            return name.replace(/[\/\\:*?"$/g, '_').trim();
        }

        function toggleTheme() {
            const themeButton = document.getElementById('themeButton');
            if (!themeButton) {
                console.error('Theme button not found');
                return;
            }
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            themeButton.textContent = newTheme.charAt(0).toUpperCase() + newTheme.slice(1);
            console.log('Theme set to:', newTheme);
        }

        function updateLoginLink() {
            const userProfile = document.getElementById('userProfile');
            const userProfilePicture = document.getElementById('userProfilePicture');
            const myProfileLink = document.getElementById('myProfileLink');
            const logoutLink = document.getElementById('logoutLink');
            const loginLink = document.getElementById('loginLink');

            if (!userProfile || !userProfilePicture || !myProfileLink || !logoutLink || !loginLink) return;

            if (loggedInUser) {
                userProfilePicture.src = loggedInUser.avatar || '/assets/avatar.png';
                myProfileLink.textContent = 'My Profile';
                myProfileLink.href = `#${loggedInUser.username.toLowerCase()}`;
                userProfile.style.display = 'flex';
                myProfileLink.style.display = 'inline-block';
                logoutLink.style.display = 'inline-block';
                loginLink.style.display = 'none';
            } else {
                userProfile.style.display = 'none';
                myProfileLink.style.display = 'none';
                logoutLink.style.display = 'none';
                loginLink.style.display = 'inline-block';
            }
        }

        function showLoginModal(event) {
            event.preventDefault();
            const loginModal = document.getElementById('loginModal');
            const loginUsernameInput = document.getElementById('loginUsernameInput');
            const loginSearchContainer = document.getElementById('loginSearchContainer');
            const selectedProfileContainer = document.getElementById('selectedProfileContainer');
            const confirmLoginButton = document.getElementById('confirmLoginButton');
            if (loginModal && loginUsernameInput && loginSearchContainer && selectedProfileContainer && confirmLoginButton) {
                loginModal.style.display = 'flex';
                loginUsernameInput.value = '';
                loginUsernameInput.focus();
                loginSearchContainer.style.display = 'flex';
                selectedProfileContainer.style.display = 'none';
                confirmLoginButton.style.display = 'none';
                clearLoginSuggestions();
                const navbarMenu = document.getElementById('navbarMenu');
                if (navbarMenu) {
                    navbarMenu.classList.remove('active');
                    const toggle = document.querySelector('.navbar-toggle');
                    if (toggle) toggle.setAttribute('aria-expanded', 'false');
                }
            }
        }

        function clearLoginSuggestions() {
            const suggestions = document.getElementById('loginSuggestions');
            if (suggestions) {
                suggestions.innerHTML = '';
                suggestions.style.display = 'none';
            }
        }

        async function fetchWithCache(key, fetchFn, retries = 3, delay = 1000) {
            if (cache.has(key)) {
                console.log(`Cache hit for ${key}`);
                return cache.get(key);
            }
            for (let i = 0; i < retries; i++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000);
                    const data = await fetchFn(controller.signal);
                    clearTimeout(timeoutId);
                    if (data) {
                        cache.set(key, data);
                    } else {
                        console.log(`Not caching null response for ${key}`);
                    }
                    return data;
                } catch (error) {
                    if (i < retries - 1 && error.message.includes('429')) {
                        console.log(`Rate limit hit for ${key}, retrying in ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                    } else {
                        console.error(`Fetch error for ${key}:`, error.message);
                        throw error;
                    }
                }
            }
        }

        async function searchLoginProfiles(query) {
            const suggestions = document.getElementById('loginSuggestions');
            if (!suggestions) {
                console.error('Login suggestions container not found');
                return;
            }

            if (!query || query.length < 3) {
                suggestions.innerHTML = '';
                suggestions.style.display = 'none';
                return;
            }

            suggestions.innerHTML = '<div class="suggestion-item">Searching...</div>';
            suggestions.style.display = 'block';

            if (activeSearch) {
                activeSearch.cancel = true;
            }

            const searchToken = { cancel: false };
            activeSearch = searchToken;

            try {
                const profileData = await fetchWithCache(`profile_${query}`, async (signal) => {
                    const response = await fetch(graphqlEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            query: profileQuery,
                            variables: { id: query, cacheId: `getUserQuery-Profile-${query}` }
                        }),
                        signal
                    });

                    if (searchToken.cancel) {
                        throw new Error('Search cancelled');
                    }

                    if (!response.ok) {
                        throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
                    }

                    const result = await response.json();
                    if (result.errors) {
                        throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
                    }

                    return result.data?.public?.user;
                });

                if (searchToken.cancel) {
                    console.log('Search cancelled, ignoring result');
                    return;
                }

                suggestions.innerHTML = '';
                if (profileData && profileData.username) {
                    const item = document.createElement('div');
                    item.className = 'suggestion-item';
                    
                    if (profileData.avatar?.url) {
                        const img = document.createElement('img');
                        img.src = profileData.avatar.url;
                        img.alt = `${profileData.username} avatar`;
                        img.onerror = () => {
                            console.error(`Failed to load avatar for ${profileData.username}`);
                            img.style.display = 'none';
                        };
                        item.appendChild(img);
                    }

                    const text = document.createElement('span');
                    text.textContent = profileData.username;
                    item.appendChild(text);

                    item.dataset.username = profileData.username;
                    item.dataset.avatar = profileData.avatar?.url || '';
                    item.addEventListener('click', () => {
                        selectLoginProfile(profileData.username, profileData.avatar?.url);
                    });
                    suggestions.appendChild(item);
                    suggestions.style.display = 'block';
                } else {
                    suggestions.innerHTML = '<div class="suggestion-item">No profile found</div>';
                    suggestions.style.display = 'block';
                }
            } catch (error) {
                if (error.message !== 'Search cancelled') {
                    console.error(`Error in searchLoginProfiles: ${error.message}`);
                    suggestions.innerHTML = `<div class="suggestion-item">${
                        error.message.includes('user[id=') && error.message.includes('not found')
                            ? 'No profile found'
                            : `Error: ${error.message}`
                    }</div>`;
                    suggestions.style.display = 'block';
                }
            } finally {
                if (activeSearch === searchToken) {
                    activeSearch = null;
                }
            }
        }

        function selectLoginProfile(username, avatarUrl) {
            const loginUsernameInput = document.getElementById('loginUsernameInput');
            const loginSearchContainer = document.getElementById('loginSearchContainer');
            const selectedProfileContainer = document.getElementById('selectedProfileContainer');
            const selectedProfilePicture = document.getElementById('selectedProfilePicture');
            const selectedUsername = document.getElementById('selectedUsername');
            const confirmLoginButton = document.getElementById('confirmLoginButton');

            if (loginUsernameInput && loginSearchContainer && selectedProfileContainer && selectedProfilePicture && selectedUsername && confirmLoginButton) {
                loginUsernameInput.value = username;
                loginSearchContainer.style.display = 'none';
                selectedProfileContainer.style.display = 'flex';
                selectedUsername.textContent = username;
                selectedProfilePicture.src = avatarUrl || '/assets/fallback-icon.png';
                selectedProfilePicture.style.display = avatarUrl ? 'block' : 'none';
                confirmLoginButton.style.display = 'inline-block';
                clearLoginSuggestions();
            }
        }

        async function handleLogin() {
            const loginUsernameInput = document.getElementById('loginUsernameInput');
            const loginModal = document.getElementById('loginModal');
            const errorDiv = document.getElementById('error');
            if (!loginUsernameInput || !loginModal || !errorDiv) return;

            const username = sanitizeInput(loginUsernameInput.value.trim());
            if (!username) {
                errorDiv.textContent = 'Please enter a username.';
                return;
            }

            try {
                const profileData = await fetchWithCache(`profile_${username}`, async (signal) => {
                    const response = await fetch(graphqlEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            query: profileQuery,
                            variables: { id: username, cacheId: `getUserQuery-Profile-${username}` }
                        }),
                        signal
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
                    }

                    const result = await response.json();
                    if (result.errors) {
                        throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
                    }

                    return result.data?.public?.user;
                });

                if (profileData && profileData.username) {
                    loggedInUser = {
                        username: profileData.username,
                        displayName: profileData.displayName || profileData.username,
                        avatar: profileData.avatar?.url || ''
                    };
                    localStorage.setItem('loggedInUser', JSON.stringify(loggedInUser));
                    updateLoginLink();
                    loginModal.style.display = 'none';
                    errorDiv.textContent = '';
                    fetchProfileAndNFTsForLogin(profileData.username);
                } else {
                    errorDiv.textContent = 'No profile found';
                }
            } catch (error) {
                console.error(`Login error: ${error.message}`);
                errorDiv.textContent = error.message.includes('user[id=') && error.message.includes('not found')
                    ? 'No profile found'
                    : `Error: ${error.message}`;
            }
        }

        function resetLoginForm() {
            const loginModal = document.getElementById('loginModal');
            const loginUsernameInput = document.getElementById('loginUsernameInput');
            const loginSearchContainer = document.getElementById('loginSearchContainer');
            const selectedProfileContainer = document.getElementById('selectedProfileContainer');
            const confirmLoginButton = document.getElementById('confirmLoginButton');
            if (loginModal && loginUsernameInput && loginSearchContainer && selectedProfileContainer && confirmLoginButton) {
                loginModal.style.display = 'none';
                loginUsernameInput.value = '';
                loginSearchContainer.style.display = 'flex';
                selectedProfileContainer.style.display = 'none';
                confirmLoginButton.style.display = 'none';
                clearLoginSuggestions();
            }
        }

        function logout(event) {
            event.preventDefault();
            const username = loggedInUser?.username;
            loggedInUser = null;
            localStorage.removeItem('loggedInUser');
            updateLoginLink();
            const profileHeader = document.getElementById('profileHeader');
            const nftContainer = document.getElementById('nftContainer');
            const nftCountContainer = document.getElementById('nftCountContainer');
            const noResultsDiv = document.getElementById('noResults');
            const controls = document.getElementById('controls');
            const collectionTitle = document.getElementById('collectionTitle');
            const collectionFilter = document.getElementById('collectionFilter');
            const chainFilter = document.getElementById('chainFilter');
            const curatedFilter = document.getElementById('curatedFilter');
            const usernameInput = document.getElementById('usernameInput');
            const downloadZipButton = document.getElementById('downloadZipButton');
            const downloadCollageButton = document.getElementById('downloadCollageButton');

            if (profileHeader) profileHeader.style.display = 'none';
            if (nftContainer) nftContainer.innerHTML = '';
            if (nftCountContainer) nftCountContainer.innerHTML = '';
            if (noResultsDiv) noResultsDiv.style.display = 'none';
            if (controls) controls.classList.remove('visible');
            if (collectionTitle) {
                collectionTitle.textContent = '';
                collectionTitle.classList.remove('visible');
            }
            if (collectionFilter) {
                collectionFilter.innerHTML = '<option value="">All Collections</option>';
                collectionFilter.disabled = true;
            }
            if (chainsexual) chainFilter.value = '';
            if (curatedFilter) curatedFilter.value = '';
            if (usernameInput) usernameInput.value = '';
            if (downloadZipButton) downloadZipButton.style.display = 'none';
            if (downloadCollageButton) downloadCollageButton.style.display = 'none';

            allNFTs = [];
            currentUsername = '';
            history.pushState({}, '', window.location.pathname);
            window.location.href = homeUrl;
        }

        async function searchProfiles(query) {
            const suggestions = document.getElementById('suggestions');
            if (!suggestions) {
                console.error('Suggestions container not found');
                return;
            }

            if (!query || query.length < 3) {
                suggestions.innerHTML = '';
                suggestions.style.display = 'none';
                console.log('Query too short, clearing suggestions');
                return;
            }

            suggestions.innerHTML = '<div class="suggestion-item">Searching...</div>';
            suggestions.style.display = 'block';

            if (activeSearch) {
                activeSearch.cancel = true;
            }

            const searchToken = { cancel: false };
            activeSearch = searchToken;

            try {
                const profileData = await fetchWithCache(`profile_${query}`, async (signal) => {
                    const response = await fetch(graphqlEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            query: profileQuery,
                            variables: { id: query, cacheId: `getUserQuery-Profile-${query}` }
                        }),
                        signal
                    });

                    if (searchToken.cancel) {
                        throw new Error('Search cancelled');
                    }

                    if (!response.ok) {
                        throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
                    }

                    const result = await response.json();
                    if (result.errors) {
                        throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
                    }

                    return result.data?.public?.user;
                });

                if (searchToken.cancel) {
                    console.log('Search cancelled, ignoring result');
                    return;
                }

                suggestions.innerHTML = '';
                if (profileData && profileData.username) {
                    const item = document.createElement('div');
                    item.className = 'suggestion-item';
                    
                    if (profileData.avatar?.url) {
                        const img = document.createElement('img');
                        img.src = profileData.avatar.url;
                        img.alt = `${profileData.username} avatar`;
                        img.onerror = () => {
                            console.error(`Failed to load avatar for ${profileData.username}`);
                            img.style.display = 'none';
                        };
                        item.appendChild(img);
                    }

                    const text = document.createElement('span');
                    text.textContent = profileData.username;
                    item.appendChild(text);

                    item.dataset.username = profileData.username;
                    item.addEventListener('click', () => {
                        selectSuggestion(profileData.username);
                    });
                    suggestions.appendChild(item);
                    suggestions.style.display = 'block';
                } else {
                    suggestions.innerHTML = '<div class="suggestion-item">No profile found</div>';
                    suggestions.style.display = 'block';
                }
            } catch (error) {
                if (error.message !== 'Search cancelled') {
                    console.error(`Error in searchProfiles: ${error.message}`);
                    suggestions.innerHTML = `<div class="suggestion-item">${
                        error.message.includes('user[id=') && error.message.includes('not found')
                            ? 'No profile found'
                            : `Error: ${error.message}`
                    }</div>`;
                    suggestions.style.display = 'block';
                }
            } finally {
                if (activeSearch === searchToken) {
                    activeSearch = null;
                }
            }
        }

        function clearSuggestions() {
            const suggestions = document.getElementById('suggestions');
            if (suggestions) {
                suggestions.innerHTML = '';
                suggestions.style.display = 'none';
            }
        }

        function selectSuggestion(username) {
            const usernameInput = document.getElementById('usernameInput');
            if (usernameInput) {
                usernameInput.value = username;
                clearSuggestions();
                fetchProfileAndNFTs();
            }
        }

        async function fetchAllNFTs(ownerId, progressCallback) {
            const first = 60;
            let skip = 0;
            let allAssets = [];
            let hasMore = true;

            while (hasMore && !isProfileLoadingCancelled) {
                const nftVariables = { ownerId, first, skip };
                try {
                    const response = await fetch(graphqlEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ query: nftQuery, variables: nftVariables })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
                    }

                    const result = await response.json();
                    if (result.errors) {
                        throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
                    }

                    const assets = result.data?.public?.profileAssets || [];
                    allAssets = [...allAssets, ...assets];
                    skip += first;
                    hasMore = assets.length === first;
                    if (progressCallback) {
                        progressCallback(allAssets.length);
                    }
                } catch (error) {
                    console.error(`Failed to fetch NFTs: ${error.message}`);
                    throw error;
                }
            }

            return allAssets;
        }

        function normalizeText(text) {
            if (!text) return '';
            let normalized = text.normalize('NFKD').replace(/[\u0300-\u036f]/g, '');
            normalized = normalized.replace(/\n\s*\n/g, '\n').trim();
            return normalized;
        }

        function updateProfileUI(profileData) {
            const profileHeader = document.getElementById('profileHeader');
            const profilePicture = document.getElementById('profilePicture');
            const username = document.getElementById('username');
            const verifiedBadge = document.getElementById('verifiedBadge');
            const displayName = document.getElementById('displayName');
            const socialContainer = document.getElementById('socialContainer');
            const croLink = document.getElementById('croLink');
            const croUrl = document.getElementById('croUrl');
            const twitterLink = document.getElementById('twitterLink');
            const twitterUrl = document.getElementById('twitterUrl');
            const facebookLink = document.getElementById('facebookLink');
            const facebookUrl = document.getElementById('facebookUrl');
            const instagramLink = document.getElementById('instagramLink');
            const instagramUrl = document.getElementById('instagramUrl');
            const usernameInput = document.getElementById('usernameInput');

            if (!profileHeader || !profilePicture || !username || !verifiedBadge || !displayName || !socialContainer ||
                !croLink || !croUrl || !twitterLink || !twitterUrl || !facebookLink || !facebookUrl || !instagramLink || !instagramUrl || !usernameInput) {
                console.error('Profile UI elements not found');
                return;
            }

            if (!profileData || !profileData.username) {
                console.error('Invalid profile data');
                return;
            }

            username.textContent = profileData.username || 'Unknown';
            currentUsername = profileData.username || '';
            displayName.textContent = profileData.displayName || '';
            displayName.style.display = profileData.displayName ? 'block' : 'none';
            currentDisplayName = profileData.displayName || profileData.username || 'Unknown';

            verifiedBadge.style.display = profileData.verified === true ? 'inline-block' : 'none';
            profilePicture.src = profileData.avatar?.url || '';
            profilePicture.style.display = profileData.avatar?.url ? 'block' : 'none';

            let hasSocialLinks = false;

            if (currentUsername) {
                croUrl.href = `https://crypto.com/nft/profile/${sanitizeInput(currentUsername)}`;
                croLink.style.display = 'inline-block';
                hasSocialLinks = true;
            } else {
                croLink.style.display = 'none';
            }

            if (profileData.twitterUsername) {
                twitterUrl.href = `https://x.com/${sanitizeInput(profileData.twitterUsername)}`;
                twitterLink.style.display = 'inline-block';
                hasSocialLinks = true;
            } else {
                twitterLink.style.display = 'none';
            }

            if (profileData.facebookUsername) {
                facebookUrl.href = `https://facebook.com/${sanitizeInput(profileData.facebookUsername)}`;
                facebookLink.style.display = 'inline-block';
                hasSocialLinks = true;
            } else {
                facebookLink.style.display = 'none';
            }

            if (profileData.instagramUsername) {
                instagramUrl.href = `https://instagram.com/${sanitizeInput(profileData.instagramUsername)}`;
                instagramLink.style.display = 'inline-block';
                hasSocialLinks = true;
            } else {
                instagramLink.style.display = 'none';
            }

            socialContainer.style.display = hasSocialLinks ? 'flex' : 'none';
            profileHeader.style.display = 'block';
            usernameInput.value = '';
        }

        async function fetchProfileAndNFTs() {
            const usernameInput = document.getElementById('usernameInput');
            const errorDiv = document.getElementById('error');
            const noResultsDiv = document.getElementById('noResults');
            const controls = document.getElementById('controls');
            const collectionTitle = document.getElementById('collectionTitle');
            const profileHeader = document.getElementById('profileHeader');
            const nftContainer = document.getElementById('nftContainer');
            const nftCountContainer = document.getElementById('nftCountContainer');
            const collectionFilter = document.getElementById('collectionFilter');
            const chainFilter = document.getElementById('chainFilter');
            const curatedFilter = document.getElementById('curatedFilter');
            const displayMode = document.getElementById('displayMode');
            const cardSize = document.getElementById('cardSize');
            const sortBy = document.getElementById('sortBy');
            const downloadZipButton = document.getElementById('downloadZipButton');
            const downloadCollageButton = document.getElementById('downloadCollageButton');
            const progressModal = document.getElementById('progressModal');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const modalTitle = document.getElementById('modalTitle');
            const cancelButton = document.getElementById('cancelDownloadButton');

            if (!usernameInput || !errorDiv || !noResultsDiv || !controls || !collectionTitle ||
                !profileHeader || !nftContainer || !nftCountContainer || !collectionFilter || 
                !chainFilter || !curatedFilter || !displayMode || !cardSize || !sortBy || 
                !downloadZipButton || !downloadCollageButton || !progressModal || 
                !progressBar || !progressText || !modalTitle || !cancelButton) {
                console.error('Required DOM elements not found');
                if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
                return;
            }

            const username = sanitizeInput(usernameInput.value.trim());
            if (!username || username.toLowerCase() === currentUsername.toLowerCase()) {
                console.log('fetchProfileAndNFTs skipped:', { username, currentUsername });
                return;
            }

            console.log('Starting fetchProfileAndNFTs for:', username);

            currentUsername = '';
            allNFTs = [];
            displayMode.value = 'thumbnail';
            cardSize.value = 'small';
            sortBy.value = 'newest';
            collectionFilter.innerHTML = '<option value="">All Collections</option>';
            collectionFilter.value = '';
            collectionFilter.disabled = true;
            chainFilter.value = '';
            curatedFilter.value = '';

            currentUsername = username;
            lastSearchedUsername = currentUsername;
            clearSuggestions();

            profileHeader.style.display = 'none';
            nftContainer.innerHTML = '';
            nftCountContainer.innerHTML = '';
            noResultsDiv.style.display = 'none';
            controls.classList.remove('visible');
            collectionTitle.textContent = '';
            collectionTitle.classList.remove('visible');
            errorDiv.textContent = '';
            downloadZipButton.style.display = 'none';
            downloadCollageButton.style.display = 'none';

            modalTitle.textContent = 'Loading Profile';
            progressText.textContent = `Loading profile for ${username}...`;
            progressBar.style.width = '0%';
            progressModal.style.display = 'flex';
            cancelButton.style.display = 'block';

            isProfileLoadingCancelled = false;
            cancelButton.onclick = () => {
                isProfileLoadingCancelled = true;
                progressText.textContent = 'Profile loading cancelled.';
                progressBar.style.width = '0%';
                setTimeout(() => {
                    progressModal.style.display = 'none';
                    window.location.href = homeUrl;
                }, 1000);
            };

            let progress = 0;
            const progressInterval = setInterval(() => {
                if (isProfileLoadingCancelled) {
                    clearInterval(progressInterval);
                    return;
                }
                progress += 10;
                progressBar.style.width = `${Math.min(progress, 80)}%`;
            }, 500);

            try {
                const profileData = await fetchWithCache(`profile_${currentUsername}`, async (signal) => {
                    const response = await fetch(graphqlEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            query: profileQuery,
                            variables: { id: currentUsername, cacheId: `getUserQuery-Profile-${currentUsername}` }
                        }),
                        signal
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
                    }

                    const result = await response.json();
                    if (result.errors) {
                        throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
                    }

                    return result.data?.public?.user;
                });

                if (isProfileLoadingCancelled) {
                    clearInterval(progressInterval);
                    return;
                }

                if (!profileData) {
                    clearInterval(progressInterval);
                    progressModal.style.display = 'none';
                    noResultsDiv.style.display = 'block';
                    errorDiv.textContent = 'No profile found';
                    resetViewport();
                    return;
                }

                updateProfileUI(profileData);

                progressText.textContent = `0 assets`;
                allNFTs = await fetchWithCache(`nfts_${currentUsername}`, () => fetchAllNFTs(currentUsername, (nftCount) => {
                    if (isProfileLoadingCancelled) return;
                    progressText.textContent = `${nftCount} assets`;
                }));

                if (isProfileLoadingCancelled) {
                    clearInterval(progressInterval);
                    return;
                }

                clearInterval(progressInterval);
                progressBar.style.width = '100%';
                progressText.textContent = `${allNFTs.length} assets loaded successfully!`;
                setTimeout(() => {
                    progressModal.style.display = 'none';
                    resetViewport();
                }, 500);

                if (allNFTs.length > 0) {
                    console.log('Populating collection filter with', allNFTs.length, 'NFTs');
                    populateCollectionFilter(allNFTs);
                    collectionFilter.disabled = false;
                    controls.classList.add('visible');
                    console.log('Applying filters and displaying NFTs with', allNFTs.length, 'assets');

                    const { collection } = parseUrlHash();
                    if (collection) {
                        const optionExists = Array.from(collectionFilter.options).some(
                            option => option.value === collection
                        );
                        collectionFilter.value = optionExists ? collection : '';
                    }
                    chainFilter.value = '';
                    curatedFilter.value = '';

                    filterNFTs();
                } else {
                    console.log('No NFTs found, showing no results');
                    noResultsDiv.style.display = 'block';
                    resetViewport();
                }
            } catch (error) {
                if (!isProfileLoadingCancelled) {
                    console.error(`Error in fetchProfileAndNFTs: ${error.message}`);
                    clearInterval(progressInterval);
                    progressModal.style.display = 'none';
                    errorDiv.textContent = error.message.includes('user[id=') && error.message.includes('not found')
                        ? 'No profile found'
                        : `Error: ${error.message}`;
                    resetViewport();
                }
            }
        }

        async function fetchProfileAndNFTsForLogin(username) {
            console.log('fetchProfileAndNFTsForLogin called for username:', username);
            const errorDiv = document.getElementById('error');
            const noResultsDiv = document.getElementById('noResults');
            const controls = document.getElementById('controls');
            const collectionTitle = document.getElementById('collectionTitle');
            const profileHeader = document.getElementById('profileHeader');
            const nftContainer = document.getElementById('nftContainer');
            const nftCountContainer = document.getElementById('nftCountContainer');
            const collectionFilter = document.getElementById('collectionFilter');
            const chainFilter = document.getElementById('chainFilter');
            const curatedFilter = document.getElementById('curatedFilter');
            const displayMode = document.getElementById('displayMode');
            const cardSize = document.getElementById('cardSize');
            const sortBy = document.getElementById('sortBy');
            const downloadZipButton = document.getElementById('downloadZipButton');
            const downloadCollageButton = document.getElementById('downloadCollageButton');
            const progressModal = document.getElementById('progressModal');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const modalTitle = document.getElementById('modalTitle');
            const cancelButton = document.getElementById('cancelDownloadButton');

            if (!errorDiv || !noResultsDiv || !controls || !collectionTitle ||
                !profileHeader || !nftContainer || !nftCountContainer || !collectionFilter || 
                !chainFilter || !curatedFilter || !displayMode || !cardSize || !sortBy || 
                !downloadZipButton || !downloadCollageButton || !progressModal || 
                !progressBar || !progressText || !modalTitle || !cancelButton) {
                console.error('Required DOM elements not found');
                if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
                return;
            }

            const sanitizedUsername = sanitizeInput(username.trim());
            if (!username) {
                console.error('No username provided');
                errorDiv.textContent = 'No profile found';
                return;
            }

            console.log('Starting fetchProfileAndNFTsForLogin for:', sanitizedUsername);

            currentUsername = '';
            allNFTs = [];
            displayMode.value = 'thumbnail';
            cardSize.value = 'small';
            sortBy.value = 'newest';
            collectionFilter.innerHTML = '<option value="">All Collections</option>';
            collectionFilter.value = '';
            collectionFilter.disabled = true;
            chainFilter.value = '';
            curatedFilter.value = '';

            currentUsername = sanitizedUsername;
            lastSearchedUsername = currentUsername;
            clearSuggestions();

            profileHeader.style.display = 'none';
            nftContainer.innerHTML = '';
            nftCountContainer.innerHTML = '';
            noResultsDiv.style.display = 'none';
            controls.classList.remove('visible');
            collectionTitle.textContent = '';
            collectionTitle.classList.remove('visible');
            errorDiv.textContent = '';
            downloadZipButton.style.display = 'none';
            downloadCollageButton.style.display = 'none';

            modalTitle.textContent = 'Loading Profile';
            progressText.textContent = `Loading profile for ${sanitizedUsername}...`;
            progressBar.style.width = '0%';
            progressModal.style.display = 'flex';
            cancelButton.style.display = 'block';

            isProfileLoadingCancelled = false;
            cancelButton.onclick = () => {
                isProfileLoadingCancelled = true;
                progressText.textContent = 'Profile loading cancelled.';
                progressBar.style.width = '0%';
                setTimeout(() => {
                    progressModal.style.display = 'none';
                    window.location.href = homeUrl;
                }, 1000);
            };

            let progress = 0;
            const progressInterval = setInterval(() => {
                if (isProfileLoadingCancelled) {
                    clearInterval(progressInterval);
                    return;
                }
                progress += 10;
                progressBar.style.width = `${Math.min(progress, 80)}%`;
            }, 500);

            try {
                const profileData = await fetchWithCache(`profile_${currentUsername}`, async (signal) => {
                    const response = await fetch(graphqlEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            query: profileQuery,
                            variables: { id: currentUsername, cacheId: `getUserQuery-Profile-${currentUsername}` }
                        }),
                        signal
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
                    }

                    const result = await response.json();
                    if (result.errors) {
                        throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
                    }

                    return result.data?.public?.user;
                });

                if (isProfileLoadingCancelled) {
                    clearInterval(progressInterval);
                    return;
                }

                if (!profileData) {
                    clearInterval(progressInterval);
                    progressModal.style.display = 'none';
                    noResultsDiv.style.display = 'block';
                    errorDiv.textContent = 'No profile found';
                    resetViewport();
                    return;
                }

                updateProfileUI(profileData);

                progressText.textContent = `0 assets`;
                allNFTs = await fetchWithCache(`nfts_${currentUsername}`, () => fetchAllNFTs(currentUsername, (nftCount) => {
                    if (isProfileLoadingCancelled) return;
                    progressText.textContent = `${nftCount} assets`;
                }));

                if (isProfileLoadingCancelled) {
                    clearInterval(progressInterval);
                    return;
                }

                clearInterval(progressInterval);
                progressBar.style.width = '100%';
                progressText.textContent = `${allNFTs.length} assets loaded successfully!`;
                setTimeout(() => {
                    progressModal.style.display = 'none';
                    resetViewport();
                }, 500);

                if (allNFTs.length > 0) {
                    console.log('Populating collection filter with', allNFTs.length, 'NFTs');
                    populateCollectionFilter(allNFTs);
                    collectionFilter.disabled = false;
                    controls.classList.add('visible');
                    console.log('Applying filters and displaying NFTs with', allNFTs.length, 'assets');

                    const { collection } = parseUrlHash();
                    if (collection) {
                        const optionExists = Array.from(collectionFilter.options).some(
                            option => option.value === collection
                        );
                        collectionFilter.value = optionExists ? collection : '';
                    }
                    chainFilter.value = '';
                    curatedFilter.value = '';

                    filterNFTs();
                } else {
                    console.log('No NFTs found, showing no results');
                    noResultsDiv.style.display = 'block';
                    resetViewport();
                }
            } catch (error) {
                if (!isProfileLoadingCancelled) {
                    console.error(`Error in fetchProfileAndNFTsForLogin: ${error.message}`);
                    clearInterval(progressInterval);
                    progressModal.style.display = 'none';
                    errorDiv.textContent = error.message.includes('user[id=') && error.message.includes('not found')
                        ? 'No profile found'
                        : `Error: ${error.message}`;
                    resetViewport();
                }
            }
        }

        function populateCollectionFilter(nfts) {
            const collectionFilter = document.getElementById('collectionFilter');
            if (!collectionFilter) return;

            const collectionCounts = {};
            nfts.forEach(nft => {
                const collectionName = nft.collection?.name;
                if (collectionName) {
                    collectionCounts[collectionName] = (collectionCounts[collectionName] || 0) + 1;
                }
            });

            const sortedCollections = Object.keys(collectionCounts).sort((a, b) => {
                return collectionCounts[b] - collectionCounts[a];
            });

            collectionFilter.innerHTML = '<option value="">All Collections</option>';
            sortedCollections.forEach(collection => {
                const option = document.createElement('option');
                option.value = collection;
                option.textContent = `${collection} (${collectionCounts[collection]})`;
                collectionFilter.appendChild(option);
            });
        }

        function filterNFTs() {
            const collectionFilter = document.getElementById('collectionFilter');
            const chainFilter = document.getElementById('chainFilter');
            const curatedFilter = document.getElementById('curatedFilter');
            const sortBy = document.getElementById('sortBy');
            const collectionTitle = document.getElementById('collectionTitle');

            if (!collectionFilter || !chainFilter || !curatedFilter || !sortBy || !collectionTitle) {
                console.error('Filter elements not found');
                return;
            }

            console.log('Filtering NFTs with:', allNFTs.length, 'assets');

            if (!allNFTs || !allNFTs.length) {
                console.log('No NFTs to filter, displaying empty');
                displayNFTs([], '');
                collectionTitle.textContent = '';
                collectionTitle.classList.remove('visible');
                return;
            }

            console.log('Available isExternalNFT values:', [...new Set(allNFTs.map(nft => nft.isExternalNFT !== undefined ? nft.isExternalNFT : 'undefined'))]);
            console.log('Available network values:', [...new Set(allNFTs.map(nft => nft.isExternalNFT ? nft.externalNFTMetadata?.network || 'undefined' : 'N/A'))]);
            console.log('Available isCurated values:', [...new Set(allNFTs.map(nft => nft.isCurated !== undefined ? nft.isCurated : 'undefined'))]);

            let filteredNFTs = [...allNFTs];

            const collectionValue = collectionFilter.value;
            console.log('Collection value:', collectionValue);
            if (collectionValue) {
                filteredNFTs = filteredNFTs.filter(nft => nft.collection?.name === collectionValue);
                console.log('Filtered by collection:', filteredNFTs.length, 'NFTs');
            }

            const chainValue = chainFilter.value;
            console.log('Selected chain value:', chainValue);
            if (chainValue) {
                filteredNFTs = filteredNFTs.filter(nft => {
                    const isExternalNFT = nft.isExternalNFT;
                    const network = nft?.externalNFTMetadata?.network?.toUpperCase() || '';
                    if (chainValue === 'CRONOS') {
                        return isExternalNFT === true && network === 'CRONOS';
                    } else if (chainValue === 'CRONOS_POS') {
                        return isExternalNFT === false;
                    }
                    return true;
                });
                console.log('After chain filter:', filteredNFTs.length);
            }

            const curatedValue = curatedFilter.value;
            console.log('Selected curated value:', curatedValue);
            if (curatedValue) {
                filteredNFTs = filteredNFTs.filter(nft => {
                    const isCurated = nft.isCurated !== undefined ? nft.isCurated : false;
                    return curatedValue === 'true' ? isCurated === true : curatedValue === 'false' ? isCurated === false : true;
                });
                console.log('After curated filter:', filteredNFTs.length, 'NFTs');
            }

            const sortValue = sortBy.value || 'newest';
            console.log('Sort value:', sortValue);
            if (sortValue === 'rank') {
                filteredNFTs.sort((a, b) => (a.defaultRarityRank || Infinity) - (b.defaultRarityRank || Infinity));
            } else if (sortValue === 'oldest') {
                filteredNFTs.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
            } else {
                filteredNFTs.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
            }

            console.log('Final filtered NFTs:', filteredNFTs.length, 'for collection:', collectionValue || 'All', 'chain:', chainValue || 'All', 'curated:', curatedValue || 'All');

            collectionTitle.textContent = collectionValue || 'All Collections';
            collectionTitle.classList.add('visible');

            const encodedCollection = collectionValue ? encodeURIComponent(collectionValue) : '';
            const newUrl = encodedCollection
                ? `${window.location.pathname}#${encodeURIComponent(currentUsername.toLowerCase())}/#${encodedCollection}`
                : `${window.location.pathname}#${encodeURIComponent(currentUsername.toLowerCase())}`;
            history.pushState({ username: currentUsername, collection: collectionValue }, '', newUrl);

            displayNFTs(filteredNFTs);
        }

        function displayNFTs(assets, selectedCollection) {
            const container = document.getElementById('nftContainer');
            const countContainer = document.getElementById('nftCountContainer');
            const downloadZipButton = document.getElementById('downloadZipButton');
            const downloadCollageButton = document.getElementById('downloadCollageButton');
            const displayMode = document.getElementById('displayMode')?.value || 'thumbnail';
            const cardSize = document.getElementById('cardSize')?.value || 'small';

            if (!container || !countContainer || !downloadZipButton || !downloadCollageButton) {
                console.error('Container elements not found');
                return;
            }

            console.log('Displaying NFTs:', assets.length, 'assets for collection:', selectedCollection || 'All');

            countContainer.innerHTML = '';
            container.innerHTML = '';
            container.className = `nft-container ${displayMode}-mode ${cardSize}-size`;

            const countElement = document.createElement('p');
            countElement.className = 'nft-count';
            countElement.innerHTML = selectedCollection
                ? `<span style="color: var(--color1);">${currentUsername.toUpperCase()}</span> has <span class="count">${assets.length}</span> assets in this collection.`
                : `<span style="color: var(--color1);">${currentUsername.toUpperCase()}</span> has <span class="count">${assets.length}</span> assets.`;
            countContainer.appendChild(countElement);

            downloadZipButton.style.display = assets.length > 0 && currentUsername ? 'inline-block' : 'none';
            downloadCollageButton.style.display = assets.length > 0 && currentUsername ? 'inline-block' : 'none';
            if (assets.length > 0) {
                downloadZipButton.textContent = `DOWNLOAD ${assets.length} ASSETS`;
            }

            if (displayMode === 'thumbnail') {
                const cardWidth = cardSize === 'small' ? 110 : cardSize === 'large' ? 280 : 180;
                container.style.gridTemplateColumns = `repeat(auto-fill, ${cardWidth}px)`;

                assets.forEach((asset, index) => {
                    const imageUrl = asset.cover?.url || 'https://via.placeholder.com/150';
                    const card = document.createElement('div');
                    card.className = 'nft-card';

                    let mediaElement;
                    if (imageUrl.endsWith('.mp4')) {
                        mediaElement = document.createElement('video');
                        mediaElement.src = imageUrl;
                        mediaElement.muted = true;
                        mediaElement.loop = true;
                        mediaElement.playsinline = true;
                        mediaElement.setAttribute('muted', '');
                    } else {
                        mediaElement = document.createElement('img');
                        mediaElement.src = imageUrl;
                        mediaElement.alt = asset.name || 'NFT Image';
                        mediaElement.loading = 'lazy';
                        mediaElement.decoding = 'async';
                        mediaElement.sizes = '(max-width: 768px) 80px, 200px';
                    }

                    mediaElement.onerror = () => {
                        console.error('Media failed to load for asset:', asset.name || 'Unnamed');
                        card.innerHTML = '';
                        const placeholder = document.createElement('div');
                        placeholder.className = 'media-placeholder';
                        placeholder.textContent = 'Media unavailable';
                        card.appendChild(placeholder);
                    };

                    const tooltip = document.createElement('span');
                    tooltip.className = 'tooltip';
                    tooltip.textContent = asset.name || 'Unnamed NFT';
                    card.appendChild(tooltip);

                    card.appendChild(mediaElement);
                    container.appendChild(card);
                });
            } else {
                assets.forEach((asset, index) => {
                    const imageUrl = asset.cover?.url || 'https://via.placeholder.com/150';
                    const card = document.createElement('div');
                    card.className = 'nft-card';

                    let mediaElement;
                    if (imageUrl.endsWith('.mp4')) {
                        mediaElement = document.createElement('video');
                        mediaElement.src = imageUrl;
                        mediaElement.muted = true;
                        mediaElement.loop = true;
                        mediaElement.playsinline = true;
                        mediaElement.setAttribute('muted', '');
                    } else {
                        mediaElement = document.createElement('img');
                        mediaElement.src = imageUrl;
                        mediaElement.alt = asset.name || 'NFT Image';
                        mediaElement.loading = 'lazy';
                        mediaElement.decoding = 'async';
                        mediaElement.sizes = '(max-width: 768px) 80px, 200px';
                    }

                    mediaElement.onerror = () => {
                        console.error('Failed to load media for asset:', asset.name);
                        card.innerHTML = '';
                        const placeholder = document.createElement('div');
                        placeholder.className = 'media-placeholder';
                        placeholder.textContent = 'Media unavailable';
                        card.appendChild(placeholder);
                    };

                    card.appendChild(mediaElement);

                    const title = document.createElement('h3');
                    title.innerHTML = asset.name ? normalizeText(asset.name) : 'Unnamed NFT';
                    card.appendChild(title);

                    container.appendChild(card);
                });
            }
        }

        async function downloadNFTsAsZip() {
            const zip = new JSZip();
            const nftContainer = document.getElementById('nftContainer');
            const errorDiv = document.getElementById('error');
            const progressModal = document.getElementById('progressModal');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const modalTitle = document.getElementById('modalTitle');
            const cancelButton = document.getElementById('cancelDownloadButton');

            if (!nftContainer || !errorDiv || !progressModal || !progressBar || !progressText || !modalTitle || !cancelButton) {
                console.error('Required DOM elements not found');
                if (errorDiv) errorDiv.textContent = 'Internal error: missing UI elements';
                return;
            }

            const filteredAssets = Array.from(nftContainer.querySelectorAll('.nft-card')).map((card, index) => {
                const img = card.querySelector('img');
                const video = card.querySelector('video');
                const titleElement = card.querySelector('h3') || card.querySelector('.tooltip');
                const title = titleElement ? titleElement.textContent : `NFT_${index + 1}`;
                return {
                    url: img ? img.src : video ? video.src : null,
                    name: title,
                };
            }).filter(asset => asset.url && asset.url !== 'https://via.placeholder.com/150');

            if (filteredAssets.length === 0) {
                errorDiv.textContent = 'No valid assets to download';
                return;
            }

            modalTitle.textContent = 'Creating ZIP File';
            progressText.textContent = `Preparing ${filteredAssets.length} assets`;
            progressBar.style.width = '0%';
            progressModal.style.display = 'flex';
            cancelButton.style.display = 'block';

            isDownloadCancelled = false;
            cancelButton.onclick = () => {
                isDownloadCancelled = true;
                progressText.textContent = 'Download cancelled';
                progressBar.style.width = '0%';
                setTimeout(() => {
                    progressModal.style.display = 'none';
                }, 1000);
            };

            let processed = 0;
            for (const [index, asset] of filteredAssets.entries()) {
                if (isDownloadCancelled) {
                    console.log('Download cancelled');
                    return;
                }

                try {
                    const response = await fetch(asset.url);
                    if (!response.ok) {
                        console.error(`Failed to fetch ${asset.name}: ${response.status}`);
                        continue;
                    }
                    const blob = await response.blob();
                    const extension = asset.url.includes('.mp4') ? 'mp4' : 'png';
                    const sanitizedName = sanitizeFileNameForZip(asset.name);
                    const fileName = `${sanitizedName}.${extension}`;
                    zip.file(fileName, blob);
                    processed++;
                    const progressPercent = (processed / filteredAssets.length) * 100;
                    progressBar.style.width = `${progressPercent}%`;
                    progressText.textContent = `Processing: ${processed}/${filteredAssets.length}`;
                } catch (error) {
                    console.error(`Error downloading ${asset.name}: ${error.message}`);
                }
            }

            if (isDownloadCancelled) {
                console.log('Download aborted');
                return;
            }

            if (processed === 0) {
                progressModal.style.display = 'none';
                errorDiv.textContent = 'No assets downloaded';
                return;
            }

            progressText.textContent = 'Generating ZIP';
            try {
                const content = await zip.generateAsync({ type: 'blob' });
                saveAs(content, `${currentUsername}_nfts.zip`);
                progressText.textContent = 'Download complete';
                progressBar.style.width = '100%';
                setTimeout(() => {
                    progressModal.style.display = 'none';
                }, 1000);
            } catch (error) {
                console.error(`Error generating ZIP: ${error.message}`);
                progressModal.style.display = 'none';
                errorDiv.textContent = 'Failed to generate ZIP';
            }
        }

        async function downloadCollage() {
            const nftContainer = document.getElementById('nftContainer');
            const errorDiv = document.getElementById('error');
            const progressModal = document.getElementById('progressModal');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const modalTitle = document.getElementById('modalTitle');
            const cancelButton = document.getElementById('cancelDownloadButton');

            if (!nftContainer || !errorDiv || !progressModal || !progressBar || !progressText || !modalTitle || !cancelButton) {
                console.error('Required DOM elements not found');
                if (errorDiv) errorDiv.textContent = 'Internal error: missing elements';
                return;
            }

            const cards = nftContainer.querySelectorAll('.nft-card:not(.empty)');
            if (cards.length === 0) {
                errorDiv.textContent = 'No assets for collage';
                return;
            }

            modalTitle.textContent = 'Creating Collage';
            progressText.textContent = `Preparing collage with ${cards.length} assets`;
            progressBar.style.width = '0%';
            progressModal.style.display = 'flex';
            cancelButton.style.display = 'block';

            isDownloadCancelled = false;
            cancelButton.onclick = () => {
                isDownloadCancelled = true;
                progressText.textContent = 'Collage creation cancelled';
                progressBar.style.width = '0%';
                setTimeout(() => {
                    progressModal.style.display = 'none';
                }, 1000);
            };

            try {
                const gridSize = Math.ceil(Math.sqrt(cards.length));
                const imageSize = 300;
                const canvas = document.createElement('canvas');
                canvas.width = gridSize * imageSize;
                canvas.height = gridSize * imageSize;
                const ctx = canvas.getContext('2d');

                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                let processed = 0;
                for (let i = 0; i < cards.length; i++) {
                    if (isDownloadCancelled) {
                        console.log('Collage creation cancelled');
                        return;
                    }

                    const card = cards[i];
                    const img = card.querySelector('img');
                    const video = card.querySelector('video');
                    let mediaUrl = img ? img.src : video ? video.src : null;

                    if (!mediaUrl || mediaUrl.includes('undefined')) {
                        console.warn(`Invalid media for card ${i + 1}`);
                        continue;
                    }

                    try {
                        const response = await fetch(mediaUrl);
                        if (!response.ok) {
                            console.error(`Failed to fetch media for card ${i + 1}`);
                            continue;
                        }
                        const blob = await response.blob();
                        const imageBitmap = await createImageBitmap(blob);
                        const row = Math.floor(i / gridSize);
                        const col = i % gridSize;
                        ctx.drawImage(imageBitmap, col * imageSize, row * imageSize, imageSize, imageSize);
                        imageBitmap.close();
                        processed++;
                        const progressPercent = (processed / cards.length) * 100;
                        progressBar.style.width = `${progressPercent}%`;
                        progressText.textContent = `Processing: ${processed}/${cards.length}`;
                    } catch (err) {
                        console.error(`Error processing media for card ${i + 1}: ${err.message}`);
                        continue;
                    }
                }

                if (isDownloadCancelled) {
                    console.log('Collage creation aborted');
                    return;
                }

                if (processed === 0) {
                    progressModal.style.display = 'none';
                    errorDiv.textContent = 'No valid assets for collage';
                    return;
                }

                progressText.textContent = 'Generating collage image';
                canvas.toBlob((blob) => {
                    saveAs(blob, `${currentUsername}_collage.png`);
                    progressText.textContent = 'Collage download complete!';
                    progressBar.style.width = '100%';
                    setTimeout(() => {
                        progressModal.style.display = 'none';
                    }, 1000);
                }, 'image/png', 1.0);
            } catch (error) {
                console.error(`Error generating collage: ${error.message}`);
                progressModal.style.display = 'none';
                errorDiv.textContent = 'Failed to generate collage';
            }
        }

        function updateDisplay() {
            const displayMode = document.getElementById('displayMode')?.value || 'thumbnail';
            const cardSize = document.getElementById('cardSize')?.value || 'small';
            const nftContainer = document.getElementById('nftContainer');

            if (!nftContainer) {
                console.error('NFT container not found');
                return;
            }

            nftContainer.className = `nft-container ${displayMode}-mode ${cardSize}-size`;

            if (displayMode === 'thumbnail') {
                const cardWidth = cardSize === 'small' ? 110 : cardSize === 'large' ? 280 : 180;
                nftContainer.style.gridTemplateColumns = `repeat(auto-fill, ${cardWidth}px)`;
            } else {
                nftContainer.style.gridTemplateColumns = '';
            }

            filterNFTs();
        }

        function setupDonation() {
            const walletButtons = document.querySelectorAll('.wallet-address-button');
            const errorDiv = document.getElementById('error');

            if (!walletButtons.length || !errorDiv) {
                console.error('Wallet buttons or error div not found', { buttonsFound: walletButtons.length });
                return;
            }

            console.log('Setting up donation buttons:', walletButtons.length, 'found');

            walletButtons.forEach((button, index) => {
                button.addEventListener('click', async () => {
                    const address = button.textContent.trim();
                    console.log(`Attempting to copy address: ${address} (button ${index + 1})`);
                    try {
                        await navigator.clipboard.writeText(address);
                        const originalText = button.textContent;
                        button.textContent = '✓ Copied';
                        button.disabled = true;
                        console.log(`Successfully copied: ${address}`);
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.disabled = false;
                        }, 2000);
                    } catch (err) {
                        console.error(`Failed to copy address ${address}:`, err);
                        errorDiv.textContent = 'Failed to copy address';
                        setTimeout(() => {
                            errorDiv.textContent = '';
                        }, 3000);
                    }
                });
            });
        }

        function setupEventListeners() {
            const usernameInput = document.getElementById('usernameInput');
            const loginUsernameInput = document.getElementById('loginUsernameInput');
            const themeButton = document.getElementById('themeButton');
            const collectionFilter = document.getElementById('collectionFilter');
            const chainFilter = document.getElementById('chainFilter');
            const curatedFilter = document.getElementById('curatedFilter');
            const displayMode = document.getElementById('displayMode');
            const cardSize = document.getElementById('cardSize');
            const sortBy = document.getElementById('sortBy');
            const navbarMenu = document.getElementById('navbarMenu');
            const confirmLoginButton = document.getElementById('confirmLoginButton');
            const cancelLoginButton = document.getElementById('cancelLoginButton');
            const myProfileLink = document.getElementById('myProfileLink');
            const logoutLink = document.getElementById('logoutLink');
            const loginLink = document.getElementById('loginLink');
            const scrollToTopButton = document.getElementById('scrollToTopButton');

            if (!usernameInput || !loginUsernameInput || !themeButton || !collectionFilter || 
                !chainFilter || !curatedFilter || !displayMode || !cardSize || !sortBy || !navbarMenu || 
                !confirmLoginButton || !cancelLoginButton || !myProfileLink || !logoutLink || !loginLink || !scrollToTopButton) {
                console.error('DOM elements missing');
                const errorDiv = document.getElementById('error');
                if (errorDiv) errorDiv.textContent = 'Internal error: UI elements not found';
                return;
            }

            const isMobile = window.innerWidth <= 768;
            const debounceDelay = isMobile ? 500 : 300;

            usernameInput.addEventListener('input', () => {
                clearTimeout(debounceTimeout);
                debounceTimeout = setTimeout(() => {
                    const query = sanitizeInput(usernameInput.value.trim());
                    searchProfiles(query);
                }, debounceDelay);
            });

            usernameInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    clearSuggestions();
                    fetchProfileAndNFTs();
                }
            });

            usernameInput.addEventListener('blur', () => {
                resetViewport();
            });

            loginUsernameInput.addEventListener('input', () => {
                clearTimeout(debounceTimeout);
                debounceTimeout = setTimeout(() => {
                    const query = sanitizeInput(loginUsernameInput.value.trim());
                    searchLoginProfiles(query);
                }, debounceDelay);
            });

            loginUsernameInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    clearLoginSuggestions();
                    handleLogin();
                }
            });

            themeButton.addEventListener('click', toggleTheme);

            collectionFilter.addEventListener('change', filterNFTs);
            chainFilter.addEventListener('change', filterNFTs);
            curatedFilter.addEventListener('change', filterNFTs);
            displayMode.addEventListener('change', updateDisplay);
            cardSize.addEventListener('change', updateDisplay);
            sortBy.addEventListener('change', filterNFTs);

            confirmLoginButton.addEventListener('click', handleLogin);
            cancelLoginButton.addEventListener('click', resetLoginForm);

            myProfileLink.addEventListener('click', (event) => {
                event.preventDefault();
                if (loggedInUser?.username) {
                    const usernameInput = document.getElementById('usernameInput');
                    if (usernameInput) {
                        usernameInput.value = loggedInUser.username;
                        fetchProfileAndNFTs();
                    }
                }
            });

            logoutLink.addEventListener('click', logout);
            loginLink.addEventListener('click', showLoginModal);

            window.addEventListener('resize', () => {
                if (window.innerWidth > 768 && navbarMenu.classList.contains('active')) {
                    navbarMenu.classList.remove('active');
                    const toggle = document.querySelector('.navbar-toggle');
                    if (toggle) toggle.setAttribute('aria-expanded', 'false');
                }
            });

            window.addEventListener('popstate', () => {
                const { username, collection } = parseUrlHash();
                if (username && username !== currentUsername) {
                    currentUsername = username;
                    const usernameInput = document.getElementById('usernameInput');
                    if (usernameInput) {
                        usernameInput.value = username;
                        fetchProfileAndNFTs();
                    }
                } else if (!username) {
                    const profileHeader = document.getElementById('profileHeader');
                    const nftContainer = document.getElementById('nftContainer');
                    const nftCountContainer = document.getElementById('nftCountContainer');
                    const noResultsDiv = document.getElementById('noResults');
                    const controls = document.getElementById('controls');
                    const collectionTitle = document.getElementById('collectionTitle');
                    if (profileHeader) profileHeader.style.display = 'none';
                    if (nftContainer) nftContainer.innerHTML = '';
                    if (nftCountContainer) nftCountContainer.innerHTML = '';
                    if (noResultsDiv) noResultsDiv.style.display = 'none';
                    if (controls) controls.classList.remove('visible');
                    if (collectionTitle) {
                        collectionTitle.textContent = '';
                        collectionTitle.classList.remove('visible');
                    }
                    allNFTs = [];
                    currentUsername = '';
                }
            });

            scrollToTopButton.addEventListener('click', () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });

            window.addEventListener('scroll', () => {
                if (window.scrollY > 300) {
                    scrollToTopButton.style.display = 'block';
                } else {
                    scrollToTopButton.style.display = 'none';
                }
            });
        }

        function initialize() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            const themeButton = document.getElementById('themeButton');
            if (themeButton) {
                themeButton.textContent = savedTheme.charAt(0).toUpperCase() + savedTheme.slice(1);
            }

            const savedUser = localStorage.getItem('loggedInUser');
            if (savedUser) {
                loggedInUser = JSON.parse(savedUser);
                updateLoginLink();
            }

            setupDonation();
            setupEventListeners();

            const { username, collection } = parseUrlHash();
            if (username) {
                const usernameInput = document.getElementById('usernameInput');
                if (usernameInput) {
                    usernameInput.value = username;
                    fetchProfileAndNFTs();
                }
            }

            const errorDiv = document.getElementById('error');
            if (errorDiv) errorDiv.textContent = '';

            const progressModal = document.getElementById('progressModal');
            if (progressModal) progressModal.style.display = 'none';

            console.log('Initialization complete');
        }

        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>
