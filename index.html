<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Browse smarter. Collect better ‚Äì Developed by Unscoop">
    <title>CRONOS.WTF | Developed by Unscoop</title>
    <link rel="icon" type="image/png" href="icon.png">
    <link rel="preload" href="icon.png" as="image">
    <link rel="preload" href="Geomanist-Bold.otf" as="font" type="font/otf" crossorigin>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
</head>
<body>
    <noscript>
        <div style="text-align: center; padding: 20px; color: var(--text-dark);">
            JavaScript is required to view this content. Please enable JavaScript in your browser settings.
        </div>
    </noscript>
<nav class="navbar">
    <div class="navbar-logo-search-container">
        <div class="navbar-logo">
            <img src="CRONOBOTS.png" alt="Cronobots Logo">
            <span class="navbar-logo-text">CRONOS.WTF</span>
        </div>
        <div class="navbar-search">
            <input type="text" id="usernameInput" placeholder="üîé Search a profile" aria-describedby="usernameHelp" autocomplete="on" onfocus="this.placeholder=''" onblur="if(!this.value) this.placeholder='üîé Search a profile'" />
            <div class="suggestions" id="suggestions"></div>
        </div>
    </div>
    <div class="navbar-menu" id="navbarMenu">
        <a href="https://cronobots.github.io/Cronos" aria-label="Home">Home</a>
        <span class="navbar-divider"> | </span>
        <a href="#" id="myProfileLink" style="display: none;" aria-label="My Profile">My Profile</a>
        <a href="#" id="logoutLink" style="display: none;" aria-label="Logout">Logout</a>
        <a href="#" id="loginLink" aria-label="Login">Login</a>
        <div class="user-profile" id="userProfile" style="display: none;">
            <img id="userProfilePicture" src="" alt="User Profile" class="user-profile-picture" />
        </div>
    </div>
    <button class="navbar-toggle" aria-label="Toggle menu" aria-expanded="false">‚ò∞</button>
</nav>
<div class="main-content">
<div class="updates-container">
    <div class="update-modal home-update-modal" id="availableFeaturesModal" role="region" aria-labelledby="availableFeaturesTitle">
        <div class="update-modal-content">
            <div class="update-header">
                <h3 id="availableFeaturesTitle">‚úÖ Available Features</h3>
            </div>
            <div class="update-content" id="availableFeaturesContent">
                <ul>
                    <li>Profile exploration</li>
                    <li>Login</li>
                    <li>Filtering (Collection / Blockchain / Curated)</li>
                    <li>Display (Small / Medium / Large)</li>
                    <li>Sorting (Newest / Oldest / Rank)</li>
                    <li>Theme switching (Dark / CDC)</li>
                    <li>Full assets download (With NFT name)</li>
                    <li>Single asset download</li>
                    <li>Collage download</li>
                    <li>Scroll navigation buttons (Up / Down)</li>
                    <li>Community support tracking</li>
                </ul>
            </div>
        </div>
    </div>
    <div class="update-modal home-update-modal" id="inProgressModal" role="region" aria-labelledby="inProgressTitle">
        <div class="update-modal-content">
            <div class="update-header">
                <h3 id="inProgressTitle">‚öôÔ∏è In development</h3>
            </div>
            <div class="update-content" id="inProgressContent">
                <ul>
                    <li>Full collection viewer</li>
                    <li>Collection statistics (Floor / Volume / Owners)</li>
                    <li>Partner collections integration</li>
                    <li>Sales bot (Notifications / Automated alerts)</li>
                    <li>Leaderboards (Top holders / Top collections)</li>
                    <li>...</li>
                    <li>Send me your suggestions for improvements or bug reports on Discord or X.</li>
                </ul>
            </div>
        </div>
    </div>
</div>
    <div class="profile-section">
            <div class="profile-header" id="profileHeader" style="display: none;">
                <div class="profile-header-content">
                    <div class="profile-picture">
                        <img id="profilePicture" src="" alt="Profile Picture" />
                        <div class="social-container" style="display: none;" id="socialContainer">
                            <p id="croLink" style="display: none;">
                                <a href="#" target="_blank" id="croUrl" title="Visit Crypto.com/NFT Profile">
                                    <img src="CRO.png" alt="CRO Profile" class="social-icon" onerror="console.error('Failed to load CRO.png'); this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                            <p id="twitterLink" style="display: none;">
                                <a href="#" target="_blank" id="twitterUrl" title="Visit X Profile">
                                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/X_icon_2.svg/512px-X_icon_2.svg.png" alt="X Profile" class="social-icon" onerror="this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                            <p id="facebookLink" style="display: none;">
                                <a href="#" target="_blank" id="facebookUrl" title="Visit Facebook Profile">
                                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Facebook_f_logo_%282019%29.svg/512px-Facebook_f_logo_%282019%29.svg.png" alt="Facebook Profile" class="social-icon" onerror="this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                            <p id="instagramLink" style="display: none;">
                                <a href="#" target="_blank" id="instagramUrl" title="Visit Instagram Profile">
                                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/512px-Instagram_icon.png" alt="Instagram Profile" class="social-icon" onerror="this.src='/assets/fallback-icon.png'" />
                                </a>
                            </p>
                        </div>
                    </div>
                    <div class="profile-info">
                        <div class="username-container">
                            <h2 id="username" class="username"></h2>
                            <img id="verifiedBadge" class="verified-badge" src="https://parspng.com/wp-content/uploads/2022/07/tickpng.parspng.com-4-1024x1024.png" style="display: none;" alt="Verified" onerror="this.src='/assets/fallback-verified.png'" />
                        </div>
                        <p id="displayName" class="display-name"></p>
                    </div>
                </div>
            </div>
<div class="controls" id="controls">
    <div class="control-group">
        <label>COLLECTION:</label>
        <select id="collectionFilter" onchange="filterNFTs()" disabled>
            <option value="">ALL COLLECTIONS</option>
        </select>
    </div>
    <div class="control-group">
        <label>CHAINS:</label>
        <select id="chainFilter" onchange="filterNFTs()">
            <option value="">ALL</option>
            <option value="CRONOS">CRONOS</option>
            <option value="CRONOS_POS">CRONOS POS CHAIN</option>
        </select>
    </div>
    <div class="control-group">
        <label>CURATION:</label>
        <select id="curatedFilter" onchange="filterNFTs()">
            <option value="">ALL</option>
            <option value="true">CURATED</option>
            <option value="false">NON CURATED</option>
        </select>
    </div>
    <div class="control-group">
        <label for="cardSize">CARD SIZE:</label>
        <select id="cardSize" onchange="updateDisplay()">
            <option value="small" selected>SMALL</option>
            <option value="medium">MEDIUM</option>
            <option value="large">LARGE</option>
        </select>
    </div>
    <div class="control-group">
        <label>SORT BY:</label>
        <select id="sortBy" onchange="filterNFTs()">
            <option value="newest" selected>NEWEST</option>
            <option value="oldest">OLDEST</option>
            <option value="rank">RANK</option>
        </select>
    </div>
</div>
            <h2 id="collectionTitle" class="collection-title"></h2>
        </div>

        <div class="timestamp" id="timestamp"></div>
        <div class="error" id="error" role="alert"></div>
        <div class="no-results" id="noResults" style="display: none;">No results found</div>
        <div id="nftCountContainer"></div>
        <div class="nft-container" id="nftContainer"></div>
        <div class="download-buttons">
            <button id="downloadZipButton" style="display: none;" onclick="downloadNFTsAsZip()">DOWNLOAD ASSETS</button>
            <button id="downloadCollageButton" style="display: none;" onclick="downloadCollage()">DOWNLOAD COLLAGE</button>
        </div>

        <div class="modal" id="progressModal">
            <div class="modal-content">
                <h3 id="modalTitle">Creating ZIP File</h3>
                <div class="progress-bar">
                    <div class="progress" id="progressBar"></div>
                </div>
                <p class="progress-text" id="progressText">Preparing</p>
                <div class="modal-buttons">
                    <button id="cancelDownloadButton" class="cancel-button">Cancel</button>
                </div>
            </div>
        </div>
<div class="modal" id="loginModal">
    <div class="modal-content">
        <h3>Enter your Crypto.com/NFT Profile</h3>
        <div class="navbar-search" id="loginSearchContainer">
            <input type="text" id="loginUsernameInput" placeholder="üîé Search a profile" autocomplete="on" onfocus="this.placeholder=''" onblur="if(!this.value) this.placeholder='üîé Search a profile'" />
            <div class="suggestions" id="loginSuggestions"></div>
        </div>
        <div class="modal-buttons">
            <button id="cancelLoginButton" class="cancel-button">Cancel</button>
        </div>
    </div>
</div>
    </div>

<footer class="footer">
    <div class="footer-left">
<div class="footer-logo-container">
    <img src="CRONOBOTS.png" alt="Cronobots Logo" class="footer-logo">
    <p class="footer-text">DEVELOPED BY <a href="https://x.com/LoadedPixel_CDC" target="_blank" rel="noopener noreferrer" class="footer-link">UNSCOOP</a></p>
</div>
    </div>
    <div class="footer-center">
<div class="donation-section">
    <h4>Together, we make this possible</h4>
    <span class="wallet-address">0x9829e44fd04f3788F27096875Df0D2772173Ab3d</span>
    <div class="donation-progress">
        <span class="progress-label">Community Supports: <span id="progressPercent">1</span>%</span>
        <div class="progress-bar">
            <div class="progress" id="donationProgressBar" style="width: 1%;"></div>
        </div>
    </div>
</div>
    </div>
    <div class="footer-right">
        <div class="theme-toggle">
            <label>Theme:</label>
            <button id="themeButton">CDC</button>
        </div>
    </div>
</footer>

<button id="scrollToTopButton" aria-label="Scroll to top">‚Üë</button>
<button id="scrollToBottomButton" aria-label="Scroll to bottom">‚Üì</button>

    <script>
        const cache = new Map();
let allNFTs = [];
let currentUsername = '';
let currentDisplayName = '';
let lastSearchedUsername = '';
let debounceTimeout = null;
let isDownloadCancelled = false;
let isProfileLoadingCancelled = false;
let loggedInUser = null;
let activeSearch = null;
let hasSelectedSpecificCollection = false;

const profileQuery = `
    query User($id: ID!, $cacheId: ID) {
        public(cacheId: $cacheId) {
            user(id: $id) {
                username
                displayName
                verified
                avatar {
                    url
                }
                twitterUsername
                facebookUsername
                instagramUsername
            }
        }
    }
`;

const nftQuery = `
    query GetProfileAssets($ownerId: ID!, $first: Int!, $skip: Int!) {
        public {
            profileAssets(ownerId: $ownerId, first: $first, skip: $skip) {
                id
                name
                cover {
                    url
                }
                collection {
                    name
                }
                isExternalNft
                externalNftMetadata {
                    network
                }
                defaultListingV2 {
                    salePriceDecimalUSD
                }
                latestPurchasedEdition {
                    priceUSD
                }
                createdAt
                defaultRarityRank
                isCurated
            }
        }
    }
`;

const graphqlEndpoint = "https://crypto.com/nft-api/graphql";
const homeUrl = "https://cronobots.github.io/Cronos";

function parseUrlHash() {
    const hash = window.location.hash.substring(1);
    if (!hash) return { username: null, collection: null };
    const parts = hash.split('/#').map(decodeURIComponent);
    return {
        username: parts[0] || null,
        collection: parts[1] || null
    };
}

function resetSearchBar() {
    const searchInput = document.getElementById('usernameInput');
    if (searchInput) {
        searchInput.value = ''; // Vider le contenu
        searchInput.blur(); // Retirer le focus
        searchInput.placeholder = 'üîé Search a profile'; // Restaurer le placeholder
    }
}

function resetViewport() {
    window.scrollTo(0, 0);
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function toggleMenu(event) {
    console.log('toggleMenu called', { eventType: event?.type || 'unknown' });
    const menu = document.getElementById('navbarMenu');
    const toggle = document.querySelector('.navbar-toggle');
    if (menu && toggle) {
        const isExpanded = menu.classList.toggle('active');
        toggle.setAttribute('aria-expanded', isExpanded);
        console.log('Menu toggled:', isExpanded ? 'visible' : 'hidden', { menuDisplay: getComputedStyle(menu).display });
    } else {
        console.error('Navbar menu or toggle not found', { menu: !!menu, toggle: !!toggle });
    }
}

function sanitizeInput(input) {
    return input.replace(/[<>]/g, '').trim().toLowerCase();
}

function sanitizeFileNameForZip(name, index = 0) {
    if (!name || name.trim() === '') {
        return `unnamed_nft_${index}`;
    }
    // Supprimer les caract√®res non valides et limiter la longueur
    let sanitized = name.replace(/[\/\\:*?"<>|]/g, '_').trim();
    sanitized = sanitized.replace(/\s+/g, '_').substring(0, 100); // Limiter √† 100 caract√®res
    return sanitized || `unnamed_nft_${index}`;
}

function toggleTheme() {
    const themeButton = document.getElementById('themeButton');
    if (!themeButton) {
        console.error('Theme button not found');
        return;
    }
    const currentTheme = document.documentElement.getAttribute('data-theme');
    const newTheme = currentTheme === 'dark' ? 'cdc' : 'dark'; // Remplacer 'light' par 'cdc'
    document.documentElement.setAttribute('data-theme', newTheme);
    localStorage.setItem('theme', newTheme);
    themeButton.textContent = newTheme === 'dark' ? 'CDC' : 'Dark'; // Mettre √† jour le texte du bouton
    console.log('Theme set to:', newTheme);
}

function normalizeText(text) {
    if (!text) return '';
    let normalized = text.normalize('NFKD').replace(/[\u0300-\u036f]/g, '');
    normalized = normalized.replace(/\n\s*\n/g, '\n').trim();
    return normalized;
}

function updateLoginLink() {
    const userProfile = document.getElementById('userProfile');
    const userProfilePicture = document.getElementById('userProfilePicture');
    const myProfileLink = document.getElementById('myProfileLink');
    const logoutLink = document.getElementById('logoutLink');
    const loginLink = document.getElementById('loginLink');

    if (!userProfile || !userProfilePicture || !myProfileLink || !logoutLink || !loginLink) return;

    if (loggedInUser) {
        userProfilePicture.src = loggedInUser.avatar || '/assets/fallback-icon.png';
        myProfileLink.textContent = 'My Profile';
        myProfileLink.href = `#${loggedInUser.username.toLowerCase()}`;
        userProfile.style.display = 'flex';
        myProfileLink.style.display = 'inline-block';
        logoutLink.style.display = 'inline-block';
        loginLink.style.display = 'none';
    } else {
        userProfile.style.display = 'none';
        myProfileLink.style.display = 'none';
        logoutLink.style.display = 'none';
        loginLink.style.display = 'inline-block';
    }
}

function showLoginModal(event) {
    event.preventDefault();
    const loginModal = document.getElementById('loginModal');
    const loginUsernameInput = document.getElementById('loginUsernameInput');
    const loginSearchContainer = document.getElementById('loginSearchContainer');
    if (loginModal && loginUsernameInput && loginSearchContainer) {
        loginModal.style.display = 'flex';
        loginUsernameInput.value = '';
        loginUsernameInput.focus();
        loginSearchContainer.style.display = 'flex';
        clearLoginSuggestions();
        const navbarMenu = document.getElementById('navbarMenu');
        if (navbarMenu) {
            navbarMenu.classList.remove('active');
            const toggle = document.querySelector('.navbar-toggle');
            if (toggle) toggle.setAttribute('aria-expanded', 'false');
        }
    }
}


function clearLoginSuggestions() {
    const suggestions = document.getElementById('loginSuggestions');
    if (suggestions) {
        suggestions.innerHTML = '';
        suggestions.style.display = 'none';
    }
}

function resetLoginForm() {
    const loginModal = document.getElementById('loginModal');
    const loginUsernameInput = document.getElementById('loginUsernameInput');
    const loginSearchContainer = document.getElementById('loginSearchContainer');
    if (loginModal && loginUsernameInput && loginSearchContainer) {
        loginModal.style.display = 'none';
        loginUsernameInput.value = '';
        loginSearchContainer.style.display = 'flex';
        clearLoginSuggestions();
    }
}

function logout(event) {
    event.preventDefault();
    const username = loggedInUser?.username;
    loggedInUser = null;
    localStorage.removeItem('loggedInUser');
    updateLoginLink();
    const profileHeader = document.getElementById('profileHeader');
    const nftContainer = document.getElementById('nftContainer');
    const nftCountContainer = document.getElementById('nftCountContainer');
    const noResultsDiv = document.getElementById('noResults');
    const controls = document.getElementById('controls');
    const collectionTitle = document.getElementById('collectionTitle');
    const collectionFilter = document.getElementById('collectionFilter');
    const chainFilter = document.getElementById('chainFilter');
    const curatedFilter = document.getElementById('curatedFilter');
    const usernameInput = document.getElementById('usernameInput');
    const downloadZipButton = document.getElementById('downloadZipButton');
    const downloadCollageButton = document.getElementById('downloadCollageButton');

    if (profileHeader) profileHeader.style.display = 'none';
    if (nftContainer) nftContainer.innerHTML = '';
    if (nftCountContainer) nftCountContainer.innerHTML = '';
    if (noResultsDiv) noResultsDiv.style.display = 'none';
    if (controls) controls.classList.remove('visible');
    if (collectionTitle) {
        collectionTitle.textContent = '';
        collectionTitle.classList.remove('visible');
    }
    if (collectionFilter) {
        collectionFilter.innerHTML = '<option value="">All Collections</option>';
        collectionFilter.disabled = true;
    }
    if (chainFilter) chainFilter.value = '';
    if (curatedFilter) curatedFilter.value = '';
    if (usernameInput) usernameInput.value = '';
    if (downloadZipButton) downloadZipButton.style.display = 'none';
    if (downloadCollageButton) downloadCollageButton.style.display = 'none';

    allNFTs = [];
    currentUsername = '';
    history.pushState({}, '', window.location.pathname);
    window.location.href = homeUrl;
}

async function fetchWithCache(key, fetchFn, retries = 3, delay = 1000) {
    if (key.startsWith('image_')) {
        // Ignorer le cache pour les URLs d'images
        return await fetchFn();
    }
    if (cache.has(key)) {
        console.log(`Cache hit for ${key}`);
        return cache.get(key);
    }
    for (let i = 0; i < retries; i++) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000);
            const data = await fetchFn(controller.signal);
            clearTimeout(timeoutId);
            if (data) {
                cache.set(key, data);
            } else {
                console.log(`Not caching null response for ${key}`);
            }
            return data;
        } catch (error) {
            if (i < retries - 1 && error.message.includes('429')) {
                console.log(`Rate limit hit for ${key}, retrying in ${delay}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                delay *= 2;
            } else {
                console.error(`Fetch error for ${key}:`, error.message);
                throw error;
            }
        }
    }
}

async function fetchAllNFTs(ownerId, progressCallback) {
    const first = 60;
    let skip = 0;
    let allAssets = [];
    let hasMore = true;

    while (hasMore && !isProfileLoadingCancelled) {
        const nftVariables = { ownerId, first, skip };
        try {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query: nftQuery, variables: nftVariables })
            });

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            const assets = result.data?.public?.profileAssets || [];
            allAssets = [...allAssets, ...assets];
            skip += first;
            hasMore = assets.length === first;

            if (progressCallback) {
                progressCallback(allAssets.length);
            }
        } catch (error) {
            console.error(`Failed to fetch NFTs: ${error.message}`);
            throw error;
        }
    }

    return allAssets;
}

async function searchProfiles(query) {
    const suggestions = document.getElementById('suggestions');
    if (!suggestions) {
        console.error('Suggestions container not found');
        return;
    }

    if (!query || query.length < 3) {
        suggestions.innerHTML = '';
        suggestions.style.display = 'none';
        console.log('Query too short, clearing suggestions');
        return;
    }

    suggestions.innerHTML = '<div class="suggestion-item">Searching...</div>';
    suggestions.style.display = 'block';

    if (activeSearch) {
        activeSearch.cancel = true;
    }

    const searchToken = { cancel: false };
    activeSearch = searchToken;

    try {
        const profileData = await fetchWithCache(`profile_${query}`, async (signal) => {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: profileQuery,
                    variables: { id: query, cacheId: `getUserQuery-Profile-${query}` }
                }),
                signal
            });

            if (searchToken.cancel) {
                throw new Error('Search cancelled');
            }

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            return result.data?.public?.user;
        });

        if (searchToken.cancel) {
            console.log('Search cancelled, ignoring result');
            return;
        }

        suggestions.innerHTML = '';
        if (profileData && profileData.username) {
            const item = document.createElement('div');
            item.className = 'suggestion-item';
            
            if (profileData.avatar?.url) {
                const img = document.createElement('img');
                img.src = profileData.avatar.url;
                img.alt = `${profileData.username} avatar`;
                img.onerror = () => {
                    console.error(`Failed to load avatar for ${profileData.username}`);
                    img.style.display = 'none';
                };
                item.appendChild(img);
            }

            const text = document.createElement('span');
            text.textContent = profileData.username;
            item.appendChild(text);

            item.dataset.username = profileData.username;
            item.addEventListener('click', () => {
                selectSuggestion(profileData.username);
            });
            suggestions.appendChild(item);
            suggestions.style.display = 'block';
        } else {
            suggestions.innerHTML = '<div class="suggestion-item">No profile found</div>';
            suggestions.style.display = 'block';
        }
    } catch (error) {
        if (error.message !== 'Search cancelled') {
            console.error(`Error in searchProfiles: ${error.message}`);
            suggestions.innerHTML = `<div class="suggestion-item">${
                error.message.includes('user[id=') && error.message.includes('not found')
                    ? 'No profile found'
                    : `Error: ${error.message}`
            }</div>`;
            suggestions.style.display = 'block';
        }
    } finally {
        if (activeSearch === searchToken) {
            activeSearch = null;
        }
    }
}

function clearSuggestions() {
    const suggestions = document.getElementById('suggestions');
    if (suggestions) {
        suggestions.innerHTML = '';
        suggestions.style.display = 'none';
    }
}

function selectSuggestion(username) {
    const usernameInput = document.getElementById('usernameInput');
    if (usernameInput) {
        usernameInput.value = username;
        clearSuggestions();
        fetchProfileAndNFTs();
        resetSearchBar(); // R√©initialiser la barre apr√®s validation
    }
}

async function searchLoginProfiles(query) {
    const suggestions = document.getElementById('loginSuggestions');
    if (!suggestions) {
        console.error('Login suggestions container not found');
        return;
    }

    if (!query || query.length < 3) {
        suggestions.innerHTML = '';
        suggestions.style.display = 'none';
        return;
    }

    suggestions.innerHTML = '<div class="suggestion-item">Searching...</div>';
    suggestions.style.display = 'block';

    if (activeSearch) {
        activeSearch.cancel = true;
    }

    const searchToken = { cancel: false };
    activeSearch = searchToken;

    try {
        const profileData = await fetchWithCache(`profile_${query}`, async (signal) => {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: profileQuery,
                    variables: { id: query, cacheId: `getUserQuery-Profile-${query}` }
                }),
                signal
            });

            if (searchToken.cancel) {
                throw new Error('Search cancelled');
            }

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            return result.data?.public?.user;
        });

        if (searchToken.cancel) {
            console.log('Search cancelled, ignoring result');
            return;
        }

        suggestions.innerHTML = '';
        if (profileData && profileData.username) {
            const item = document.createElement('div');
            item.className = 'suggestion-item';
            
            if (profileData.avatar?.url) {
                const img = document.createElement('img');
                img.src = profileData.avatar.url;
                img.alt = `${profileData.username} avatar`;
                img.onerror = () => {
                    console.error(`Failed to load avatar for ${profileData.username}`);
                    img.style.display = 'none';
                };
                item.appendChild(img);
            }

            const text = document.createElement('span');
            text.textContent = profileData.username;
            item.appendChild(text);

            item.dataset.username = profileData.username;
            item.dataset.avatar = profileData.avatar?.url || '';
            item.addEventListener('click', () => {
                selectLoginSuggestion(profileData.username, profileData.avatar?.url);
            });
            suggestions.appendChild(item);
            suggestions.style.display = 'block';
        } else {
            suggestions.innerHTML = '<div class="suggestion-item">No profile found</div>';
            suggestions.style.display = 'block';
        }
    } catch (error) {
        if (error.message !== 'Search cancelled') {
            console.error(`Error in searchLoginProfiles: ${error.message}`);
            suggestions.innerHTML = `<div class="suggestion-item">${
                error.message.includes('user[id=') && error.message.includes('not found')
                    ? 'No profile found'
                    : `Error: ${error.message}`
            }</div>`;
            suggestions.style.display = 'block';
        }
    } finally {
        if (activeSearch === searchToken) {
            activeSearch = null;
        }
    }
}

async function selectLoginSuggestion(username, avatarUrl) {
    const loginUsernameInput = document.getElementById('loginUsernameInput');
    const loginModal = document.getElementById('loginModal');
    const errorDiv = document.getElementById('error');

    if (!loginUsernameInput || !loginModal || !errorDiv) {
        console.error('Required DOM elements not found');
        return;
    }

    try {
        // R√©cup√©rer les donn√©es du profil via l'API
        const profileData = await fetchWithCache(`profile_${username}`, async (signal) => {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: profileQuery,
                    variables: { id: username, cacheId: `getUserQuery-Profile-${username}` }
                }),
                signal
            });

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            return result.data?.public?.user;
        });

        if (profileData && profileData.username) {
            // Stocker les informations de l'utilisateur connect√©
            loggedInUser = {
                username: profileData.username,
                displayName: profileData.displayName || profileData.username,
                avatar: profileData.avatar?.url || '',
                twitterUsername: profileData.twitterUsername || '',
                facebookUsername: profileData.facebookUsername || '',
                instagramUsername: profileData.instagramUsername || '',
                verified: profileData.verified || false
            };
            localStorage.setItem('loggedInUser', JSON.stringify(loggedInUser));

            // Mettre √† jour l'interface de connexion (navbar)
            updateLoginLink();

            // Fermer le modal
            loginModal.style.display = 'none';
            errorDiv.textContent = '';
            loginUsernameInput.value = '';

            // Charger et afficher le profil complet
            updateProfileUI(profileData);
            fetchProfileAndNFTsForLogin(profileData.username);
        } else {
            errorDiv.textContent = 'No profile found';
        }
    } catch (error) {
        console.error(`Error in selectLoginSuggestion: ${error.message}`);
        errorDiv.textContent = error.message.includes('user[id=') && error.message.includes('not found')
            ? 'No profile found'
            : `Error: ${error.message}`;
    }
}

function updateProfileUI(profileData) {
    const profileHeader = document.getElementById('profileHeader');
    const profilePicture = document.getElementById('profilePicture');
    const username = document.getElementById('username');
    const verifiedBadge = document.getElementById('verifiedBadge');
    const displayName = document.getElementById('displayName');
    const socialContainer = document.getElementById('socialContainer');
    const croLink = document.getElementById('croLink');
    const croUrl = document.getElementById('croUrl');
    const twitterLink = document.getElementById('twitterLink');
    const twitterUrl = document.getElementById('twitterUrl');
    const facebookLink = document.getElementById('facebookLink');
    const facebookUrl = document.getElementById('facebookUrl');
    const instagramLink = document.getElementById('instagramLink');
    const instagramUrl = document.getElementById('instagramUrl');
    const usernameInput = document.getElementById('usernameInput');

    if (!profileHeader || !profilePicture || !username || !verifiedBadge || !displayName || !socialContainer ||
        !croLink || !croUrl || !twitterLink || !twitterUrl || !facebookLink || !facebookUrl || !instagramLink || !instagramUrl || !usernameInput) {
        console.error('Profile UI elements not found');
        return;
    }

    if (!profileData || !profileData.username) {
        console.error('Invalid profile data');
        return;
    }

    username.textContent = profileData.username || 'Unknown';
    currentUsername = profileData.username || '';
    displayName.textContent = profileData.displayName || '';
    displayName.style.display = profileData.displayName ? 'block' : 'none';
    currentDisplayName = profileData.displayName || profileData.username || 'Unknown';

    verifiedBadge.style.display = profileData.verified === true ? 'inline-block' : 'none';
    profilePicture.src = profileData.avatar?.url || '';
    profilePicture.style.display = profileData.avatar?.url ? 'block' : 'none';

    let hasSocialLinks = false;

    if (currentUsername) {
        croUrl.href = `https://crypto.com/nft/profile/${sanitizeInput(currentUsername)}`;
        croLink.style.display = 'inline-block';
        hasSocialLinks = true;
    } else {
        croLink.style.display = 'none';
    }

    if (profileData.twitterUsername) {
        twitterUrl.href = `https://x.com/${sanitizeInput(profileData.twitterUsername)}`;
        twitterLink.style.display = 'inline-block';
        hasSocialLinks = true;
    } else {
        twitterLink.style.display = 'none';
    }

    if (profileData.facebookUsername) {
        facebookUrl.href = `https://facebook.com/${sanitizeInput(profileData.facebookUsername)}`;
        facebookLink.style.display = 'inline-block';
        hasSocialLinks = true;
    } else {
        facebookLink.style.display = 'none';
    }

    if (profileData.instagramUsername) {
        instagramUrl.href = `https://instagram.com/${sanitizeInput(profileData.instagramUsername)}`;
        instagramLink.style.display = 'inline-block';
        hasSocialLinks = true;
    } else {
        instagramLink.style.display = 'none';
    }

    socialContainer.style.display = hasSocialLinks ? 'flex' : 'none';
    profileHeader.style.display = 'block';
    usernameInput.value = '';
}

async function fetchProfileAndNFTs() {
    const usernameInput = document.getElementById('usernameInput');
    const errorDiv = document.getElementById('error');
    const noResultsDiv = document.getElementById('noResults');
    const controls = document.getElementById('controls');
    const collectionTitle = document.getElementById('collectionTitle');
    const profileHeader = document.getElementById('profileHeader');
    const nftContainer = document.getElementById('nftContainer');
    const nftCountContainer = document.getElementById('nftCountContainer');
    const collectionFilter = document.getElementById('collectionFilter');
    const chainFilter = document.getElementById('chainFilter');
    const curatedFilter = document.getElementById('curatedFilter');
    const cardSize = document.getElementById('cardSize');
    const sortBy = document.getElementById('sortBy');
    const downloadZipButton = document.getElementById('downloadZipButton');
    const downloadCollageButton = document.getElementById('downloadCollageButton');
    const progressModal = document.getElementById('progressModal');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const modalTitle = document.getElementById('modalTitle');
    const cancelButton = document.getElementById('cancelDownloadButton');
    const availableFeaturesModal = document.getElementById('availableFeaturesModal');
    const inProgressModal = document.getElementById('inProgressModal');

    if (!usernameInput || !errorDiv || !noResultsDiv || !controls || !collectionTitle ||
        !profileHeader || !nftContainer || !nftCountContainer || !collectionFilter || 
        !chainFilter || !curatedFilter || !cardSize || !sortBy || 
        !downloadZipButton || !downloadCollageButton || !progressModal || 
        !progressBar || !progressText || !modalTitle || !cancelButton) {
        console.error('Required DOM elements not found');
        if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
        return;
    }

    const username = sanitizeInput(usernameInput.value.trim());
    if (!username || username.toLowerCase() === currentUsername.toLowerCase()) {
        console.log('fetchProfileAndNFTs skipped:', { username, currentUsername });
        return;
    }

    console.log('Starting fetchProfileAndNFTs for:', username);

    currentUsername = '';
    allNFTs = [];
    cardSize.value = 'small';
    sortBy.value = 'newest';
    collectionFilter.innerHTML = '<option value="">All Collections</option>';
    collectionFilter.value = '';
    chainFilter.value = '';
    curatedFilter.value = '';
    chainFilter.disabled = false;
    curatedFilter.disabled = false;

    currentUsername = username;
    lastSearchedUsername = currentUsername;
    clearSuggestions();

    // Masquer les modales de mise √† jour
    if (availableFeaturesModal) availableFeaturesModal.style.display = 'none';
    if (inProgressModal) inProgressModal.style.display = 'none';

    profileHeader.style.display = 'none';
    nftContainer.innerHTML = '';
    nftCountContainer.innerHTML = '';
    noResultsDiv.style.display = 'none';
    controls.classList.remove('visible');
    collectionTitle.textContent = '';
    collectionTitle.classList.remove('visible');
    errorDiv.textContent = '';
    downloadZipButton.style.display = 'none';
    downloadCollageButton.style.display = 'none';
    resetSearchBar();

    modalTitle.textContent = 'Loading Profile';
    progressText.textContent = `Loading profile for ${username}...`;
    progressBar.style.width = '0%';
    progressModal.style.display = 'flex';
    cancelButton.style.display = 'block';

    isProfileLoadingCancelled = false;
    cancelButton.onclick = () => {
        isProfileLoadingCancelled = true;
        progressText.textContent = 'Profile loading cancelled.';
        progressBar.style.width = '0%';
        setTimeout(() => {
            progressModal.style.display = 'none';
            window.location.href = homeUrl;
        }, 1000);
    };

    let progress = 0;
    const progressInterval = setInterval(() => {
        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }
        progress += 10;
        progressBar.style.width = `${Math.min(progress, 80)}%`;
    }, 500);

    try {
        const profileData = await fetchWithCache(`profile_${currentUsername}`, async (signal) => {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: profileQuery,
                    variables: { id: currentUsername, cacheId: `getUserQuery-Profile-${currentUsername}` }
                }),
                signal
            });

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            return result.data?.public?.user;
        });

        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }

        if (!profileData) {
            clearInterval(progressInterval);
            progressModal.style.display = 'none';
            noResultsDiv.style.display = 'block';
            errorDiv.textContent = 'No profile found';
            resetViewport();
            return;
        }

        updateProfileUI(profileData);

        progressText.textContent = `0 assets`;
        allNFTs = await fetchWithCache(`nfts_${currentUsername}`, () => fetchAllNFTs(currentUsername, (nftCount) => {
            if (isProfileLoadingCancelled) return;
            progressText.textContent = `${nftCount} assets`;
        }));

        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }

        clearInterval(progressInterval);
        progressBar.style.width = '100%';
        progressText.textContent = `${allNFTs.length} assets loaded successfully!`;
        setTimeout(() => {
            progressModal.style.display = 'none';
            resetViewport();
        }, 500);

        if (allNFTs.length > 0) {
            console.log('Populating collection filter with', allNFTs.length, 'NFTs');
            populateCollectionFilter(allNFTs);
            collectionFilter.disabled = false;
            controls.classList.add('visible');
            console.log('Applying filters and displaying NFTs with', allNFTs.length, 'assets');

            const { collection } = parseUrlHash();
            if (collection) {
                const optionExists = Array.from(collectionFilter.options).some(
                    option => option.value === collection
                );
                collectionFilter.value = optionExists ? collection : '';
            } else {
                collectionFilter.value = '';
                chainFilter.value = '';
                curatedFilter.value = '';
                chainFilter.disabled = false;
                curatedFilter.disabled = false;
                console.log('No collection in URL: CURATION enabled=', !curatedFilter.disabled, 'value=', curatedFilter.value);
                console.log('No collection in URL: CHAINS enabled=', !chainFilter.disabled, 'value=', chainFilter.value);
            }

            // Garde-fou : s'assurer que les filtres sont activ√©s apr√®s le chargement
            if (!collectionFilter.value) {
                chainFilter.value = '';
                curatedFilter.value = '';
                chainFilter.disabled = false;
                curatedFilter.disabled = false;
                console.log('Post-loading check: CURATION enabled=', !curatedFilter.disabled, 'value=', curatedFilter.value);
                console.log('Post-loading check: CHAINS enabled=', !chainFilter.disabled, 'value=', chainFilter.value);
            }

            filterNFTs();
        } else {
            console.log('No NFTs found, showing no results');
            noResultsDiv.style.display = 'block';
            resetViewport();
        }
    } catch (error) {
        if (!isProfileLoadingCancelled) {
            console.error(`Error in fetchProfileAndNFTs: ${error.message}`);
            clearInterval(progressInterval);
            progressModal.style.display = 'none';
            errorDiv.textContent = error.message.includes('user[id=') && error.message.includes('not found')
                ? 'No profile found'
                : `Error: ${error.message}`;
            resetViewport();
        }
    }
}

async function fetchProfileAndNFTsForLogin(username) {
    console.log('fetchProfileAndNFTsForLogin called for username:', username);
    const errorDiv = document.getElementById('error');
    const noResultsDiv = document.getElementById('noResults');
    const controls = document.getElementById('controls');
    const collectionTitle = document.getElementById('collectionTitle');
    const profileHeader = document.getElementById('profileHeader');
    const nftContainer = document.getElementById('nftContainer');
    const nftCountContainer = document.getElementById('nftCountContainer');
    const collectionFilter = document.getElementById('collectionFilter');
    const chainFilter = document.getElementById('chainFilter');
    const curatedFilter = document.getElementById('curatedFilter');
    const cardSize = document.getElementById('cardSize');
    const sortBy = document.getElementById('sortBy');
    const downloadZipButton = document.getElementById('downloadZipButton');
    const downloadCollageButton = document.getElementById('downloadCollageButton');
    const progressModal = document.getElementById('progressModal');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const modalTitle = document.getElementById('modalTitle');
    const cancelButton = document.getElementById('cancelDownloadButton');
    const availableFeaturesModal = document.getElementById('availableFeaturesModal');
    const inProgressModal = document.getElementById('inProgressModal');

    if (!errorDiv || !noResultsDiv || !controls || !collectionTitle ||
        !profileHeader || !nftContainer || !nftCountContainer || !collectionFilter || 
        !chainFilter || !curatedFilter || !cardSize || !sortBy || 
        !downloadZipButton || !downloadCollageButton || !progressModal || 
        !progressBar || !progressText || !modalTitle || !cancelButton) {
        console.error('Required DOM elements not found');
        if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
        return;
    }

    const sanitizedUsername = sanitizeInput(username.trim());
    if (!sanitizedUsername) {
        console.log('No username provided');
        errorDiv.textContent = 'No username provided';
        return;
    }

    console.log('Starting fetchProfileAndNFTsForLogin for:', sanitizedUsername);

    currentUsername = '';
    allNFTs = [];
    cardSize.value = 'small';
    sortBy.value = 'newest';
    collectionFilter.innerHTML = '<option value="">All Collections</option>';
    collectionFilter.value = '';
    chainFilter.value = '';
    curatedFilter.value = '';
    chainFilter.disabled = false;
    curatedFilter.disabled = false;

    currentUsername = sanitizedUsername;
    lastSearchedUsername = currentUsername;
    clearSuggestions();

    // Masquer les modales de mise √† jour
    if (availableFeaturesModal) availableFeaturesModal.style.display = 'none';
    if (inProgressModal) inProgressModal.style.display = 'none';

    profileHeader.style.display = 'none';
    nftContainer.innerHTML = '';
    nftCountContainer.innerHTML = '';
    noResultsDiv.style.display = 'none';
    controls.classList.remove('visible');
    collectionTitle.textContent = '';
    collectionTitle.classList.remove('visible');
    errorDiv.textContent = '';
    downloadZipButton.style.display = 'none';
    downloadCollageButton.style.display = 'none';

    modalTitle.textContent = 'Loading Profile';
    progressText.textContent = `Loading profile for ${sanitizedUsername}...`;
    progressBar.style.width = '0%';
    progressModal.style.display = 'flex';
    cancelButton.style.display = 'block';

    isProfileLoadingCancelled = false;
    cancelButton.onclick = () => {
        isProfileLoadingCancelled = true;
        progressText.textContent = 'Profile loading cancelled.';
        progressBar.style.width = '0%';
        setTimeout(() => {
            progressModal.style.display = 'none';
            window.location.href = homeUrl;
        }, 1000);
    };

    let progress = 0;
    const progressInterval = setInterval(() => {
        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }
        progress += 10;
        progressBar.style.width = `${Math.min(progress, 80)}%`;
    }, 500);

    try {
        const profileData = await fetchWithCache(`profile_${currentUsername}`, async (signal) => {
            const response = await fetch(graphqlEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: profileQuery,
                    variables: { id: currentUsername, cacheId: `getUserQuery-Profile-${currentUsername}` }
                }),
                signal
            });

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();
            if (result.errors) {
                throw new Error(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`);
            }

            return result.data?.public?.user;
        });

        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }

        if (!profileData) {
            clearInterval(progressInterval);
            progressModal.style.display = 'none';
            noResultsDiv.style.display = 'block';
            errorDiv.textContent = 'No profile found';
            resetViewport();
            return;
        }

        updateProfileUI(profileData);

        progressText.textContent = `0 assets`;
        allNFTs = await fetchWithCache(`nfts_${currentUsername}`, () => fetchAllNFTs(currentUsername, (nftCount) => {
            if (isProfileLoadingCancelled) return;
            progressText.textContent = `${nftCount} assets`;
        }));

        if (isProfileLoadingCancelled) {
            clearInterval(progressInterval);
            return;
        }

        clearInterval(progressInterval);
        progressBar.style.width = '100%';
        progressText.textContent = `${allNFTs.length} assets loaded successfully!`;
        setTimeout(() => {
            progressModal.style.display = 'none';
            resetViewport();
        }, 500);

        if (allNFTs.length > 0) {
            console.log('Populating collection filter with', allNFTs.length, 'NFTs');
            populateCollectionFilter(allNFTs);
            collectionFilter.disabled = false;
            controls.classList.add('visible');
            console.log('Applying filters and displaying NFTs with', allNFTs.length, 'assets');

            const { collection } = parseUrlHash();
            if (collection) {
                const optionExists = Array.from(collectionFilter.options).some(
                    option => option.value === collection
                );
                collectionFilter.value = optionExists ? collection : '';
            } else {
                collectionFilter.value = '';
                chainFilter.value = '';
                curatedFilter.value = '';
                chainFilter.disabled = false;
                curatedFilter.disabled = false;
                console.log('No collection in URL: CURATION enabled=', !curatedFilter.disabled, 'value=', curatedFilter.value);
                console.log('No collection in URL: CHAINS enabled=', !chainFilter.disabled, 'value=', chainFilter.value);
            }

            // Garde-fou : s'assurer que les filtres sont activ√©s apr√®s le chargement
            if (!collectionFilter.value) {
                chainFilter.value = '';
                curatedFilter.value = '';
                chainFilter.disabled = false;
                curatedFilter.disabled = false;
                console.log('Post-loading check: CURATION enabled=', !curatedFilter.disabled, 'value=', curatedFilter.value);
                console.log('Post-loading check: CHAINS enabled=', !chainFilter.disabled, 'value=', chainFilter.value);
            }

            filterNFTs();
        } else {
            console.log('No NFTs found, showing no results');
            noResultsDiv.style.display = 'block';
            resetViewport();
        }
    } catch (error) {
        if (!isProfileLoadingCancelled) {
            console.error(`Error in fetchProfileAndNFTsForLogin: ${error.message}`);
            clearInterval(progressInterval);
            progressModal.style.display = 'none';
            errorDiv.textContent = error.message.includes('user[id=') && error.message.includes('not found')
                ? 'No profile found'
                : `Error: ${error.message}`;
            resetViewport();
        }
    }
}

function populateCollectionFilter(nfts) {
    const collectionFilter = document.getElementById('collectionFilter');
    if (!collectionFilter) return;

    const collectionCounts = {};
    nfts.forEach(nft => {
        const collectionName = nft.collection?.name;
        if (collectionName) {
            collectionCounts[collectionName] = (collectionCounts[collectionName] || 0) + 1;
        }
    });

    const sortedCollections = Object.keys(collectionCounts).sort((a, b) => {
        return collectionCounts[b] - collectionCounts[a];
    });

    collectionFilter.innerHTML = '<option value="">All Collections</option>';
    sortedCollections.forEach(collection => {
        const option = document.createElement('option');
        option.value = collection;
        option.textContent = `${collection} (${collectionCounts[collection]})`;
        collectionFilter.appendChild(option);
    });
}

function filterNFTs() {
    const collectionFilter = document.getElementById('collectionFilter');
    const chainFilter = document.getElementById('chainFilter');
    const curatedFilter = document.getElementById('curatedFilter');
    const cardSize = document.getElementById('cardSize');
    const sortBy = document.getElementById('sortBy');
    const collectionTitle = document.getElementById('collectionTitle');

    if (!collectionFilter || !chainFilter || !curatedFilter || !cardSize || !sortBy || !collectionTitle) {
        console.error('Filter elements not found');
        return;
    }

    console.log('Filtering NFTs with', allNFTs.length, 'assets', {
        collection: collectionFilter.value,
        chain: chainFilter.value,
        curated: curatedFilter.value
    });

    if (!allNFTs || !allNFTs.length) {
        console.log('No NFTs to filter, displaying empty');
        displayNFTs([], '');
        collectionTitle.textContent = '';
        collectionTitle.classList.remove('visible');
        return;
    }

    let filteredNFTs = [...allNFTs];

    const collectionValue = collectionFilter.value;

    if (collectionValue) {
        filteredNFTs = filteredNFTs.filter(nft => nft.collection?.name === collectionValue);
        console.log('After collection filter:', filteredNFTs.length, 'NFTs');

        let allCurated = true;
        let allNonCurated = true;
        let allCronos = true;
        let allCronosPos = true;

        filteredNFTs.forEach(nft => {
            const isCurated = nft.isCurated !== undefined ? nft.isCurated : false;
            const isExternalNft = nft.isExternalNft;
            const network = nft.externalNftMetadata?.network?.toUpperCase() || '';

            if (!isCurated) allCurated = false;
            if (isCurated) allNonCurated = false;
            if (isExternalNft !== true || network !== 'CRONOS') allCronos = false;
            if (isExternalNft !== false) allCronosPos = false;
        });

        curatedFilter.value = allCurated ? 'true' : allNonCurated ? 'false' : '';
        curatedFilter.disabled = true;
        chainFilter.value = allCronos ? 'CRONOS' : allCronosPos ? 'CRONOS_POS' : '';
        chainFilter.disabled = true;
        hasSelectedSpecificCollection = true; // Indiquer qu'une collection sp√©cifique a √©t√© s√©lectionn√©e
        console.log('CURATION filter: value=', curatedFilter.value, 'disabled=', curatedFilter.disabled);
        console.log('CHAINS filter: value=', chainFilter.value, 'disabled=', chainFilter.disabled);
    } else {
        // Lorsque "ALL Collections" est s√©lectionn√©
        chainFilter.disabled = false;
        curatedFilter.disabled = false;
        if (hasSelectedSpecificCollection) {
            // R√©initialiser les filtres √† "ALL" une seule fois apr√®s une collection sp√©cifique
            chainFilter.value = '';
            curatedFilter.value = '';
            hasSelectedSpecificCollection = false; // R√©initialiser pour √©viter une nouvelle r√©initialisation
            console.log('ALL Collections selected after specific collection: CURATION reset to value=', curatedFilter.value, 'disabled=', curatedFilter.disabled);
            console.log('ALL Collections selected after specific collection: CHAINS reset to value=', chainFilter.value, 'disabled=', curatedFilter.disabled);
        } else {
            console.log('ALL Collections selected: CURATION value=', curatedFilter.value, 'disabled=', curatedFilter.disabled);
            console.log('ALL Collections selected: CHAINS value=', chainFilter.value, 'disabled=', chainFilter.disabled);
        }
    }

    // Apply CHAINS filter if a value is selected
    if (chainFilter.value) {
        filteredNFTs = filteredNFTs.filter(nft => {
            const isExternalNft = nft.isExternalNft;
            const network = nft.externalNftMetadata?.network?.toUpperCase() || '';
            if (chainFilter.value === 'CRONOS') {
                return isExternalNft === true && network === 'CRONOS';
            } else if (chainFilter.value === 'CRONOS_POS') {
                return isExternalNft === false;
            }
            return true;
        });
        console.log('After chain filter:', filteredNFTs.length, 'NFTs');
    }

    // Apply CURATION filter if a value is selected
    if (curatedFilter.value) {
        filteredNFTs = filteredNFTs.filter(nft => {
            const isCurated = nft.isCurated !== undefined ? nft.isCurated : false;
            return curatedFilter.value === 'true' ? isCurated : curatedFilter.value === 'false' ? !isCurated : true;
        });
        console.log('After curated filter:', filteredNFTs.length, 'NFTs');
    }

    // Apply sorting
    const sortValue = sortBy.value || 'newest';
    console.log('Selected sort value:', sortValue);
    if (sortValue === 'rank') {
        filteredNFTs.sort((a, b) => (a.defaultRarityRank || Infinity) - (b.defaultRarityRank || Infinity));
    } else if (sortValue === 'oldest') {
        filteredNFTs.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
    } else {
        filteredNFTs.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    }

    console.log('Final filtered NFTs:', filteredNFTs.length, 'for collection:', collectionValue || 'All', 'chain:', chainFilter.value || 'All', 'curated:', curatedFilter.value || 'All');

    collectionTitle.textContent = collectionValue || 'All Collections';
    collectionTitle.classList.add('visible');

    displayNFTs(filteredNFTs, collectionValue);
}

function displayNFTs(assets, selectedCollection) {
    const container = document.getElementById('nftContainer');
    const countContainer = document.getElementById('nftCountContainer');
    const downloadZipButton = document.getElementById('downloadZipButton');
    const downloadCollageButton = document.getElementById('downloadCollageButton');
    const cardSize = document.getElementById('cardSize')?.value || 'small';

    if (!container || !countContainer || !downloadZipButton || !downloadCollageButton) {
        console.error('NFT container, count container, or download buttons not found');
        return;
    }

    console.log('Displaying NFTs:', assets.length, 'assets for collection:', selectedCollection || 'All');

    countContainer.innerHTML = '';
    container.innerHTML = '';
    container.className = `nft-container thumbnail-mode ${cardSize}-size`;

    const countElement = document.createElement('p');
    countElement.className = 'nft-count';
    countElement.innerHTML = selectedCollection
        ? `<span style="color: var(--color1);">${currentUsername.toUpperCase()}</span> has <span class="count">${assets.length}</span> assets on this collection.`
        : `<span style="color: var(--color1);">${currentUsername.toUpperCase()}</span> has <span class="count">${assets.length}</span> assets.`;
    countContainer.appendChild(countElement);

    downloadZipButton.style.display = assets.length > 0 && currentUsername ? 'inline-block' : 'none';
    downloadCollageButton.style.display = assets.length > 0 && currentUsername ? 'inline-block' : 'none';
    if (assets.length > 0) {
        downloadZipButton.textContent = `DOWNLOAD ${assets.length} ASSETS`;
    }

    assets.forEach((asset, index) => {
        const imageUrl = asset.cover?.url || 'https://via.placeholder.com/150';
        const card = document.createElement('div');
        card.className = 'nft-card';

        let mediaElement;
        if (imageUrl.endsWith('.mp4')) {
            mediaElement = document.createElement('video');
            mediaElement.src = imageUrl;
            mediaElement.controls = true;
            mediaElement.muted = true;
            mediaElement.loop = true;
            mediaElement.setAttribute('playsinline', '');
        } else {
            mediaElement = document.createElement('img');
            mediaElement.src = imageUrl;
            mediaElement.alt = asset.name || 'NFT Image';
            mediaElement.loading = 'lazy';
            mediaElement.decoding = 'async';
            mediaElement.sizes = '(max-width: 768px) 80px, 200px';
        }

        mediaElement.onerror = () => {
            console.error('Media failed to load for asset:', asset.name || 'Unnamed');
            card.innerHTML = '';
            const placeholder = document.createElement('div');
            placeholder.className = 'media-placeholder';
            placeholder.textContent = 'M√©dia indisponible';
            card.appendChild(placeholder);
        };

        const tooltip = document.createElement('span');
        tooltip.className = 'tooltip';
        tooltip.textContent = asset.name && asset.name.trim() !== '' ? asset.name : 'Unnamed NFT';
        card.appendChild(tooltip);

        // Ajout du bouton de t√©l√©chargement avec ic√¥ne SVG
        if (imageUrl !== 'https://via.placeholder.com/150') {
            const downloadButton = document.createElement('button');
            downloadButton.className = 'download-nft-btn';
            downloadButton.title = 'Download NFT';
            downloadButton.innerHTML = `
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                </svg>
            `;
            downloadButton.onclick = () => downloadSingleNFT(imageUrl, asset.name || `NFT_${index + 1}`);
            card.appendChild(downloadButton);
        }

        card.appendChild(mediaElement);
        container.appendChild(card);
    });

    // Appeler updateDisplay apr√®s avoir cr√©√© les cartes pour recalculer la grille
    updateDisplay();
}

async function fetchWithRetry(url, retries = 3, delay = 1000) {
    for (let i = 0; i < retries; i++) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // Timeout de 30s
            const response = await fetch(url, {
                method: 'GET',
                mode: 'cors',
                cache: 'no-cache',
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            if (!response.ok) {
                if (response.status === 429 && i < retries - 1) {
                    console.log(`Rate limit hit for ${url}, retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                    continue;
                }
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }
            return response;
        } catch (error) {
            if (i === retries - 1) throw error;
        }
    }
}

async function downloadSingleNFT(url, name, index) {
    const errorDiv = document.getElementById('error');
    if (!errorDiv) {
        console.error('Error div not found');
        return;
    }

    try {
        const response = await fetchWithRetry(url, 3, 2000);
        if (!response.ok) {
            throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
        }
        const contentType = response.headers.get('content-type');
        let extension = 'png';
        if (contentType.includes('video/mp4')) {
            extension = 'mp4';
        } else if (contentType.includes('image/jpeg')) {
            extension = 'jpg';
        } else if (contentType.includes('image/gif')) {
            extension = 'gif';
        } else if (!contentType.includes('image/png')) {
            throw new Error(`Unsupported file type: ${contentType}`);
        }
        const blob = await response.blob();
        if (!blob || blob.size === 0) {
            throw new Error('Received empty or invalid blob');
        }
        console.log(`Downloading ${name}: URL=${url}, Content-Type=${contentType}, Status=${response.status}`);
        const sanitizedName = sanitizeFileNameForZip(name, index);
        const fileName = `${sanitizedName}.${extension}`;
        const urlObj = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = urlObj;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(urlObj);
    } catch (error) {
        console.error(`Error downloading NFT ${name}: ${error.message}`);
        errorDiv.textContent = `Failed to download ${name}: ${error.message}`;
        setTimeout(() => errorDiv.textContent = '', 5000);
    }
}

async function downloadNFTsAsZip() {
    const zip = new JSZip();
    const nftContainer = document.getElementById('nftContainer');
    const errorDiv = document.getElementById('error');
    const progressModal = document.getElementById('progressModal');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const modalTitle = document.getElementById('modalTitle');
    const cancelButton = document.getElementById('cancelDownloadButton');

    if (!nftContainer || !errorDiv || !progressModal || !progressBar || !progressText || !modalTitle || !cancelButton) {
        console.error('Required DOM elements for download not found');
        if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
        return;
    }

    const filteredNFTs = Array.from(nftContainer.querySelectorAll('.nft-card')).map((card, index) => {
        const img = card.querySelector('img');
        const video = card.querySelector('video');
        const titleElement = card.querySelector('h3') || card.querySelector('.tooltip');
        const title = titleElement ? titleElement.textContent : `NFT_${index + 1}`;
        return {
            url: img ? img.src : video ? video.src : null,
            name: title,
        };
    }).filter(nft => nft.url && nft.url !== 'https://via.placeholder.com/150');

    if (filteredNFTs.length === 0) {
        errorDiv.textContent = 'No valid assets to download.';
        return;
    }

    modalTitle.textContent = 'Creating ZIP File';
    progressText.textContent = `Preparing ${filteredNFTs.length} assets`;
    progressBar.style.width = '0%';
    progressModal.style.display = 'flex';
    cancelButton.style.display = 'block';

    isDownloadCancelled = false;
    cancelButton.onclick = () => {
        isDownloadCancelled = true;
        progressText.textContent = 'Download cancelled.';
        progressBar.style.width = '0%';
        setTimeout(() => {
            progressModal.style.display = 'none';
        }, 1000);
    };

    let processed = 0;
    for (const [index, nft] of filteredNFTs.entries()) {
        if (isDownloadCancelled) {
            console.log('Download cancelled by user');
            return;
        }

        try {
            const response = await fetch(nft.url);
            if (!response.ok) {
                console.error(`Failed to fetch asset ${nft.name}: ${response.statusText}`);
                continue;
            }
            const blob = await response.blob();
            const extension = nft.url.endsWith('.mp4') ? 'mp4' : 'png';
            const sanitizedName = sanitizeFileNameForZip(nft.name);
            const fileName = `${sanitizedName}.${extension}`;
            zip.file(fileName, blob);
            processed++;
            const progressPercent = (processed / filteredNFTs.length) * 100;
            progressBar.style.width = `${progressPercent}%`;
            progressText.textContent = `Downloading: ${processed}/${filteredNFTs.length}`;
        } catch (error) {
            console.error(`Error downloading ${nft.name}: ${error.message}`);
        }
    }

    if (isDownloadCancelled) {
        console.log('Download process aborted');
        return;
    }

    if (processed === 0) {
        progressModal.style.display = 'none';
        errorDiv.textContent = 'No assets could be downloaded';
        return;
    }

    progressText.textContent = 'Generating ZIP file';
    try {
        const content = await zip.generateAsync({ type: 'blob' });
        saveAs(content, `${currentUsername}_nfts.zip`);
        progressText.textContent = 'Download complete!';
        progressBar.style.width = '100%';
        setTimeout(() => {
            progressModal.style.display = 'none';
        }, 1000);
    } catch (error) {
        console.error(`Error generating ZIP: ${error.message}`);
        progressModal.style.display = 'none';
        errorDiv.textContent = 'Failed to generate ZIP file';
    }
}

async function downloadCollage() {
    const nftContainer = document.getElementById('nftContainer');
    const errorDiv = document.getElementById('error');
    const progressModal = document.getElementById('progressModal');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const modalTitle = document.getElementById('modalTitle');
    const cancelButton = document.getElementById('cancelDownloadButton');

    if (!nftContainer || !errorDiv || !progressModal || !progressBar || !progressText || !modalTitle || !cancelButton) {
        console.error('Required DOM elements for collage download not found');
        if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
        return;
    }

    const cards = nftContainer.querySelectorAll('.nft-card:not(.empty)');
    if (cards.length === 0) {
        errorDiv.textContent = 'No assets to include in the collage.';
        return;
    }

    modalTitle.textContent = 'Creating Collage';
    progressText.textContent = `Preparing collage with ${cards.length} assets`;
    progressBar.style.width = '0%';
    progressModal.style.display = 'flex';
    cancelButton.style.display = 'block';

    isDownloadCancelled = false;
    cancelButton.onclick = () => {
        isDownloadCancelled = true;
        progressText.textContent = 'Collage creation cancelled.';
        progressBar.style.width = '0%';
        setTimeout(() => {
            progressModal.style.display = 'none';
        }, 1000);
    };

    try {
        const gridSize = Math.ceil(Math.sqrt(cards.length));
        const imageSize = 300;
        const canvas = document.createElement('canvas');
        canvas.width = gridSize * imageSize;
        canvas.height = gridSize * imageSize;
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = '#333';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let processed = 0;
        for (let i = 0; i < cards.length; i++) {
            if (isDownloadCancelled) {
                console.log('Collage creation cancelled');
                return;
            }

            const card = cards[i];
            const img = card.querySelector('img');
            const video = card.querySelector('video');
            let mediaUrl = img ? img.src : video ? video.currentSrc : null;

            if (!mediaUrl || mediaUrl === 'https://via.placeholder.com/150') {
                console.warn(`Invalid media for card ${i + 1}`);
                processed++;
                continue;
            }

            try {
                const response = await fetch(mediaUrl + (mediaUrl.includes('?') ? '&' : '?') + 'quality=high');
                if (!response.ok) {
                    console.error(`Failed to fetch media for card ${i + 1}: ${response.statusText}`);
                    processed++;
                    continue;
                }
                const blob = await response.blob();
                const imageBitmap = await createImageBitmap(blob);

                const row = Math.floor(i / gridSize);
                const col = i % gridSize;
                ctx.drawImage(imageBitmap, col * imageSize, row * imageSize, imageSize, imageSize);
                imageBitmap.close();

                processed++;
                const progressPercent = (processed / cards.length) * 100;
                progressBar.style.width = `${progressPercent}%`;
                progressText.textContent = `Processing: ${processed}/${cards.length}`;
            } catch (error) {
                console.error(`Error processing media for card ${i + 1}: ${error.message}`);
                processed++;
            }
        }

        if (isDownloadCancelled) {
            console.log('Collage creation aborted');
            return;
        }

        if (processed === 0) {
            progressModal.style.display = 'none';
            errorDiv.textContent = 'No valid assets could be included in the collage';
            return;
        }

        progressText.textContent = 'Generating collage image';
        canvas.toBlob((blob) => {
            saveAs(blob, `${currentUsername}_collage.png`);
            progressText.textContent = 'Collage download complete!';
            progressBar.style.width = '100%';
            setTimeout(() => {
                progressModal.style.display = 'none';
            }, 1000);
        }, 'image/png', 1.0);
    } catch (error) {
        console.error(`Error generating collage: ${error.message}`);
        progressModal.style.display = 'none';
        errorDiv.textContent = 'Failed to generate collage image';
    }
}

function updateDisplay() {
    const cardSize = document.getElementById('cardSize')?.value || 'small';
    const nftContainer = document.getElementById('nftContainer');

    if (!nftContainer) {
        console.error('Conteneur NFT non trouv√©');
        return;
    }

    nftContainer.className = `nft-container thumbnail-mode ${cardSize}-size`;

    // D√©finir les tailles de base des cartes et l'√©cart (gap)
    const baseCardWidth = cardSize === 'small' ? 110 : cardSize === 'medium' ? 180 : 280;
    const isMobile = window.innerWidth <= 768;
    const isVerySmallScreen = window.innerWidth <= 480;
    const gap = isVerySmallScreen ? 6 : isMobile ? 10 : 4;

    // Marges fixes de nftContainer (50px √† gauche, 50px √† droite)
    const marginLeft = 50;
    const marginRight = 50;
    const totalMargin = marginLeft + marginRight;

    // Calculer la largeur disponible : largeur de la fen√™tre - marges
    const availableWidth = document.documentElement.clientWidth - totalMargin;

    // Calculer le nombre de colonnes initial
    const columnWidthWithGap = baseCardWidth + gap;
    let numColumns = Math.floor((availableWidth + gap) / columnWidthWithGap);
    numColumns = Math.max(1, numColumns); // Minimum 1 colonne

    // Calculer la largeur ajust√©e des colonnes
    const totalGaps = (numColumns - 1) * gap;
    let adjustedColumnWidth = (availableWidth - totalGaps) / numColumns;

    // Appliquer des contraintes de taille minimale/maximale
    const minWidth = baseCardWidth * 0.8; // 80% de la taille de base
    let maxWidth = baseCardWidth * 1.2; // 120% de la taille de base par d√©faut
    if (cardSize === 'large') {
        maxWidth = baseCardWidth * 1.5; // Assouplir la contrainte pour mode large (150%)
    }
    adjustedColumnWidth = Math.min(Math.max(adjustedColumnWidth, minWidth), maxWidth);

    // R√©ajuster le nombre de colonnes si la largeur totale d√©passe availableWidth
    let totalWidthWithAdjusted = numColumns * adjustedColumnWidth + totalGaps;
    if (totalWidthWithAdjusted > availableWidth) {
        numColumns = Math.max(1, numColumns - 1);
        const newTotalGaps = (numColumns - 1) * gap;
        adjustedColumnWidth = (availableWidth - newTotalGaps) / numColumns;
        adjustedColumnWidth = Math.min(Math.max(adjustedColumnWidth, minWidth), maxWidth);
        totalWidthWithAdjusted = numColumns * adjustedColumnWidth + newTotalGaps;
    }

    // Maximiser l'espace en mode "large" si l'espace est sous-utilis√©
    if (cardSize === 'large' && totalWidthWithAdjusted < availableWidth * 0.95) {
        // Si l'espace utilis√© est inf√©rieur √† 95% de la largeur disponible, augmenter la largeur des colonnes
        adjustedColumnWidth = (availableWidth - totalGaps) / numColumns;
        adjustedColumnWidth = Math.min(Math.max(adjustedColumnWidth, minWidth), maxWidth);
        totalWidthWithAdjusted = numColumns * adjustedColumnWidth + totalGaps;
    }

    // Appliquer la grille
    nftContainer.style.gridTemplateColumns = `repeat(${numColumns}, ${adjustedColumnWidth}px)`;

    // V√©rifier si la grille d√©passe la marge droite
    const containerRect = nftContainer.getBoundingClientRect();
    const windowRightEdge = document.documentElement.clientWidth - marginRight;
    if (containerRect.right > windowRightEdge + 1) {
        console.warn(`D√©bordement d√©tect√©: container.right=${containerRect.right}px, windowRightEdge=${windowRightEdge}px`);
        numColumns = Math.max(1, numColumns - 1);
        const newTotalGaps = (numColumns - 1) * gap;
        adjustedColumnWidth = (availableWidth - newTotalGaps) / numColumns;
        adjustedColumnWidth = Math.min(Math.max(adjustedColumnWidth, minWidth), maxWidth);
        nftContainer.style.gridTemplateColumns = `repeat(${numColumns}, ${adjustedColumnWidth}px)`;
    }

    // Forcer un recalcul du layout
    nftContainer.style.display = 'none';
    nftContainer.offsetHeight; // Forcer un reflow
    nftContainer.style.display = 'grid';

    // D√©bogage visuel
    console.log(`updateDisplay: clientWidth=${document.documentElement.clientWidth}px, marginLeft=${marginLeft}px, marginRight=${marginRight}px, availableWidth=${availableWidth}px, numColumns=${numColumns}, adjustedColumnWidth=${adjustedColumnWidth}px, totalWidth=${totalWidthWithAdjusted}px, container.right=${nftContainer.getBoundingClientRect().right}px, expectedRightEdge=${windowRightEdge}px`);
}

function setupEventListeners() {
    const usernameInput = document.getElementById('usernameInput');
    const loginUsernameInput = document.getElementById('loginUsernameInput');
    const themeButton = document.getElementById('themeButton');
    const collectionFilter = document.getElementById('collectionFilter');
    const chainFilter = document.getElementById('chainFilter');
    const curatedFilter = document.getElementById('curatedFilter');
    const cardSize = document.getElementById('cardSize');
    const sortBy = document.getElementById('sortBy');
    const navbarMenu = document.getElementById('navbarMenu');
    const cancelLoginButton = document.getElementById('cancelLoginButton');
    const myProfileLink = document.getElementById('myProfileLink');
    const logoutLink = document.getElementById('logoutLink');
    const loginLink = document.getElementById('loginLink');
    const scrollToTopButton = document.getElementById('scrollToTopButton');
    const scrollToBottomButton = document.getElementById('scrollToBottomButton');
    const navbarToggle = document.querySelector('.navbar-toggle');
    const downloadZipButton = document.getElementById('downloadZipButton');
    const downloadCollageButton = document.getElementById('downloadCollageButton');

    // V√©rification des √©l√©ments DOM critiques
    if (!usernameInput || !loginUsernameInput || !themeButton || !collectionFilter || 
        !chainFilter || !curatedFilter || !cardSize || !sortBy || !navbarMenu || 
        !cancelLoginButton || !myProfileLink || !logoutLink || !loginLink || !navbarToggle || 
        !downloadZipButton || !downloadCollageButton) {
        console.error('One or more DOM elements not found', {
            usernameInput: !!usernameInput,
            loginUsernameInput: !!loginUsernameInput,
            themeButton: !!themeButton,
            collectionFilter: !!collectionFilter,
            chainFilter: !!chainFilter,
            curatedFilter: !!curatedFilter,
            cardSize: !!cardSize,
            sortBy: !!sortBy,
            navbarMenu: !!navbarMenu,
            cancelLoginButton: !!cancelLoginButton,
            myProfileLink: !!myProfileLink,
            logoutLink: !!logoutLink,
            loginLink: !!loginLink,
            navbarToggle: !!navbarToggle,
            downloadZipButton: !!downloadZipButton,
            downloadCollageButton: !!downloadCollageButton
        });
        const errorDiv = document.getElementById('error');
        if (errorDiv) errorDiv.textContent = 'Internal error: UI elements missing.';
        return;
    }

    // V√©rification sp√©cifique pour les boutons de d√©filement
    if (!scrollToTopButton || !scrollToBottomButton) {
        console.warn('Scroll buttons not found in DOM', {
            scrollToTopButton: !!scrollToTopButton,
            scrollToBottomButton: !!scrollToBottomButton
        });
    }

    // Gestion du basculement du th√®me
    themeButton.addEventListener('click', toggleTheme);
    console.log('Theme button listener attached');

    // Gestion du menu mobile (bouton hamburger)
    console.log('Attaching listeners to navbar toggle');
    navbarToggle.addEventListener('click', (e) => {
        console.log('Click event on navbar toggle');
        toggleMenu(e);
    });
    navbarToggle.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Emp√™cher le double d√©clenchement ou le zoom
        console.log('Touchstart event on navbar toggle');
        toggleMenu(e);
    }, { passive: false });

    // Gestion de la recherche principale
    usernameInput.addEventListener('input', debounce(async (e) => {
        const query = sanitizeInput(e.target.value);
        if (query.length > 2) {
            await searchProfiles(query);
        } else {
            clearSuggestions();
        }
    }, 300));
    console.log('Main search input listener attached');

    // R√©activer les suggestions sur focus si texte pr√©sent
    usernameInput.addEventListener('focus', async () => {
        const query = sanitizeInput(usernameInput.value);
        if (query.length > 2) {
            console.log('Search input focused, querying:', query);
            await searchProfiles(query);
        }
    });

    // Gestion de la recherche dans le modal de connexion
    loginUsernameInput.addEventListener('input', debounce(async (e) => {
        const query = sanitizeInput(e.target.value);
        if (query.length > 2) {
            console.log('Login input event:', query);
            await searchLoginProfiles(query);
        } else {
            clearLoginSuggestions();
        }
    }, 300));
    console.log('Login search input listener attached');

    // R√©activer les suggestions sur focus si texte pr√©sent dans le modal
    loginUsernameInput.addEventListener('focus', async () => {
        const query = sanitizeInput(loginUsernameInput.value);
        if (query.length > 2) {
            console.log('Login input focused, querying:', query);
            await searchLoginProfiles(query);
        }
    });

    // Gestion des clics pour les suggestions et les clics en dehors
    document.addEventListener('click', (e) => {
        const suggestions = document.getElementById('suggestions');
        const loginSuggestions = document.getElementById('loginSuggestions');
        const availableFeaturesModal = document.getElementById('availableFeaturesModal');
        const inProgressModal = document.getElementById('inProgressModal');

        // V√©rifier si le clic est sur une suggestion
        if (e.target.classList.contains('suggestion-item') || e.target.closest('.suggestion-item')) {
            const suggestionItem = e.target.closest('.suggestion-item');
            const username = suggestionItem.dataset.username;
            const avatar = suggestionItem.dataset.avatar;
            const isLoginModal = suggestionItem.closest('#loginModal');
            console.log('Suggestion clicked:', { username, isLoginModal });
            if (isLoginModal) {
                selectLoginSuggestion(username, avatar);
            } else {
                selectSuggestion(username);
            }
            return;
        }

        // V√©rifier si le clic est dans une modale de mise √† jour
        const isUpdateModalClick = (availableFeaturesModal && availableFeaturesModal.contains(e.target)) ||
                                  (inProgressModal && inProgressModal.contains(e.target));

        // V√©rifier si le clic est en dehors de la barre de recherche et des suggestions
        const isMainSearchClick = usernameInput.contains(e.target);
        const isMainSuggestionsClick = suggestions && suggestions.contains(e.target);
        const isLoginSearchClick = loginUsernameInput.contains(e.target);
        const isLoginSuggestionsClick = loginSuggestions && loginSuggestions.contains(e.target);

        if (!isMainSearchClick && !isMainSuggestionsClick && !isUpdateModalClick) {
            clearSuggestions();
        }

        if (!isLoginSearchClick && !isLoginSuggestionsClick && !isUpdateModalClick) {
            clearLoginSuggestions();
        }
    });
    console.log('Document click listener for suggestions attached');

    // Gestion des filtres
    collectionFilter.addEventListener('change', filterNFTs);
    chainFilter.addEventListener('change', filterNFTs);
    curatedFilter.addEventListener('change', filterNFTs);
    cardSize.addEventListener('change', updateDisplay);
    sortBy.addEventListener('change', filterNFTs);
    console.log('Filter listeners attached');

    // Gestion du modal de connexion
    loginLink.addEventListener('click', showLoginModal);
    console.log('Login link listener attached');

    cancelLoginButton.addEventListener('click', resetLoginForm);
    console.log('Cancel login button listener attached');

    // Gestion du profil et d√©connexion
    myProfileLink.addEventListener('click', (e) => {
        e.preventDefault();
        if (loggedInUser?.username) {
            console.log('My Profile clicked, fetching for:', loggedInUser.username);
            fetchProfileAndNFTsForLogin(loggedInUser.username);
        }
    });
    console.log('My profile link listener attached');

    logoutLink.addEventListener('click', logout);
    console.log('Logout link listener attached');

    // Gestion des boutons de t√©l√©chargement
    downloadZipButton.addEventListener('click', downloadNFTsAsZip);
    downloadCollageButton.addEventListener('click', downloadCollage);
    console.log('Download buttons listeners attached');

    // Gestion des boutons de d√©filement
    const toggleScrollButtons = () => {
        const scrollY = window.scrollY;
        const windowHeight = window.innerHeight;
        const documentHeight = document.documentElement.scrollHeight;
        const isScrollable = documentHeight > windowHeight + 100;

        const showTopButton = isScrollable && scrollY > 200;
        scrollToTopButton.style.display = showTopButton ? 'block' : 'none';
        scrollToTopButton.classList.toggle('visible', showTopButton);

        const isAtBottom = scrollY + windowHeight >= documentHeight - 10;
        const showBottomButton = isScrollable && !isAtBottom;
        scrollToBottomButton.style.display = showBottomButton ? 'block' : 'none';
        scrollToBottomButton.classList.toggle('visible', showBottomButton);

        console.log('toggleScrollButtons:', {
            scrollY,
            windowHeight,
            documentHeight,
            isScrollable,
            showTopButton,
            showBottomButton
        });
    };

    window.addEventListener('scroll', toggleScrollButtons);
    window.addEventListener('resize', toggleScrollButtons);

    const observer = new MutationObserver(toggleScrollButtons);
    observer.observe(document.body, { childList: true, subtree: true });

    scrollToTopButton.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
        console.log('Scroll to top clicked');
    });

    scrollToBottomButton.addEventListener('click', () => {
        window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'smooth' });
        console.log('Scroll to bottom clicked');
    });

    toggleScrollButtons();
    console.log('Scroll buttons listeners and observer attached');
}

function initialize() {
    const savedTheme = localStorage.getItem('theme') || 'dark';
    const initialTheme = savedTheme === 'light' ? 'cdc' : savedTheme;
    document.documentElement.setAttribute('data-theme', initialTheme);
    const themeButton = document.getElementById('themeButton');
    if (themeButton) {
        themeButton.textContent = initialTheme === 'dark' ? 'CDC' : 'Dark';
    }

    const savedUser = localStorage.getItem('loggedInUser');
    if (savedUser) {
        try {
            loggedInUser = JSON.parse(savedUser);
            updateLoginLink();
        } catch (error) {
            console.error('Error parsing saved user:', error);
            localStorage.removeItem('loggedInUser');
        }
    }

    resetSearchBar(); // R√©initialiser la barre de recherche au chargement

    // Afficher les fen√™tres des mises √† jour sur la page d'accueil
    const availableFeaturesModal = document.getElementById('availableFeaturesModal');
    const inProgressModal = document.getElementById('inProgressModal');
    const { username, collection } = parseUrlHash();
    if (availableFeaturesModal && inProgressModal && !username) {
        availableFeaturesModal.style.display = 'block';
        inProgressModal.style.display = 'block';
        console.log('Update modals displayed on home page');
    }

    if (username) {
        const usernameInput = document.getElementById('usernameInput');
        if (usernameInput) {
            usernameInput.value = username;
            fetchProfileAndNFTs();
        }
    }

    setupEventListeners();

    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(updateDisplay, 100);
    });

    updateDisplay();

    window.addEventListener('popstate', () => {
        const { username, collection } = parseUrlHash();
        if (username) {
            const usernameInput = document.getElementById('usernameInput');
            if (usernameInput) {
                usernameInput.value = username;
                fetchProfileAndNFTs();
            }
        }
    });
}

document.addEventListener('DOMContentLoaded', initialize);
    </script></body>
</html>
